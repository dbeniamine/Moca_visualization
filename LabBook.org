#+TITLE: Beniamine's LabBook
#+AUTHOR: Beniamine
#+LATEX_HEADER: \usepackage[margin=2cm,a4paper]{geometry}
#+STARTUP: overview indent
#+TAGS: Lucas(L) David(D) noexport(n) deprecated(d)
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+SEQ_TODO: TODO(t!) STARTED(s!) WAITING(w!) | DONE(d!) CANCELLED(c!) DEFERRED(f!)

* 2016-02-17 Memory access along time (from MOCA)

David's traces have only variables. We should look to them as states.

So convert accordingly:

#+begin_src bash :results output :session :exports both
grep ^Variable Moca_matrix_bloc_20160217_Virt.pjdump | 
   awk -F, '{print "State,"$2",access,"$4","$5","$6",0,"$3}' > states_Virt.csv
grep ^Variable Moca_matrix_bloc_20160217_Phy.pjdump | 
   awk -F, '{print "State,"$2",access,"$4","$5","$6",0,"$3}' > states_Phy.csv
#+END_SRC

#+RESULTS:

Great, now let's load them into R.

#+begin_src R :results output :session :exports both
read_paje_trace <- function(file) {
  df <- read.csv(file, header=FALSE, strip.white=TRUE)
  names(df) <- c("Nature","ResourceId","Type","Start","End","Duration", "Depth", "Value")
  df$Origin=file
  m <- min(df$Start)
  df$Start <- df$Start - m
  df$End <- df$Start+df$Duration
  df$Origin <- NULL
  df$Nature <- NULL
  df$Depth <- NULL
  df
}
df_Virt <- read_paje_trace("states_Virt.csv");
df_Phy <- read_paje_trace("states_Phy.csv");
#+end_src

#+RESULTS:

#+begin_src R :results output :session :exports both
nrow(df_Virt);
nrow(df_Phy);
#+end_src

#+RESULTS:
: [1] 4478461
: [1] 4472513

The largest dataframes I have ever seen.

Let's play with care.

#+begin_src R :results output graphics :file (org-babel-temp-file "figure" ".png") :exports both :width 600 :height 400 :session
library(ggplot2);
df <- df_Virt;
df <- df[df$ResourceId == 140737310789152, ];
p <- ggplot(df) +
  theme_bw() +
  geom_segment(size=15, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId), color="black") +
  geom_segment(size=13, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value)) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[file:/tmp/babel-9357QOL/figure9357w0Z.png]]


Strange. Let's see how many *Shared_read* there are.

#+begin_src R :results output :session :exports both
nrow(df[df$Value == "Private_Read" & df$Start < 200000 & df$Start > 150000,]);
nrow(df[df$Value == "Shared_Read" & df$Start < 180000 & df$Start > 210000,]);
df[df$Start > 180000 & df$Start < 210000,]
#+end_src

#+RESULTS:
: [1] 0
: [1] 0
:          ResourceId   Type  Start    End Duration       Value
: 289172 1.407373e+14 access 189573 221868    32295 Shared_Read
: 289173 1.407373e+14 access 189573 221868    32295 Shared_Read
: 289174 1.407373e+14 access 189573 221868    32295 Shared_Read
: 289175 1.407373e+14 access 189573 221868    32295 Shared_Read

Lot's of them for this particular address. Let's zoom in.

#+begin_src R :results output graphics :file img/virt_first_try_2.png :exports both :width 600 :height 400 :session
library(ggplot2);
df <- df_Virt;
df <- df;
p <- ggplot(df) +
  theme_bw() +
  geom_segment(size=13, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value), alpha=.4) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[file:img/first_try_2.png]]



#+begin_src R :results output graphics :file img/phy_first_try_1.png :exports both :width 600 :height 400 :session
library(ggplot2);
df <- df_Phy;
df <- df;
p <- ggplot(df) +
  theme_bw() +
  geom_segment(size=13, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value), alpha=.4) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[file:img/phy_first_try_1.png]]


* 2016-02-17 Calculating intensity

_First Attempt_

I'll try with bash.

#+begin_src bash :results output :session :exports both
cat states_Virt.csv  | grep Shared_Read > states_Virt_shared_read.csv
cat states_Virt_shared_read.csv | cut -d, -f2 | sort | uniq > add_Virt
cat states_Virt_shared_read.csv  | cut -d, -f4-6 | sort | uniq  > timeslices

cat states_Virt_shared_read.csv  | cut -d, -f2,4,5,8 > states_Virt_shared_read_essential.csv
cat states_Virt_shared_read_essential.csv  | sort | uniq  > states_Virt_shared_read_essential_unique.csv
while read line ; do echo -n "$line,"; cat states_Virt_shared_read_essential.csv | grep "$line" | wc -l; done < states_Virt_shared_read_essential_unique.csv > states_Virt_shared_read_essential_unique_with_intensity.csv
#+end_src

Done. Just check the file:
+ =states_Virt_shared_read_essential_unique_with_intensity.csv=
You can load with R and play with it.

_Second Attempt_

Actually, I believe I can do it faster and cleaner with R.

#+begin_src R :results output :session :exports both
library(plyr);
k <- read.csv("states_Virt_shared_read.csv", header=FALSE);
options("scipen"=100, "digits"=4);
head(k);
#+end_src

#+RESULTS:
:      V1              V2     V3 V4   V5   V6 V7          V8
: 1 State 140737351871824 access  1 4396 4395  0 Shared_Read
: 2 State 140737351871976 access  1 4396 4395  0 Shared_Read
: 3 State 140737347542408 access  1 4396 4395  0 Shared_Read
: 4 State 140737347542640 access  1 4396 4395  0 Shared_Read
: 5 State 140737488351205 access  1 4396 4395  0 Shared_Read
: 6 State 140737488350713 access  1 4396 4395  0 Shared_Read

#+begin_src R :results output :session :exports both
sapply(k, class);
#+end_src

#+RESULTS:
:        V1        V2        V3        V4        V5        V6        V7        V8 
:  "factor" "numeric"  "factor" "integer" "integer" "integer" "integer"  "factor"

#+begin_src R :results output :session :exports both
names(k) <- c("Nature", "Address", "Type", "Start", "End", "Duration", "Imbric", "Value");
k$Nature <- NULL;
k$Type <- NULL;
k$Imbric <- NULL;
head(k);
#+end_src

#+RESULTS:
:           Address Start  End Duration       Value
: 1 140737351871824     1 4396     4395 Shared_Read
: 2 140737351871976     1 4396     4395 Shared_Read
: 3 140737347542408     1 4396     4395 Shared_Read
: 4 140737347542640     1 4396     4395 Shared_Read
: 5 140737488351205     1 4396     4395 Shared_Read
: 6 140737488350713     1 4396     4395 Shared_Read

#+begin_src R :results output :session :exports both
sapply(k, class);
#+end_src

#+RESULTS:
:   Address     Start       End  Duration     Value 
: "numeric" "integer" "integer" "integer"  "factor"

Do the magic. This command takes time.

#+begin_src R :results output :session :exports both
library(plyr);
g <- ddply(k, .(Address, Start, End, Duration, Value), summarize, N=length(Value));
head(g);
#+end_src

#+RESULTS:
:        Address Start  End Duration       Value N
: 1 1.407374e+14     1 4396     4395 Shared_Read 1
: 2 1.407374e+14     1 4396     4395 Shared_Read 1
: 3 1.407373e+14     1 4396     4395 Shared_Read 1
: 4 1.407373e+14     1 4396     4395 Shared_Read 1
: 5 1.407375e+14     1 4396     4395 Shared_Read 1
: 6 1.407375e+14     1 4396     4395 Shared_Read 1

#+begin_src R :results output :session :exports both
head(g);
sapply(g, class);
#+end_src

#+RESULTS:
:           Address Start  End Duration       Value N
: 1 140737351871824     1 4396     4395 Shared_Read 1
: 2 140737351871976     1 4396     4395 Shared_Read 1
: 3 140737347542408     1 4396     4395 Shared_Read 1
: 4 140737347542640     1 4396     4395 Shared_Read 1
: 5 140737488351205     1 4396     4395 Shared_Read 1
: 6 140737488350713     1 4396     4395 Shared_Read 1
:   Address     Start       End  Duration     Value         N 
: "numeric" "integer" "integer" "integer"  "factor" "integer"

#+begin_src R :results output :session :exports both
summary(g$N);
#+end_src

#+RESULTS:
:    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
:   1.000   2.000   3.000   3.421   5.000   8.000

#+begin_src R :results output :session :exports both
#head(g[g$Address == 140737308215152,]);
head(g[g$Address == 140737312395264,]);
median(g[g$Address > 7000000,]$Address);
#tail(g);
#+end_src

#+RESULTS:
:               Address  Start    End Duration       Value N
: 17014 140737312395264  28278  67005    38727 Shared_Read 3
: 22805 140737312395264  54041  77448    23407 Shared_Read 2
: 30183 140737312395264  67009 126332    59323 Shared_Read 3
: 33031 140737312395264  77453  90227    12774 Shared_Read 2
: 36721 140737312395264  90243 137116    46873 Shared_Read 2
: 50336 140737312395264 126336 171611    45275 Shared_Read 5
: [1] 140737314631680

#+begin_src R :results output graphics :file img/intensity_1_up.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(g[g$Address > 6304416,]) +
  theme_bw() +
  geom_segment(size=7, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_wrap(~Value, ncol=1);# + ylim(139000000000000, NA);
p
#+end_src

#+RESULTS:
[[file:img/intensity_1_up.png]]

I just can't find out the best Y scale. Let's create a histogram of
these addresses.

#+begin_src R :results output :session :exports both
h <- g[g$Address > 7304416,];
h$Address = h$Address - 140737000000000;
head(h);
#+end_src

#+RESULTS:
:     Address Start  End Duration       Value N
: 1 351871824     1 4396     4395 Shared_Read 1
: 2 351871976     1 4396     4395 Shared_Read 1
: 3 347542408     1 4396     4395 Shared_Read 1
: 4 347542640     1 4396     4395 Shared_Read 1
: 5 488351205     1 4396     4395 Shared_Read 1
: 6 488350713     1 4396     4395 Shared_Read 1

#+begin_src R :results output graphics :file img/address_histogram.png :exports both :width 600 :height 400 :session
ggplot(h, aes(Address)) + xlim(300000000, 330000000) + geom_histogram();
#+end_src

#+RESULTS:
[[file:img/address_histogram.png]]

Okay, let's try again.

#+begin_src R :results output graphics :file img/intensity_2.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(h) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_wrap(~Value, ncol=1);# + ylim(300000000, 330000000)
p
#+end_src

#+RESULTS:
[[file:img/intensity_2.png]]


Not that good, need further filtering:

#+begin_src R :results output :session :exports both
summary(h$Address);
#+end_src

#+RESULTS:
:      Min.   1st Qu.    Median      Mean   3rd Qu.      Max. 
: 271000000 310000000 315000000 315000000 319000000 488000000

Let's get only addresses from the 1st to the 3rd Qu.

#+begin_src R :results output graphics :file img/intensity_3.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(h) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_wrap(~Value, ncol=1) + ylim(310000000, 319000000)
p
#+end_src

#+RESULTS:
[[file:img/intensity_3.png]]

Finally. Let's reduce size.

#+begin_src R :results output graphics :file img/intensity_4.png :exports both :width 600 :height 800 :session
library(ggplot2);
p <- ggplot(h) +
  theme_bw() +
  geom_segment(size=0.2, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_wrap(~Value, ncol=1) + ylim(310000000, 319000000)
p
#+end_src

#+RESULTS:
[[file:img/intensity_4.png]]


#+begin_src R :results output graphics :file img/intensity_5.png :exports both :width 600 :height 2000 :session
library(ggplot2);
p <- ggplot(h) +
  theme_bw() +
  geom_segment(size=0.2, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_wrap(~Value, ncol=1) + ylim(310000000, 319000000)
p
#+end_src

#+RESULTS:
[[file:img/intensity_5.png]]

#+begin_src R :results output graphics :file img/intensity_6.png :exports both :width 600 :height 2000 :session
library(ggplot2);
p <- ggplot(h) +
  theme_bw() +
  geom_segment(size=0.5, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_wrap(~Value, ncol=1) + ylim(310000000, 311000000)
p
#+end_src

#+RESULTS:
[[file:img/intensity_6.png]]

** Old Stuff                                                    :deprecated:

Let's make rows unique, since now we have the intensity.

#+begin_src R :results output :session :exports both
h <- unique(g);
#+end_src

#+RESULTS:

#+begin_src R :results output :session :exports both
head(h);
#+end_src

#+RESULTS:
:        Address Start  End Duration       Value N
: 1 1.407374e+14     1 4396     4395 Shared_Read 1
: 2 1.407374e+14     1 4396     4395 Shared_Read 1
: 3 1.407373e+14     1 4396     4395 Shared_Read 1
: 4 1.407373e+14     1 4396     4395 Shared_Read 1
: 5 1.407375e+14     1 4396     4395 Shared_Read 1
: 6 1.407375e+14     1 4396     4395 Shared_Read 1

#+begin_src R :results output graphics :file (org-babel-temp-file "figure" ".png") :exports both :width 600 :height 400 :session
ggplot(h, aes(x=Start, y=N)) + geom_point();
#+end_src

#+RESULTS:
[[file:/tmp/babel-9357QOL/figure9357x8U.png]]

* 2016-02-23 New traces

I got a new tarbal from David, here's its MD5 signature.

#+begin_src sh :results output :session :exports both
md5sum ../Moca-matrix.tgz
#+end_src

#+RESULTS:
: 7a81360ff13bcdd0cb3dc23e5b006805  ../Moca-matrix.tgz

Extracting the data in the =v2= directory.

#+begin_src sh :results output :session :exports both
mkdir -p v2; cd v2; tar xfz ../../Moca-matrix.tgz; mv Moca-matrix-bloc/* .; rm -rf Moca-matrix-bloc;
#+end_src

#+RESULTS:

List contents:

#+begin_src sh :results output :session :exports both
pwd
ls -hl v2
#+end_src

#+RESULTS:
: /home/schnorr/TRACES/david/Moca-matrix-bloc
: total 1.1G
: -rw-r--r-- 1 schnorr schnorr  126 Feb 17 10:54 matrix.stackmap.csv
: -rw-r--r-- 1 schnorr schnorr  331 Feb 17 10:54 matrix.structs.csv
: -rw-r--r-- 1 schnorr schnorr 317M Feb 18 13:31 Moca-framesoc.csv
: -rw-r--r-- 1 schnorr schnorr  94M Feb 17 10:54 Moca-full-trace.csv
: -rw-r--r-- 1 schnorr schnorr 351M Feb 18 14:01 Moca_matrix_bloc_20160218Virt.pjdump
: -rw-r--r-- 1 schnorr schnorr 301M Feb 18 14:31 states

Great, now we are ready to start again.

* 2016-02-23 Playing with new traces

It looks like I only get virtual mem addresses this time. Okay.

#+begin_src sh :results output :session :exports both
cd v2
grep ^Variable Moca_matrix_bloc_20160218Virt.pjdump | 
   awk -F, '{print "State,"$2",access,"$4","$5","$6",0,"$3}' > states_Virt.csv
#+end_src

#+RESULTS:

I have noticed that some durations are negative. See:

#+begin_src sh :results output :session :exports both
cd v2
cat states_Virt.csv | grep "-" | head
#+end_src

#+RESULTS:
#+begin_example
State,140737305567232,access,17863,17762,-101,0,Shared_Read
State,140737305567232,access,17863,17762,-101,0,Shared_Read
State,140737305569152,access,17863,17762,-101,0,Shared_Read
State,140737305599152,access,17863,17762,-101,0,Shared_Read
State,140737305599152,access,17863,17762,-101,0,Shared_Read
State,140737305595904,access,17863,17762,-101,0,Shared_Read
State,140737305611152,access,17863,17762,-101,0,Shared_Read
State,140737305608192,access,17863,17762,-101,0,Shared_Read
State,140737305623152,access,17863,17762,-101,0,Shared_Read
State,140737305623152,access,17863,17762,-101,0,Shared_Read
#+end_example

_Summary_:
- Negative durations (probably an error)

* 2016-02-23 Removing durations with negative values                  :Lucas:

Okay, let's proceed anyway, removing the problem.

#+begin_src sh :results output :session :exports both
cd v2
cat states_Virt.csv | grep -v "-" > states_Virt_without_neg_durations.csv
#+end_src

#+RESULTS:

Great, now let's load it.

#+begin_src R :results output :session :exports both
read_paje_trace <- function(file) {
  df <- read.csv(file, header=FALSE, strip.white=TRUE)
  names(df) <- c("Nature","ResourceId","Type","Start","End","Duration", "Depth", "Value")
  df$Origin=file
  m <- min(df$Start)
  df$Start <- df$Start - m
  df$End <- df$Start+df$Duration
  df$Origin <- NULL
  df$Nature <- NULL
  df$Depth <- NULL
  df
}
df_Virt <- read_paje_trace("v2/states_Virt_without_neg_durations.csv");
#+end_src

#+RESULTS:

#+begin_src R :results output :session :exports both
df <- df_Virt;
df$Type <- NULL;
head(df);
#+end_src

#+RESULTS:
:   ResourceId Start  End Duration         Value
: 1    4656816     0 4395     4395  Private_Read
: 2    6303348     0 4395     4395  Private_Read
: 3    6303348     0 4395     4395 Private_Write
: 4    6303752     0 4395     4395  Private_Read
: 5    6303752     0 4395     4395 Private_Write
: 6    7330440     0 4395     4395  Private_Read

#+begin_src R :results output graphics :file img/Moca_matrix_bloc_20160218Virt_overview.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(df) +
  theme_bw() +
  geom_segment(size=13, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value), alpha=.4) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[./img/Moca_matrix_bloc_20160218Virt_overview.png]]

Let's remove =Shared_Write= and =Private_Write=.

#+begin_src R :results output graphics :file img/Moca_matrix_bloc_20160218Virt_filter_1.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(df[df$Value != "Private_Write" & df$Value != "Shared_Write",]) +
  theme_bw() +
  geom_segment(size=13, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value), alpha=.4) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[file:img/Moca_matrix_bloc_20160218Virt_filter_1.png]]

Let's zoom in to the beginning, reduce segment size:

#+begin_src R :results output graphics :file img/Moca_matrix_bloc_20160218Virt_filter_2.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(df[df$Value != "Private_Write" & df$Value != "Shared_Write",]) +
  theme_bw() +
  geom_segment(size=1, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value), alpha=.4) +
  facet_wrap(~Value, ncol=1) + xlim(0, 90243);
p
#+end_src

#+RESULTS:
[[file:img/Moca_matrix_bloc_20160218Virt_filter_2.png]]

That's strange the middle with nothing. The problem is this:

#+begin_src sh :results output :session :exports both
cat v2/states_Virt_without_neg_durations.csv | cut -d, -f2 | head -n30 | cat -n
#+end_src

#+RESULTS:
#+begin_example
     1	4656816
     2	6303348
     3	6303348
     4	6303752
     5	6303752
     6	7330440
     7	7330440
     8	7341840
     9	7341840
    10	8700368
    11	8700368
    12	8737104
    13	8737104
    14	8784688
    15	8784688
    16	8787648
    17	8787648
    18	8790320
    19	8790320
    20	140152691697344
    21	140152691777685
    22	140152691881456
    23	140152691913632
    24	140152692128528
    25	140152692183424
    26	140152692227168
    27	140152692306624
    28	140152692447204
    29	140152692585408
    30	140152692856576
#+end_example

The first 19 events have very low addresses. All other addresses are
much larger. That's why we have those blank spaces in the plot. We
should remove these low addresses. Sorting these events numerically
indicates that I should look only to addresses between 
140152691697344 and 
140737488351205.

#+begin_src R :results output :session :exports both
sapply(df, class);
#+end_src

#+RESULTS:
: ResourceId      Start        End   Duration      Value 
:  "numeric"  "integer"  "integer"  "integer"   "factor"

Great, we can filter easily.

#+begin_src R :results output graphics :file img/Moca_matrix_bloc_20160218Virt_filter_3.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(
  df[df$Value != "Private_Write" &
  df$Value != "Shared_Write" &
  df$ResourceId >= 140152691697344 &
  df$ResourceId <= 140737488351205,]) +
  theme_bw() +
  geom_segment(size=1, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value), alpha=.4) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[file:img/Moca_matrix_bloc_20160218Virt_filter_3.png]]

That didn't work. Let's create a histogram:


#+begin_src R :results output :session :exports both

#+end_src


#+begin_src R :results output graphics :file img/Moca_matrix_bloc_20160218Virt_ResourceId_histogram.png :exports both :width 600 :height 400 :session
ggplot(df, aes(ResourceId)) + geom_histogram() + theme_bw();
#+end_src

#+RESULTS:
[[file:img/Moca_matrix_bloc_20160218Virt_ResourceId_histogram.png]]

Okay, let's zoom in:


#+begin_src R :results output graphics :file img/Moca_matrix_bloc_20160218Virt_ResourceId_histogram_1.png :exports both :width 600 :height 400 :session
ggplot(df, aes(ResourceId)) + geom_histogram() + theme_bw() + xlim(1.4073e+14,NA);
#+end_src

#+RESULTS:
[[file:img/Moca_matrix_bloc_20160218Virt_ResourceId_histogram_1.png]]

Okay, limits should be =xlim(1.4073e+14,NA)=.

#+begin_src R :results output graphics :file img/Moca_matrix_bloc_20160218Virt_filter_4.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(
  df[df$Value != "Private_Write" &
  df$Value != "Shared_Write" &
  df$ResourceId >= 1.4073e+14,]) +
  theme_bw() +
  geom_segment(size=1, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value), alpha=.4) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[file:img/Moca_matrix_bloc_20160218Virt_filter_4.png]]


Now we are finally going somewhere. ResourceId filtering is essential.

Let's go on, limiting the upper bound.

#+begin_src R :results output graphics :file img/Moca_matrix_bloc_20160218Virt_filter_5.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(
  df[df$Value != "Private_Write" &
  df$Value != "Shared_Write" &
  df$ResourceId >= 1.4073e+14 &
  df$ResourceId <= 1.407374e+14,]) +
  theme_bw() +
  geom_segment(size=1, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value), alpha=.4) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[file:img/Moca_matrix_bloc_20160218Virt_filter_5.png]]

Great. I stop here for now.

The problem for me is to correctly define the Address bounds for the
visualization. Since MOCA dumps really every single memory address
accessed (no matter where), and we don't know which part we should
look for, the prototype should allow an easy search methodology in the
address space (pretty much following what I have done above, but
automatically). Then, and only then, plot things.


Some recomendations:
- filter by memory address in MOCA (if intrusion is acceptable)
- create a script to easily filter by memory address interval
  - automatic address interval selection should be possible

Future analysis methodology:
- I am using alpha values to draw segments, but I shouldn't.
  - Intensity should correlate with number of concurrent mem access.
  - So, a preprocessing of the trace do the magic
    - Take a look at [[*2016-02-17 Calculating intensity][2016-02-17 Calculating intensity]] to see how to
  - Then plot as usual after all this filtering stuff mentioned above

* 2016-02-24 Answers for questions of previous section                :David:
- The filtering on the address space can be done using the structs.csv and stackmaps.csv
that provides addresses, name and size of the various data structures
and stacks. 
In Ocelotl, I usually filter out all the addresses that are not in a
data structure at import time. Still it can be interesting to do it
during the preprocessing phase.
Sadly I realized yesterday that Pin (the tool that I am using to
record data structure addresses) was providing bad addresses, thus the
filter won't work this the trace version two.
This issue is not yet completly fixed but there is a trace with
manually fixed data structure addresses and with the address space
already reduced to data structures:
 https://ligcloud.imag.fr/public.php?service=files&t=13b4b28b657943bdf7c4d31d6a7a18ba
- The idea of Moca is to provide a trace as precise as possible, we don't know a priori what
we are looking for, thus I'd rather avoid filtering during tracing.
- The preprocessing can also be done when we detect sharing, currently when I dectect that
two threads are sharing a page, I create to different accesses. I
could create only one access to the page with a value of two. Still
with this reprensentation, we only now the address of the shared page
and loose the precise addresses of each accesses.

* 2016-02-25 New trace / Redo analysis / Try to be faster in filtering :Lucas:

I have been provided with a new trace.

#+begin_src sh :results output :session :exports both
md5sum matrix.tgz
#+end_src

#+RESULTS:
: 098f7ee5632a20cf82290737e89c3ad2  matrix.tgz

#+begin_src sh :results output :session :exports both
tar xfz matrix.tgz
#+end_src

#+RESULTS:

#+begin_src sh :results output :session :exports both
ls -1 Moca-matrix-bloc-fixaddr/
#+end_src

#+RESULTS:
: matrix.stackmap.csv
: matrix.structs.csv
: Moca-framesoc.csv
: Moca_matrix_bloc_fixaddr_20160222_144532_CET_Physical_6.pjdump
: Moca_matrix_bloc_fixaddr_20160223_172342_CET_Physical_6.pjdump
: Moca_matrix_bloc_fixaddr_20160223_172342_CET_Virtual_7.pjdump

David told me the file =matrix.structs.csv= has information about the
memory addresses of main data structures, the ones I should be looking
for. Here's the contents:

#+begin_src sh :results output :session :exports both
cat Moca-matrix-bloc-fixaddr/matrix.structs.csv
#+end_src

#+RESULTS:
: name,start,sz
: __GI___pthread_keys,2196192,16384
: __pthread_keys,2196192,16384
: UnnamedStruct#0,6303760,5280
: UnnamedStruct#1,6303888,32816
: UnnamedStruct#2,6303888,32816
: /tmp/matrix/matrix_naif.c:122,140737323565072,18000000
: /tmp/matrix/matrix_naif.c:123,140737305563152,18000000
: /tmp/matrix/matrix_naif.c:123,140737287561232,18000000

Great, let's focus our analysis below in addresses starting at
- 140737305563152 up to 140737305563152+18000000

First, convert to =states=, using bash.

#+begin_src sh :results output :session :exports both
UNIQFILE=Moca_matrix_bloc_fixaddr_20160223_172342_CET_Virtual_7
cat Moca-matrix-bloc-fixaddr/${UNIQFILE}.pjdump | grep ^Variable |
   awk -F, '{print "State,"$2",access,"$4","$5","$6",0,"$3}' > ${UNIQFILE}-states.csv
#+end_src

#+RESULTS:

Now, calculate intensity as in:
- [[*2016-02-17 Calculating intensity][2016-02-17 Calculating intensity]]

#+begin_src R :results output :session :exports both
k <- read.csv("Moca_matrix_bloc_fixaddr_20160223_172342_CET_Virtual_7-states.csv", header=FALSE);
options("scipen"=100, "digits"=4);
head(k);
#+end_src

#+RESULTS:
:      V1      V2     V3 V4   V5   V6 V7            V8
: 1 State 4656816 access  1 4399 4398  0  Private_Read
: 2 State 6303500 access  1 4399 4398  0  Private_Read
: 3 State 6303500 access  1 4399 4398  0 Private_Write
: 4 State 6303752 access  1 4399 4398  0  Private_Read
: 5 State 6303752 access  1 4399 4398  0 Private_Write
: 6 State 7330440 access  1 4399 4398  0  Private_Read

#+begin_src R :results output :session :exports both
sapply(k, class);
#+end_src

#+RESULTS:
:        V1        V2        V3        V4        V5        V6        V7        V8 
:  "factor" "numeric"  "factor" "integer" "integer" "integer" "integer"  "factor"

#+begin_src R :results output :session :exports both
names(k) <- c("Nature", "Address", "Type", "Start", "End", "Duration", "Imbric", "Value");
k$Niature <- NULL;
k$Type <- NULL;
k$Imbric <- NULL;
head(k);
#+end_src

#+RESULTS:
:   Address Start  End Duration         Value
: 1 4656816     1 4399     4398  Private_Read
: 2 6303500     1 4399     4398  Private_Read
: 3 6303500     1 4399     4398 Private_Write
: 4 6303752     1 4399     4398  Private_Read
: 5 6303752     1 4399     4398 Private_Write
: 6 7330440     1 4399     4398  Private_Read

#+begin_src R :results output :session :exports both
sapply(k, class);
#+end_src

#+RESULTS:
:   Address     Start       End  Duration     Value 
: "numeric" "integer" "integer" "integer"  "factor"

Do the magic. This command takes time.

#+begin_src R :results output :session :exports both
library(plyr);
g <- ddply(k, .(Address, Start, End, Duration, Value), summarize, N=length(Value));
head(g);
#+end_src

*Attention*: I aborted the command above since I was waiting for too long.

Let's try again with dplyr.

#+begin_src R :results output :session :exports both
library(dplyr);
#+end_src

#+RESULTS:
#+begin_example

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union
#+end_example

See this introduction to _dplyr_ (specially tthe section on chaining):
https://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html

Okay, let's write new code:

#+begin_src R :results output :session :exports both
g <- k %>%
       group_by(Address, Start, End, Duration, Value) %>%
       summarize(N = length(Value));
#+end_src

#+RESULTS:

It was fast (I think around a minute in my machine).

#+begin_src R :results output :session :exports both
nrow(g);
head(g);
#+end_src

#+RESULTS:
#+begin_example
[1] 3368394
Source: local data frame [6 x 6]
Groups: Address, Start, End, Duration

  Address   Start     End Duration         Value N
1 4194928 1700510 1729918    29408  Private_Read 1
2 4197248   14887   17767     2880  Private_Read 1
3 4656816       1    4399     4398  Private_Read 1
4 6303496   14887   17767     2880  Private_Read 1
5 6303500       1    4399     4398  Private_Read 1
6 6303500       1    4399     4398 Private_Write 1
#+end_example

Filter out the space address:
- 140737305563152 up to 140737305563152+18000000

#+begin_src R :results output :session :exports both
head(g[g$Address >= 140737305563152 & g$Address <= 140737305563152+18000000,]);
#+end_src

#+RESULTS:
#+begin_example
Source: local data frame [6 x 6]
Groups: Address, Start, End, Duration

          Address Start   End Duration         Value N
1 140737305563152  4400  9932     5532  Private_Read 1
2 140737305563152  4400  9932     5532 Private_Write 1
3 140737305563152 17734 17757       23  Private_Read 1
4 140737305563152 17757 20391     2634   Shared_Read 2
5 140737305563152 20391 27232     6841  Private_Read 1
6 140737305563152 27232 32008     4776   Shared_Read 2
#+end_example

It worked, but it was a little slow. Let's also use =dplyr=.

#+begin_src R :results output :session :exports both
h <- g %>% filter(Address >= 140737305563152 & Address <= 140737305563152+18000000);
#+end_src

#+RESULTS:

My feeling is that it was slower.

#+begin_src R :results output :session :exports both
head(h);
#+end_src

#+RESULTS:
#+begin_example
Source: local data frame [6 x 6]
Groups: Address, Start, End, Duration

          Address Start   End Duration         Value N
1 140737305563152  4400  9932     5532  Private_Read 1
2 140737305563152  4400  9932     5532 Private_Write 1
3 140737305563152 17734 17757       23  Private_Read 1
4 140737305563152 17757 20391     2634   Shared_Read 2
5 140737305563152 20391 27232     6841  Private_Read 1
6 140737305563152 27232 32008     4776   Shared_Read 2
#+end_example

Let's plot the intensity of =h= anyway:


#+begin_src R :results output graphics :file img/intensity_fixaddr_v1.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(h) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[file:img/intensity_fixaddr_v1.png]]

That's precise.

* 2016-02-25 Merge access information with data structure information :Lucas:

Let's look to another data structure, ow, much better, let's change
our data frame to contain such information.

#+begin_src R :results output :session :exports both
head(g);
#+end_src

#+RESULTS:
#+begin_example
Source: local data frame [6 x 6]
Groups: Address, Start, End, Duration

  Address   Start     End Duration         Value N
1 4194928 1700510 1729918    29408  Private_Read 1
2 4197248   14887   17767     2880  Private_Read 1
3 4656816       1    4399     4398  Private_Read 1
4 6303496   14887   17767     2880  Private_Read 1
5 6303500       1    4399     4398  Private_Read 1
6 6303500       1    4399     4398 Private_Write 1
#+end_example

#+begin_src R :results output :session :exports both
structs <- read.csv("Moca-matrix-bloc-fixaddr/matrix.structs.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressEnd = structs$AddressStart + structs$AddressSize;

#+end_src

#+RESULTS:
:                       Structure    AddressStart AddressSize      AddressEnd
: 1           __GI___pthread_keys         2196192       16384         2212576
: 2                __pthread_keys         2196192       16384         2212576
: 3               UnnamedStruct#0         6303760        5280         6309040
: 4               UnnamedStruct#1         6303888       32816         6336704
: 5               UnnamedStruct#2         6303888       32816         6336704
: 6 /tmp/matrix/matrix_naif.c:122 140737323565072    18000000 140737341565072
: 7 /tmp/matrix/matrix_naif.c:123 140737305563152    18000000 140737323563152
: 8 /tmp/matrix/matrix_naif.c:123 140737287561232    18000000 140737305561232

I'll have to use =sqldf= I think.

#+begin_src R :results output :session :exports both
library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);
#+end_src

#+RESULTS:
#+begin_example
Loading required package: gsubfn
Loading required package: proto
Loading required package: RSQLite
Loading required package: DBI
 Loading required package: tcltk
  Address Start    End Duration        Value N       Structure
1 6304392  4400   9932     5532 Private_Read 1 UnnamedStruct#0
2 6304392  4400   9932     5532 Private_Read 1 UnnamedStruct#1
3 6304392  4400   9932     5532 Private_Read 1 UnnamedStruct#2
4 6304416 87595 101980    14385  Shared_Read 1 UnnamedStruct#0
5 6304416 87595 101980    14385  Shared_Read 1 UnnamedStruct#1
6 6304416 87595 101980    14385  Shared_Read 1 UnnamedStruct#2
#+end_example

Ow, that was fast.

Let's plot:

#+begin_src R :results output graphics :file img/intensity_fixaddr_with_structure_v1.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_wrap(~Value, ncol=1) + facet_wrap(~Structure,ncol=1) +
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_fixaddr_with_structure_v1.png]]

The Y axis should be independent. I should also use =facet_grid= to
different by access type. Ow, I just realized I made two =facet_wrap=.


#+begin_src R :results output graphics :file img/intensity_fixaddr_with_structure_v2.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_grid(Structure~Value, scales="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_fixaddr_with_structure_v2.png]]

That's great.

Using color as factor.

#+begin_src R :results output graphics :file img/intensity_fixaddr_with_structure_v3.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scales="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_fixaddr_with_structure_v3.png]]


Strange. It is either one or two accesses only.

Is that normal for this application?

* 2016-02-25 Answer to questions of previous section                  :David:

The last image start to be quite interesting but there are several
issues:

** DONE Issue with visualization from file:img/intensity_fixaddr_with_structure_v2.png  [3/3]
- State "DONE"       from "STARTED"    [2016-02-26 Fri 13:40]
- State "STARTED"    from "TODO"       [2016-02-25 Thu 15:42]

*** DONE Number of writes
- State "DONE"       from "WAITING"    [2016-02-25 Thu 15:41]
- State "WAITING"    from "STARTED"    [2016-02-25 Thu 15:41]
- State "STARTED"    from "TODO"       [2016-02-25 Thu 15:41]
The visulisation contans only reads. Around a fourth of the accesses
should be writes. Where does this come from ?

Ok let see where does it comes from first, check that I'm working on
the same files than Lucas:

#+begin_src sh :results output :session :exports both
md5sum matrix.tgz
#+end_src

#+RESULTS:
: 098f7ee5632a20cf82290737e89c3ad2  matrix.tgz

seems to be the good ones, let's take a look

#+begin_src sh :results output :session :exports both
tar xvzf matrix.tgz
#+end_src

#+RESULTS:
: Moca-matrix-bloc-fixaddr/
: Moca-matrix-bloc-fixaddr/Moca_matrix_bloc_fixaddr_20160223_172342_CET_Virtual_7.pjdump
: Moca-matrix-bloc-fixaddr/Moca-framesoc.csv
: Moca-matrix-bloc-fixaddr/Moca_matrix_bloc_fixaddr_20160223_172342_CET_Physical_6.pjdump
: Moca-matrix-bloc-fixaddr/matrix.structs.csv
: Moca-matrix-bloc-fixaddr/matrix.stackmap.csv
: Moca-matrix-bloc-fixaddr/Moca_matrix_bloc_fixaddr_20160222_144532_CET_Physical_6.pjdump

Let's take a look at the main file

#+begin_src sh :results output :exports both
head Moca-matrix-bloc-fixaddr/Moca-framesoc.csv
#+end_src

#+RESULTS:
#+begin_example
@Virt,@Phy,Nreads,Nwrites,CPUMask,Start,End,TaskId,Shared
0000000000400040,000062000b0d4f90,1,0,000100110,1,4399,0,0
0000000000400b80,000062000b0d4f90,1,0,000000111,14887,17767,0,0
0000000000400270,0000000000400270,1,0,000001011,1700510,1729918,3,0
0000000000405435,0000000000405435,1,0,000000110,1,4399,0,0
000000000041d800,000000000041d800,1,0,000000110,1,4399,0,0
0000000000420fa0,0000000000420fa0,1,0,000000110,1,4399,0,0
00000000004341e1,00000000004341e1,1,0,000000110,1,4399,0,0
000000000044677a,000000000044677a,1,0,000000110,1,4399,0,0
000000000045dca0,000000000045dca0,1,0,000000110,1,4399,0,0
#+end_example

So the number of writes is the field number 4, lets count the number
of reads and writes in this file.

#+begin_src sh :results output :exports both
awk -F , 'BEGIN{r=0;w=0} {if($3>0){r++};if($4>0){w++}} END{print r" reads and "w" writes"}' Moca-matrix-bloc-fixaddr/Moca-framesoc.csv
#+end_src

#+RESULTS:
: 5479661 reads and 18285 writes

Ok the difference is way more than a factor 2 or 3 ...
I've recovered the original trace file (not processed) that is not in
the archive. it has the same headers as framesoc file without the last
field, thus the previous command should work on it.

#+begin_src sh :results output :exports both
awk -F , 'BEGIN{r=0;w=0} {if($3>0){r++};if($4>0){w++}} END{print r" reads and "w" writes"}' Moca-matrix-bloc-fixaddr/Moca-full-trace.csv
#+end_src

#+RESULTS:
: 1194354 reads and 17629 writes

#+begin_src sh :results output :exports both
echo 1194354 / 17629 | bc -l 
echo 5479661 / 1194354 | bc -l
echo 18285 / 17629 | bc -l 
#+end_src

#+RESULTS:
: 67.74939020931419819615
: 4.58797056819000061958
: 1.03721141301264961143

So in the raw trace we have already 67.8 more reads than write, event
if we admit that most accessses are reads and each writes also
triggers a read, it's a lot more than what I expected, I guess that I
should work on the way Moca decide if an access is a read or a write.

Still it is also weird that the post processing multiply by 4.6 the
number of reads while it almost doesn't change the number of
writes. I guess it comes from the fact that the number of accesses is
increased only when a shared is detected and according to the last
visualisation every write are private (and actually correspond to the
initialisation).

For now we will consider that this issue comes from Moca collection system.

*** DONE Duplicate data structure name
- State "DONE"       from "TODO"       [2016-02-26 Fri 11:20]
There are two entries in the structs.csv file with the same name, thus
they are merged in the visu

First make the name of data structures unique

#+begin_src sh :results output :exports both
awk -F , 'BEGIN{p="";cpt=1} {if(p==$1){n=$1"-"cpt;cpt++}\
else{cpt=1;n=$1};p=$1;print n","$2","$3}' \
Moca-matrix-bloc-fixaddr/matrix.structs.csv > Moca-matrix-bloc-fixaddr/matrix.structs-uniq.csv
cat  Moca-matrix-bloc-fixaddr/matrix.structs-uniq.csv
#+end_src

#+RESULTS:
: name,start,sz
: __GI___pthread_keys,2196192,16384
: __pthread_keys,2196192,16384
: UnnamedStruct#0,6303760,5280
: UnnamedStruct#1,6303888,32816
: UnnamedStruct#2,6303888,32816
: /tmp/matrix/matrix_naif.c:122,140737323565072,18000000
: /tmp/matrix/matrix_naif.c:123,140737305563152,18000000
: /tmp/matrix/matrix_naif.c:123-1,140737287561232,18000000

Better, now let's redo the analysis from [[*2016-02-25 New trace / Redo analysis / Try to be faster in filtering][2016-02-25 New trace / Redo analysis / Try to be faster in filtering]]  

#+begin_src sh :results output :session :exports both
UNIQFILE=Moca_matrix_bloc_fixaddr_20160223_172342_CET_Virtual_7
cat Moca-matrix-bloc-fixaddr/${UNIQFILE}.pjdump | grep ^Variable |
   awk -F, '{print "State,"$2",access,"$4","$5","$6",0,"$3}' > ${UNIQFILE}-states.csv
head ${UNIQFILE}-states.csv
#+end_src

#+RESULTS:
#+begin_example
State,4656816,access,1,4399,4398,0,Private_Read
State,6303500,access,1,4399,4398,0,Private_Read
State,6303500,access,1,4399,4398,0,Private_Write
State,6303752,access,1,4399,4398,0,Private_Read
State,6303752,access,1,4399,4398,0,Private_Write
State,7330440,access,1,4399,4398,0,Private_Read
State,7330440,access,1,4399,4398,0,Private_Write
State,7341840,access,1,4399,4398,0,Private_Read
State,7341840,access,1,4399,4398,0,Private_Write
State,7370576,access,1,4399,4398,0,Private_Read
#+end_example

Now, calculate intensity as in:
- [[*2016-02-17 Calculating intensity][2016-02-17 Calculating intensity]]

#+begin_src R :results output :session :exports both
k <- read.csv("Moca_matrix_bloc_fixaddr_20160223_172342_CET_Virtual_7-states.csv", header=FALSE);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Nature", "Address", "Type", "Start", "End", "Duration", "Imbric", "Value");
k$Niature <- NULL;
k$Type <- NULL;
k$Imbric <- NULL;
head(k);

sapply(k, class);

library(dplyr);

g <- k %>%
       group_by(Address, Start, End, Duration, Value) %>%
       summarize(N = length(Value));


nrow(g);
head(g);
h <- g %>% filter(Address >= 140737305563152 & Address <= 140737305563152+18000000);
head(h)
#+end_src

#+RESULTS:
#+begin_example
     V1      V2     V3 V4   V5   V6 V7            V8
1 State 4656816 access  1 4399 4398  0  Private_Read
2 State 6303500 access  1 4399 4398  0  Private_Read
3 State 6303500 access  1 4399 4398  0 Private_Write
4 State 6303752 access  1 4399 4398  0  Private_Read
5 State 6303752 access  1 4399 4398  0 Private_Write
6 State 7330440 access  1 4399 4398  0  Private_Read
       V1        V2        V3        V4        V5        V6        V7        V8 
 "factor" "numeric"  "factor" "integer" "integer" "integer" "integer"  "factor"
  Nature Address Start  End Duration         Value
1  State 4656816     1 4399     4398  Private_Read
2  State 6303500     1 4399     4398  Private_Read
3  State 6303500     1 4399     4398 Private_Write
4  State 6303752     1 4399     4398  Private_Read
5  State 6303752     1 4399     4398 Private_Write
6  State 7330440     1 4399     4398  Private_Read
   Nature   Address     Start       End  Duration     Value 
 "factor" "numeric" "integer" "integer" "integer"  "factor"
[1] 3368394
Source: local data frame [6 x 6]
Groups: Address, Start, End, Duration [5]

  Address   Start     End Duration         Value     N
    (dbl)   (int)   (int)    (int)        (fctr) (int)
1 4194928 1700510 1729918    29408  Private_Read     1
2 4197248   14887   17767     2880  Private_Read     1
3 4656816       1    4399     4398  Private_Read     1
4 6303496   14887   17767     2880  Private_Read     1
5 6303500       1    4399     4398  Private_Read     1
6 6303500       1    4399     4398 Private_Write     1
Source: local data frame [6 x 6]
Groups: Address, Start, End, Duration [5]

          Address Start   End Duration         Value     N
            (dbl) (int) (int)    (int)        (fctr) (int)
1 140737305563152  4400  9932     5532  Private_Read     1
2 140737305563152  4400  9932     5532 Private_Write     1
3 140737305563152 17734 17757       23  Private_Read     1
4 140737305563152 17757 20391     2634   Shared_Read     2
5 140737305563152 20391 27232     6841  Private_Read     1
6 140737305563152 27232 32008     4776   Shared_Read     2
#+end_example


Finally redo the plot v3 from [[*2016-02-25 Merge access information with data structure information][2016-02-25 Merge access information with data structure information]] 

#+begin_src R :results output graphics :file img/intensity_fixaddr_with_structure_v4.png :exports both :width 600 :height 400 :session
structs <- read.csv("Moca-matrix-bloc-fixaddr/matrix.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressEnd = structs$AddressStart + structs$AddressSize;

library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);


library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scales="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_fixaddr_with_structure_v4.png]]

Now this fix the non unique structure name issue.

*** DONE Importance of data structures
- State "DONE"       from "TODO"       [2016-02-26 Fri 13:40]
It seems that the last three data structures are not as
important as the first, but it is not clear, maybe plotting the
number of reads/write per structure would help determining if we can
ignore them.

Let's try to plot the number of accesses to each data structure:

#+begin_src R :results output :session :exports both
head(m)
library(plyr)
n <- ddply(m,c("Structure"),summarize,Nacc=sum(N));
head(n)
#+end_src

#+RESULTS:
#+begin_example
  Address Start    End Duration        Value N       Structure
1 6304392  4400   9932     5532 Private_Read 1 UnnamedStruct#0
2 6304392  4400   9932     5532 Private_Read 1 UnnamedStruct#1
3 6304392  4400   9932     5532 Private_Read 1 UnnamedStruct#2
4 6304416 87595 101980    14385  Shared_Read 1 UnnamedStruct#0
5 6304416 87595 101980    14385  Shared_Read 1 UnnamedStruct#1
6 6304416 87595 101980    14385  Shared_Read 1 UnnamedStruct#2
Error: length(rows) == 1 is not TRUE
                        Structure    Nacc
1   /tmp/matrix/matrix_naif.c:122   17508
2   /tmp/matrix/matrix_naif.c:123 5453604
3 /tmp/matrix/matrix_naif.c:123-1   24981
4                 UnnamedStruct#0    1214
5                 UnnamedStruct#1    1214
6                 UnnamedStruct#2    1214
#+end_example

ok let's plot it
#+begin_src R :results output graphics :file img/struct_importance_fixaddr_v1.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(n,aes(x=Structure,y=Nacc, fill=Structure)) +
  theme_bw() +
  geom_bar(stat="identity")
p
#+end_src

#+RESULTS:
[[file:img/struct_importance_fixaddr_v1.png]]

We can't see anything, let's try in log scale

#+begin_src R :results output graphics :file img/struct_importance_fixaddr_v2.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(n,aes(x=Structure,y=Nacc, fill=Structure)) +
  geom_bar(stat="identity") +
  theme_bw() +
  theme(panel.grid.minor = element_line(colour = "black", linetype="dashed", size = 0.1),
    panel.grid.major = element_line(colour = "black", size = 0.1)) +
  scale_y_log10()
  #lab=("Data structure name") +
  #ylab=("Number of accesses") +
p
#+end_src

#+RESULTS:
[[file:img/struct_importance_fixaddr.png]]


Better, so the unamed structures are indeed less accessed (about half
an order) but I don't think it's enough to neglect them.


** Conclusions

The visualisation is starting to be intersting, from those small test
we have seen several "weird" things:
- The number of access is always 1 or 2: I guess it comes from Moca
  tracing method usually there should be only 1 page fault (thus one
  access) per chunk having more than one access should be rare as it
  means a very specific order of accesses between two threads. Instead
  of plotting the intensity of accesses, we should probably plot the
  intensity in terms of number of threads.
- The detection of writes in Moca seems bad, I'll try to fix that

* 2016-02-29 Try on new traces                                        :David:

Moca's code to detect if an access is a read or a write seems correct,
the difference comes from the sampling, so we will try to look at some
other traces and compare them.

** Matrix modulo

The first trace we were studing is a naive matrix multiplication by
blocs, the next trace is an even more naive algorithm were threads
works on close piece of data.

The new trace is available on ligcloud:

We do the same analysis as here [[*Duplicate data structure name][Duplicate data structure name]]

#+begin_src sh :results output :exports both
DIR=Moca-matrix-modulo-2016-02-29_11-14-03
awk -F , 'BEGIN{p="";cpt=1} {if(p==$1){n=$1"-"cpt;cpt++}\
else{cpt=1;n=$1};p=$1;print n","$2","$3}' \
$DIR/matrix.structs.csv > $DIR/matrix.structs-uniq.csv
cat  $DIR/matrix.structs-uniq.csv
#+end_src

#+RESULTS:
: -1,,
: __GI___pthread_keys,2196192,16384
: __pthread_keys,2196192,16384
: UnnamedStruct#0,6303760,5280
: UnnamedStruct#1,6303888,32816
: UnnamedStruct#2,6303888,32816
: /home/david/Work/Bench/matrix/matrix_naif.c:140,140737313341456,8000000
: /home/david/Work/Bench/matrix/matrix_naif.c:123,140737321345040,8000000
: /home/david/Work/Bench/matrix/matrix_naif.c:122,140737329348624,8000000

Better, now let's redo the analysis from [[*2016-02-25 New trace / Redo analysis / Try to be faster in filtering][2016-02-25 New trace / Redo analysis / Try to be faster in filtering]]  

#+begin_src sh :results output :session :exports both
DIR=Moca-matrix-modulo-2016-02-29_11-14-03
UNIQFILE=$DIR/Moca_matrix_modulo_2016_02_29_11_14_03_20160229_112157_CET_Virtual_4
cat ${UNIQFILE}.pjdump | grep ^Variable |
   awk -F, '{print "State,"$2",access,"$4","$5","$6",0,"$3}' > ${UNIQFILE}-states.csv
head ${UNIQFILE}-states.csv
#+end_src

#+RESULTS:
#+begin_example
State,6303348,access,1,3492,3491,0,Private_Read
State,6303348,access,1,3492,3491,0,Private_Write
State,6303752,access,1,3492,3491,0,Private_Read
State,6303752,access,1,3492,3491,0,Private_Write
State,7330216,access,1,3492,3491,0,Private_Read
State,7330216,access,1,3492,3491,0,Private_Write
State,7332280,access,1,3492,3491,0,Private_Read
State,7332280,access,1,3492,3491,0,Private_Write
State,7339250,access,1,3492,3491,0,Private_Read
State,7339250,access,1,3492,3491,0,Private_Write
#+end_example

Now, calculate intensity as in:
- [[*2016-02-17 Calculating intensity][2016-02-17 Calculating intensity]]

#+begin_src R :results output :session :exports both
k <- read.csv("Moca-matrix-modulo-2016-02-29_11-14-03/Moca_matrix_modulo_2016_02_29_11_14_03_20160229_112157_CET_Virtual_4-states.csv", header=FALSE);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Nature", "Address", "Type", "Start", "End", "Duration", "Imbric", "Value");
k$Niature <- NULL;
k$Type <- NULL;
k$Imbric <- NULL;
head(k);

sapply(k, class);

library(dplyr);

g <- k %>%
       group_by(Address, Start, End, Duration, Value) %>%
       summarize(N = length(Value));


nrow(g);
head(g);
#h <- g %>% filter(Address >= 140737313341456 & Address <= 140737313341456+24000000);
#head(h)
#+end_src

#+RESULTS:
#+begin_example
     V1      V2     V3 V4   V5   V6 V7            V8
1 State 6303348 access  1 3492 3491  0  Private_Read
2 State 6303348 access  1 3492 3491  0 Private_Write
3 State 6303752 access  1 3492 3491  0  Private_Read
4 State 6303752 access  1 3492 3491  0 Private_Write
5 State 7330216 access  1 3492 3491  0  Private_Read
6 State 7330216 access  1 3492 3491  0 Private_Write
       V1        V2        V3        V4        V5        V6        V7        V8 
 "factor" "numeric"  "factor" "integer" "integer" "integer" "integer"  "factor"
  Nature Address Start  End Duration         Value
1  State 6303348     1 3492     3491  Private_Read
2  State 6303348     1 3492     3491 Private_Write
3  State 6303752     1 3492     3491  Private_Read
4  State 6303752     1 3492     3491 Private_Write
5  State 7330216     1 3492     3491  Private_Read
6  State 7330216     1 3492     3491 Private_Write
   Nature   Address     Start       End  Duration     Value 
 "factor" "numeric" "integer" "integer" "integer"  "factor"
[1] 1224679
Source: local data frame [6 x 6]
Groups: Address, Start, End, Duration [6]

  Address  Start    End Duration        Value     N
    (dbl)  (int)  (int)    (int)       (fctr) (int)
1 4194928  94264  94505      241 Private_Read     1
2 4194928  94505 108267    13762  Shared_Read     2
3 4194928 108267 108267        0 Private_Read     1
4 4196888   5923   7920     1997 Private_Read     1
5 4197408   7927  24611    16684 Private_Read     1
6 6303232   5923   7920     1997 Private_Read     1
#+end_example


Finally redo the plot v3 from [[*2016-02-25 Merge access information with data structure information][2016-02-25 Merge access information with data structure information]] 

#+begin_src R :results output graphics :file img/intensity_modulo_with_structure_v4.png :exports both :width 600 :height 400 :session
structs <- read.csv("Moca-matrix-modulo-2016-02-29_11-14-03/matrix.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressEnd = structs$AddressStart + structs$AddressSize;

library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);


library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scales="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_modulo_with_structure_v4.png]]


Let's compare this visualisation to
[[file:img/intensity_fixaddr_with_structure_v4.png][file:~/Work/labbook-lucas/img/intensity_fixaddr_with_structure_v4.png]] :
- The intensity goes up to 12 sometimes while it was never more than 2
  in matrix-bloc. This happens because the different thread work on
  very close addresses.
- As expected, the number of detected write have significantly
  increased, I think we can consider that the previous trace was clean
  and this is not a BUG in Moca.
- We can see a lot of shared write on the third data structure which
  is clearly bad in terms of cache.
- We can't see any patterns in the middle structure an the patterns in
  the other structure seems way less linear.
- It is still hard to know which thread is doing what. We really should try
  to visualize the intensity in terms of number of thread involved.


** DONE New visualisation: number of threads                         :David:
- State "DONE"       from "TODO"       [2016-02-29 Mon 18:54]
- State "TODO"       from              [2016-02-29 Mon 14:08]
  
Here is a link to an archive containing the trace I am  working on:
https://ligcloud.imag.fr/public.php?service=files&t=1d3fdcfed0bda3e1cdd30d6ff0093d7e

#+begin_src sh :results output :exports both
md5sum matrix-modulo.tgz
#+end_src

#+RESULTS:
: 82e5aa80788c8c8c5c1a021e45dea44e  matrix-modulo.tgz

#+begin_src sh :results output :exports both
DIR=Moca-matrix-modulo-2016-02-29_11-14-03
head $DIR/Moca_matrix_modulo_2016_02_29_11_14_03_20160229_112157_CET_Virtual_4-states.csv
#+end_src

#+RESULTS:
#+begin_example
State,6303348,access,1,3492,3491,0,Private_Read
State,6303348,access,1,3492,3491,0,Private_Write
State,6303752,access,1,3492,3491,0,Private_Read
State,6303752,access,1,3492,3491,0,Private_Write
State,7330216,access,1,3492,3491,0,Private_Read
State,7330216,access,1,3492,3491,0,Private_Write
State,7332280,access,1,3492,3491,0,Private_Read
State,7332280,access,1,3492,3491,0,Private_Write
State,7339250,access,1,3492,3491,0,Private_Read
State,7339250,access,1,3492,3491,0,Private_Write
#+end_example

The thread information is not in the pjdump file, and the pipeline
from the original trace to this file is very long (trace ->
preprocessing -> framesoc -> pjdump -> states.csv). We should modify
the csv generated by the preprocessing phase and work on this.

#+begin_src sh :results output :exports both
head Moca-matrix-modulo-2016-02-29_11-14-03/Moca-framesoc.csv
#+end_src

#+RESULTS:
#+begin_example
@Virt,@Phy,Nreads,Nwrites,CPUMask,Start,End,TaskId,Shared
0000000000400040,00006200028a0630,1,0,000010110,1,3492,0,0
0000000000400a18,00006200028a0630,1,0,000010110,5923,7920,0,0
0000000000400c20,00006200028a0630,1,0,000100110,7927,24611,2,0
0000000000400270,0000000000400270,1,0,010000110,94264,94505,2,0
0000000000400270,0000000000400270,1,0,010000110,94505,108267,2,1
0000000000400270,0000000000400270,1,0,001000110,94505,108267,3,1
0000000000400270,0000000000400270,1,0,001000110,108267,108267,3,0
0000000000405435,0000000000405435,1,0,010000110,1,3492,0,0
000000000041d800,000000000041d800,1,0,010000110,1,3492,0,0
#+end_example

At this level shared is always 0 or 1, we could instead put the number
of threads sharing the data. It's only a one line change in the post
processing script, let's try it:

#+begin_src sh :results output :exports both
cd  Moca-matrix-modulo-2016-02-29_11-14-03
~/Work/Moca/src/utils/create_event_producer.sh 4096 Moca-full-trace.csv
head Moca-framesoc.csv
#+end_src

#+RESULTS:
#+begin_example
Generating producer files
Generating framesoc trace file
Generating Virtual producers file
Generating Physical producers file
Virtual-producers.log Done
Physical-producers.log Done
Reading from Moca-full-trace.csv
102894 accesses on 6000 pages parsed from Moca-full-trace.csv
done in 00 h 00 min 12.765 sec
@Virt,@Phy,Nreads,Nwrites,CPUMask,Start,End,TaskId,Shared
0000000000400040,00006200028a0630,1,0,000010110,1,3492,0,1
0000000000400a18,00006200028a0630,1,0,000010110,5923,7920,0,1
0000000000400c20,00006200028a0630,1,0,000100110,7927,24611,2,1
0000000000400270,0000000000400270,1,0,010000110,94264,94505,2,1
0000000000400270,0000000000400270,1,0,010000110,94505,108267,2,2
0000000000400270,0000000000400270,1,0,001000110,94505,108267,3,2
0000000000400270,0000000000400270,1,0,001000110,108267,108267,3,1
0000000000405435,0000000000405435,1,0,010000110,1,3492,0,1
000000000041d800,000000000041d800,1,0,010000110,1,3492,0,1
#+end_example


#+begin_src R :results output :session :exports both
computeType <- function(df){
  shared <-9
  write <- 4
  if(df[shared] >= 2){
    mytype <- "Shared"
  }else{
    mytype <- "Private"
  }
  if(df[write] >= 1){
     mytype <- paste(mytype,"Write" , sep="_")
  }else{
     mytype <- paste(mytype,"Read" , sep="_")
  }
  return(mytype)
}

k <- read.csv("Moca-matrix-modulo-2016-02-29_11-14-03/Moca-framesoc.csv", header=T);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

k$Value <- apply(k,1,computeType)
k$Address <- sprintf("%f", as.numeric(paste("0x", k$Address, sep="")))
k$Phy <- NULL;
k$CPU <- NULL;
k$Tid <- NULL;
k$Reads <- NULL ;
k$Writes <- NULL ;
k$Duration <- k$End - k$Start
head(k);
#+end_src

#+RESULTS:
#+begin_example
            X.Virt            X.Phy Nreads Nwrites  CPUMask Start    End TaskId
1 0000000000400040 00006200028a0630      1       0    10110     1   3492      0
2 0000000000400a18 00006200028a0630      1       0    10110  5923   7920      0
3 0000000000400c20 00006200028a0630      1       0   100110  7927  24611      2
4 0000000000400270 0000000000400270      1       0 10000110 94264  94505      2
5 0000000000400270 0000000000400270      1       0 10000110 94505 108267      2
6 0000000000400270 0000000000400270      1       0  1000110 94505 108267      3
  Shared
1      1
2      1
3      1
4      1
5      2
6      2
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
         Address Start    End N        Value Duration
1 4194368.000000     1   3492 1 Private_Read     3491
2 4196888.000000  5923   7920 1 Private_Read     1997
3 4197408.000000  7927  24611 1 Private_Read    16684
4 4194928.000000 94264  94505 1 Private_Read      241
5 4194928.000000 94505 108267 2  Shared_Read    13762
6 4194928.000000 94505 108267 2  Shared_Read    13762
#+end_example


Ok I think that the data frame now looks like what we add with the
pjdump files, let's try to visualize that:

#+begin_src R :results output :session :exports both
g <- k
structs <- read.csv("Moca-matrix-modulo-2016-02-29_11-14-03/matrix.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressEnd = structs$AddressStart + structs$AddressSize;

library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);
#+end_src

#+RESULTS:
:          Address Start   End Duration        Value N       Structure
: 1 6304392.000000  5923  7920     1997 Private_Read 1 UnnamedStruct#0
: 2 6304392.000000  5923  7920     1997 Private_Read 1 UnnamedStruct#1
: 3 6304392.000000  5923  7920     1997 Private_Read 1 UnnamedStruct#2
: 4 6304472.000000  7921 10085     2164 Private_Read 1 UnnamedStruct#0
: 5 6304472.000000  7921 10085     2164 Private_Read 1 UnnamedStruct#1
: 6 6304472.000000  7921 10085     2164 Private_Read 1 UnnamedStruct#2

#+begin_src R :results output graphics :file img/intensity_modulo_threads.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scales="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_modulo_threads.png]]


This is starting to be very interesting, we can see here that the
middle data structure is shared by all thread, which might be bad on
NUMA machines, while the others seems two be shared mostly by two
threads, which should be a bit better.

- What is happening with the addresses in the big data structures ?

Can we do the same thing for the bloc version, see if it looks better:

#+begin_src sh :results output :exports both
cd  Moca-matrix-bloc-fixaddr/
~/Work/Moca/src/utils/create_event_producer.sh 4096 Moca-full-trace.csv
head Moca-framesoc.csv
#+end_src

#+RESULTS:
#+begin_example
Generating producer files
Generating framesoc trace file
Generating Virtual producers file
Generating Physical producers file
Virtual-producers.log Done
Physical-producers.log Done
done in 00 h 00 min 00.062 sec
@Virt,@Phy,Nreads,Nwrites,CPUMask,Start,End,TaskId,Shared
0000000000400040,000062000b0d4f90,1,0,000100110,1,4399,0,0
0000000000400b80,000062000b0d4f90,1,0,000000111,14887,17767,0,0
0000000000400270,0000000000400270,1,0,000001011,1700510,1729918,3,0
0000000000405435,0000000000405435,1,0,000000110,1,4399,0,0
000000000041d800,000000000041d800,1,0,000000110,1,4399,0,0
0000000000420fa0,0000000000420fa0,1,0,000000110,1,4399,0,0
00000000004341e1,00000000004341e1,1,0,000000110,1,4399,0,0
000000000044677a,000000000044677a,1,0,000000110,1,4399,0,0
000000000045dca0,000000000045dca0,1,0,000000110,1,4399,0,0
#+end_example

#+begin_src R :results output :session :exports both
computeType <- function(df){
  shared <-9
  write <- 4
  if(df[shared] >= 2){
    mytype <- "Shared"
  }else{
    mytype <- "Private"
  }
  if(df[write] >= 1){
     mytype <- paste(mytype,"Write" , sep="_")
  }else{
     mytype <- paste(mytype,"Read" , sep="_")
  }
  return(mytype)
}

k <- read.csv("Moca-matrix-bloc-fixaddr/Moca-framesoc.csv", header=T);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

k$Value <- apply(k,1,computeType)
k$Address <- sprintf("%f", as.numeric(paste("0x", k$Address, sep="")))
k$Phy <- NULL;
k$CPU <- NULL;
k$Tid <- NULL;
k$Reads <- NULL ;
k$Writes <- NULL ;
k$Duration <- k$End - k$Start
head(k);

g <- k
structs <- read.csv("Moca-matrix-bloc-fixaddr/matrix.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressEnd = structs$AddressStart + structs$AddressSize;

library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);
#+end_src

#+RESULTS:
#+begin_example
            X.Virt            X.Phy Nreads Nwrites CPUMask   Start     End
1 0000000000400040 000062000b0d4f90      1       0  100110       1    4399
2 0000000000400b80 000062000b0d4f90      1       0     111   14887   17767
3 0000000000400270 0000000000400270      1       0    1011 1700510 1729918
4 0000000000405435 0000000000405435      1       0     110       1    4399
5 000000000041d800 000000000041d800      1       0     110       1    4399
6 0000000000420fa0 0000000000420fa0      1       0     110       1    4399
  TaskId Shared
1      0      1
2      0      1
3      3      1
4      0      1
5      0      1
6      0      1
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
         Address   Start     End N        Value Duration
1 4194368.000000       1    4399 1 Private_Read     4398
2 4197248.000000   14887   17767 1 Private_Read     2880
3 4194928.000000 1700510 1729918 1 Private_Read    29408
4 4215861.000000       1    4399 1 Private_Read     4398
5 4315136.000000       1    4399 1 Private_Read     4398
6 4329376.000000       1    4399 1 Private_Read     4398
         Address Start   End Duration        Value N       Structure
1 6304392.000000  4400  9932     5532 Private_Read 1 UnnamedStruct#0
2 6304392.000000  4400  9932     5532 Private_Read 1 UnnamedStruct#1
3 6304392.000000  4400  9932     5532 Private_Read 1 UnnamedStruct#2
4 6304536.000000 14887 17757     2870 Private_Read 1 UnnamedStruct#0
5 6304536.000000 14887 17757     2870 Private_Read 1 UnnamedStruct#1
6 6304536.000000 14887 17757     2870 Private_Read 1 UnnamedStruct#2
#+end_example

#+begin_src R :results output graphics :file img/intensity_bloc_threads.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scales="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_bloc_threads.png]]


The interesting thing todo here is to compare the bloc version (above)
to the very naive one:
[[file:img/intensity_modulo_threads.png][file:~/Work/labbook-lucas/img/intensity_modulo_threads.png]]

We see several difference in the visualisation:
- The patterns are way more linear in the bloc version which seems
  better in regards of the cache issues
- Sharing is less intensive for the bloc version, especially in terms
  of writes: we manage to go up to 3 threads writing the same page in
  the naive version.
- For both version the 2^nd structure is accessed in an ugly way being
  completely shared, I guess it won't be inefficient for NUMA
  machines.

So I guess we have a visualisation from which we can start to see
things, the next step is to look at some other application and try to
do some improvements. We also should fix the number of addresses
issue.
* 2016-03-01 MOCA availability                                        :Lucas:

David just told me that MOCA is available here:
- https://github.com/dbeniamine/MOCA

The scripts to replay previous sections are there:
- https://github.com/dbeniamine/MOCA/blob/master/src/utils/create_event_producer.sh
- https://github.com/dbeniamine/MOCA/blob/master/src/utils/framesoc_parser.pl

* 2016-03-01 Can we go deeper ?                                       :David:

** Continue previous analysis

Let's restart were we stopped yesterday:

#+begin_src R :results output :session :exports both
computeType <- function(df){
  shared <-9
  write <- 4
  if(df[shared] >= 2){
    mytype <- "Shared"
  }else{
    mytype <- "Private"
  }
  if(df[write] >= 1){
     mytype <- paste(mytype,"Write" , sep="_")
  }else{
     mytype <- paste(mytype,"Read" , sep="_")
  }
  return(mytype)
}

k <- read.csv("Moca-matrix-modulo-2016-02-29_11-14-03/Moca-framesoc.csv", header=T);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

k$Value <- apply(k,1,computeType)
k$Address <- sprintf("%f", as.numeric(paste("0x", k$Address, sep="")))
k$Phy <- NULL;
k$CPU <- NULL;
k$Tid <- NULL;
k$Reads <- NULL ;
k$Writes <- NULL ;
k$Duration <- k$End - k$Start
head(k);

g <- k
structs <- read.csv("Moca-matrix-modulo-2016-02-29_11-14-03/matrix.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressEnd = structs$AddressStart + structs$AddressSize;

library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);
#+end_src

 #+RESULTS:
 #+begin_example
             X.Virt            X.Phy Nreads Nwrites  CPUMask Start    End TaskId
 1 0000000000400040 00006200028a0630      1       0    10110     1   3492      0
 2 0000000000400a18 00006200028a0630      1       0    10110  5923   7920      0
 3 0000000000400c20 00006200028a0630      1       0   100110  7927  24611      2
 4 0000000000400270 0000000000400270      1       0 10000110 94264  94505      2
 5 0000000000400270 0000000000400270      1       0 10000110 94505 108267      2
 6 0000000000400270 0000000000400270      1       0  1000110 94505 108267      3
   Shared
 1      1
 2      1
 3      1
 4      1
 5      2
 6      2
    X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
  "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
    Shared 
 "integer"
          Address Start    End N        Value Duration
 1 4194368.000000     1   3492 1 Private_Read     3491
 2 4196888.000000  5923   7920 1 Private_Read     1997
 3 4197408.000000  7927  24611 1 Private_Read    16684
 4 4194928.000000 94264  94505 1 Private_Read      241
 5 4194928.000000 94505 108267 2  Shared_Read    13762
 6 4194928.000000 94505 108267 2  Shared_Read    13762
          Address Start   End Duration        Value N       Structure
 1 6304392.000000  5923  7920     1997 Private_Read 1 UnnamedStruct#0
 2 6304392.000000  5923  7920     1997 Private_Read 1 UnnamedStruct#1
 3 6304392.000000  5923  7920     1997 Private_Read 1 UnnamedStruct#2
 4 6304472.000000  7921 10085     2164 Private_Read 1 UnnamedStruct#0
 5 6304472.000000  7921 10085     2164 Private_Read 1 UnnamedStruct#1
 6 6304472.000000  7921 10085     2164 Private_Read 1 UnnamedStruct#2
#+end_example

Before doing the plot we'd like to focus on some data structures:

#+begin_src R :results output :session :exports both
head(m)
n <- m[grepl("matrix",m$Structure),]
head(n)
#+end_src

#+RESULTS:
#+begin_example
         Address Start   End Duration        Value N       Structure
1 6304392.000000  5923  7920     1997 Private_Read 1 UnnamedStruct#0
2 6304392.000000  5923  7920     1997 Private_Read 1 UnnamedStruct#1
3 6304392.000000  5923  7920     1997 Private_Read 1 UnnamedStruct#2
4 6304472.000000  7921 10085     2164 Private_Read 1 UnnamedStruct#0
5 6304472.000000  7921 10085     2164 Private_Read 1 UnnamedStruct#1
6 6304472.000000  7921 10085     2164 Private_Read 1 UnnamedStruct#2
                  Address Start   End Duration         Value N
19 140737313341456.000000  5923  7920     1997 Private_Write 1
20 140737313341464.000000  7927 24611    16684  Private_Read 1
21 140737313345536.000000     1  3492     3491 Private_Write 1
22 140737313345536.000000  5923  7920     1997 Private_Write 1
23 140737313345560.000000  7927  7998       71  Private_Read 1
24 140737313345560.000000  7998 10000     2002   Shared_Read 2
                                         Structure
19 /home/david/Work/Bench/matrix/matrix_naif.c:140
20 /home/david/Work/Bench/matrix/matrix_naif.c:140
21 /home/david/Work/Bench/matrix/matrix_naif.c:140
22 /home/david/Work/Bench/matrix/matrix_naif.c:140
23 /home/david/Work/Bench/matrix/matrix_naif.c:140
24 /home/david/Work/Bench/matrix/matrix_naif.c:140
#+end_example

#+begin_src R :results output graphics :file img/intensity_modulo_threads_zoom.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(n) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scales="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_modulo_threads_zoom.png]]


It's a bit better, let's zoom in the middle data structure

#+begin_src R :results output graphics :file img/intensity_modulo_threads_zoom.png :exports both :width 600 :height 400 :session
library(ggplot2);
o <- n[grepl(".c:123",m$Structure),]
p <- ggplot(o) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(~Value, scales="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_modulo_threads_zoom.png]]


Well we don't see much more things, but It doesn't matter I think the
visualization is already quite usefull, let's try to work on some
other traces.

** IS

*** DONE First look
- State "DONE"       from "TODO"       [2016-03-01 Tue 11:26]
- State "TODO"       from              [2016-03-01 Tue 11:26]

IS in one of the NAS paralell benchmark, we saw a particularly
interesting pattern with TABARNAC: all the thread were accessing a
data structure with a Gaussian distribution. In other words each page
of the structure were accessed by each threads and more a page was in
the middle of the structure, more it was accessed.

There is an archive to the IS trace:
https://ligcloud.imag.fr/public.php?service=files&t=d724ad2c1c0c9b648eed5974cc736f58

#+begin_src sh :results output :exports both
md5sum is-a-base.tgz
#+end_src

#+RESULTS:
: a89f1719f4c4d0c68977f4fdcbba4712  is-a-base.tgz

#+begin_src sh :results output :exports both :session
DIR=Moca-is.A-2016-02-26_16-29-49
MOCAPATH=~/Work/Moca
cd $DIR
$MOCAPATH/src/utils/create_event_producer.sh 4096 Moca-full-trace.csv
head Moca-framesoc.csv
#+end_src

#+RESULTS:
#+begin_example
Generating producer files
Generating framesoc trace file
Generating Virtual producers file
Generating Physical producers file
Virtual-producers.log Done
Physical-producers.log Done
Reading from Moca-full-trace.csv
48577 accesses on 17022 pages parsed from Moca-full-trace.csv
done in 00 h 00 min 02.225 sec
@Virt,@Phy,Nreads,Nwrites,CPUMask,Start,End,TaskId,Shared
0000000000400040,000062000b08fa48,1,0,000001011,1,157,0,1
0000000000400040,000062000b08fa48,1,0,000001011,157,2825,0,2
0000000000400848,000062000b08fa48,1,0,000010011,157,2825,3,2
0000000000400848,000062000b08fa48,1,0,000010011,2825,5603,3,1
0000000000400848,000062000b08fa48,1,0,000010011,5603,8610,3,2
00000000004002a8,000062000b08fa48,1,0,000001011,5603,8610,0,2
0000000000400848,000062000b08fa48,1,0,000010011,8610,8616,3,1
0000000000400848,000062000b08fa48,1,0,000010011,8616,20399,3,2
0000000000400bd4,000062000b08fa48,1,0,000001011,8616,20399,0,2
#+end_example

#+begin_src sh :results output :exports both :session
DIR=Moca-is.A-2016-02-26_16-29-49
awk -F , 'BEGIN{p="";cpt=1} {if(p==$1){n=$1"-"cpt;cpt++}\
else{cpt=1;n=$1};p=$1;print n","$2","$3}' \
$DIR/is.A.structs.csv > $DIR/is.A.structs-uniq.csv
cat  $DIR/is.A.structs-uniq.csv
#+end_src

#+RESULTS:
#+begin_example
-1,,
__GI___pthread_keys,2196192,16384
__pthread_keys,2196192,16384
key_buff1,6305024,2097152
key_array,8402176,33554432
key_buff2,41956608,33554432
UnnamedStruct#2,75513872,32816
/tmp/NPB3.3-OMP/IS/is.c:494,75519344,4096
/tmp/NPB3.3-OMP/IS/is.c:494-1,75523456,4096
/tmp/NPB3.3-OMP/IS/is.c:494-2,75527568,4096
/tmp/NPB3.3-OMP/IS/is.c:494-3,75531680,4096
/tmp/NPB3.3-OMP/IS/is.c:494-4,75535792,4096
/tmp/NPB3.3-OMP/IS/is.c:494-5,75539904,4096
/tmp/NPB3.3-OMP/IS/is.c:494-6,75544016,4096
/tmp/NPB3.3-OMP/IS/is.c:494-7,75548128,4096
#+end_example

Hum it looks like there are a lot of data structures with the same
name here, it's gona be a mess to understand which one is which ...

#+begin_src R :results output :session :exports both
computeType <- function(df){
  shared <-9
  write <- 4
  if(df[shared] >= 2){
    mytype <- "Shared"
  }else{
    mytype <- "Private"
  }
  if(df[write] >= 1){
     mytype <- paste(mytype,"Write" , sep="_")
  }else{
     mytype <- paste(mytype,"Read" , sep="_")
  }
  return(mytype)
}

k <- read.csv("Moca-is.A-2016-02-26_16-29-49/Moca-framesoc.csv", header=T);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

k$Value <- apply(k,1,computeType)
k$Address <- sprintf("%f", as.numeric(paste("0x", k$Address, sep="")))
k$Phy <- NULL;
k$CPU <- NULL;
k$Tid <- NULL;
#k$Reads <- NULL ;
#k$Writes <- NULL ;
k$Duration <- k$End - k$Start
head(k);

g <- k
structs <- read.csv("Moca-is.A-2016-02-26_16-29-49/is.A.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressEnd = structs$AddressStart + structs$AddressSize;

library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.Reads, g.Writes, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);
#+end_src

#+RESULTS:
#+begin_example
            X.Virt            X.Phy Nreads Nwrites CPUMask Start  End TaskId
1 0000000000400040 000062000b08fa48      1       0    1011     1  157      0
2 0000000000400040 000062000b08fa48      1       0    1011   157 2825      0
3 0000000000400848 000062000b08fa48      1       0   10011   157 2825      3
4 0000000000400848 000062000b08fa48      1       0   10011  2825 5603      3
5 0000000000400848 000062000b08fa48      1       0   10011  5603 8610      3
6 00000000004002a8 000062000b08fa48      1       0    1011  5603 8610      0
  Shared
1      1
2      2
3      2
4      1
5      2
6      2
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
         Address Reads Writes Start  End N        Value Duration
1 4194368.000000     1      0     1  157 1 Private_Read      156
2 4194368.000000     1      0   157 2825 2  Shared_Read     2668
3 4196424.000000     1      0   157 2825 2  Shared_Read     2668
4 4196424.000000     1      0  2825 5603 1 Private_Read     2778
5 4196424.000000     1      0  5603 8610 2  Shared_Read     3007
6 4194984.000000     1      0  5603 8610 2  Shared_Read     3007
         Address Start   End Duration         Value Reads Writes N Structure
1 6311168.000000   157   163        6 Private_Write     1      1 1 key_buff1
2 6311168.000000   163 11652    11489  Shared_Write     1      1 2 key_buff1
3 6309120.000000   163 11652    11489  Shared_Write     1      1 2 key_buff1
4 6311168.000000 11652 21776    10124  Shared_Write     1      1 3 key_buff1
5 6309120.000000 11652 21776    10124  Shared_Write     1      1 3 key_buff1
6 6309120.000000 11652 21776    10124  Shared_Write     1      1 3 key_buff1
#+end_example


#+begin_src R :results output graphics :file img/intensity_is_threads.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_is_threads.png]]



 Woh there is a lot of data structures here, most of the accesses
 seems to be on the three first, let's do a plot similar to:
[[*Importance of data structures][Importance of data structures]]

#+begin_src R :results output :session :exports both
library(plyr)
n <- ddply(m,c("Structure"),summarize,Reads=sum(Reads), Writes=sum(Writes));
o <- n
o$Writes <- NULL
o$Type <- rep("Read", nrow(o))
names(o) <- c("Structure", "N", "Type")
q <- n
q$Reads <- NULL
q$Type <- rep("Write", nrow(o))
names(q) <- c("Structure", "N", "Type")
q <- rbind(q,o)
head(q)
#+end_src

#+RESULTS:
:                       Structure     N  Type
: 1                     key_array  8194 Write
: 2                     key_buff1 49647 Write
: 3                     key_buff2 36940 Write
: 4   /tmp/NPB3.3-OMP/IS/is.c:494     1 Write
: 5 /tmp/NPB3.3-OMP/IS/is.c:494-1     7 Write
: 6 /tmp/NPB3.3-OMP/IS/is.c:494-2     2 Write

#+begin_src R :results output graphics :file img/struct_importance_is.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(q,aes(x=Structure,y=N, fill=Type)) +
  theme_bw() +
  geom_bar(stat="identity")
p
#+end_src

#+RESULTS:
[[file:img/struct_importance_is.png]]


Ok we can clearly focus on the first three data structures. BTW this
version of the plot is more compelete than the previous, it is nice to
see the read / write ratio.

#+begin_src R :results output graphics :file img/intensity_is_threads_zoom.png :exports both :width 600 :height 400 :session
library(ggplot2);
r <- m[grepl("key_", m$Structure),]
p <- ggplot(r) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_is_threads_zoom.png]]


- So we see that keybuff1 is shared in write mode
  - At the beginning it's is shared by 2 or 3 threads, but when it the
    number of threads increase with the time
  - It seems that the addresses in the middle are accessed by more
    threads than the other, but it's not as obvious as in Tabarnac. We
    shoul try to plot the number of accesses per addresses.
- key buff1 seems to never be read, I guess we always do something
  like  keybuff1[i]++ that triggers a read and a write.
- The read write pattern of key array is quite fun: basicely we never
  re write anything, which is not the case for the two other data
  structure. This information could be used to replicate the data
  structure if needed.
  
#+begin_src R :results output graphics :file img/intensity_is_threads_zoom_nacc.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(r) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(Reads+Writes))) +
  facet_grid(Structure~Value, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_is_threads_zoom_nacc.png]]

The number of accesses for writes are higher than for reads, it is an
artifacts as a write access always contains also a read.

I'm a bit disapointed here, I thought I will see the fact that the
middle addreses of keybuff1 are more accessed ...

What if we remove the facet on the type of access

#+begin_src R :results output graphics :file img/intensity_is_threads_zoom_nacc2.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(r) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(Reads+Writes))) +
  facet_grid(Structure~., scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_is_threads_zoom_nacc2.png]]


Well  he we can only say that keybuff1 have more accesses at the same
time than the two other structures, but we still can't see this gaussian

I'll just check that the trace is indeed the original version of is,
(If yes the result of the following line should be Macros: DYN).

#+begin_src sh :results output :exports both
grep Macros Moca-is.A-2016-02-26_16-29-49/Moca-is.A.log
#+end_src

#+RESULTS:
: Macros:	DYN

It looks fine, I should compare these plots to the modified version of
IS, and see what happens ...
For reminder Tabarnac IS visualisation are available here:
http://dbeniamine.github.io/Tabarnac/examples/is.B-original.html
and
http://dbeniamine.github.io/Tabarnac/examples/is.B-modif.html

Also we are looking to a class A version of IS, for tabarnac we used a
class B, maybe it could help to work on a bigger version.

*** DONE Class B
- State "DONE"       from "STARTED"    [2016-03-01 Tue 14:55]
- State "STARTED"    from "TODO"       [2016-03-01 Tue 14:11]
- State "TODO"       from              [2016-03-01 Tue 11:26]
 
So I just generated three new is traces:
- is.A-modif: Class A, modification from tabarnac paper (see
  http://dbeniamine.github.io/Tabarnac/examples/ ).
- is.B-orig: Class A, original version.
- is.B-modif: Class B, modified.

As usual, there is an archive on ligcloud:
https://ligcloud.imag.fr/public.php?service=files&t=4e9547f6da887a6c8ebcca9dea4c159f

#+begin_src sh :results output :exports both
md5sum is-AB.tgz
tar xvzf is-AB.tgz
#+end_src

#+RESULTS:
#+begin_example
a20fd83a6de147c13ac7d572f3d526b4  is-AB.tgz
Moca-is.A-modif-2016-03-01_14-00-23/
Moca-is.A-modif-2016-03-01_14-00-23/is.A-modif-stackmap.csv
Moca-is.A-modif-2016-03-01_14-00-23/Moca-full-trace.csv
Moca-is.A-modif-2016-03-01_14-00-23/Moca-output.log
Moca-is.A-modif-2016-03-01_14-00-23/stacks.log
Moca-is.A-modif-2016-03-01_14-00-23/Moca-is.A-modif.log
Moca-is.A-modif-2016-03-01_14-00-23/temp_1760
Moca-is.A-modif-2016-03-01_14-00-23/Moca-is.A-modif.log.err
Moca-is.A-modif-2016-03-01_14-00-23/is.A-modif.structs.csv
Moca-is.B-modif-2016-03-01_14-00-58/
Moca-is.B-modif-2016-03-01_14-00-58/Moca-is.B-modif.log
Moca-is.B-modif-2016-03-01_14-00-58/Moca-is.B-modif.log.err
Moca-is.B-modif-2016-03-01_14-00-58/is.B-modif-stackmap.csv
Moca-is.B-modif-2016-03-01_14-00-58/Moca-full-trace.csv
Moca-is.B-modif-2016-03-01_14-00-58/Moca-output.log
Moca-is.B-modif-2016-03-01_14-00-58/stacks.log
Moca-is.B-modif-2016-03-01_14-00-58/is.B-modif.structs.csv
Moca-is.B-modif-2016-03-01_14-00-58/temp_3266
Moca-is.B-orig-2016-03-01_14-03-40/
Moca-is.B-orig-2016-03-01_14-03-40/Moca-is.B-orig.log
Moca-is.B-orig-2016-03-01_14-03-40/is.B-orig-stackmap.csv
Moca-is.B-orig-2016-03-01_14-03-40/Moca-is.B-orig.log.err
Moca-is.B-orig-2016-03-01_14-03-40/Moca-full-trace.csv
Moca-is.B-orig-2016-03-01_14-03-40/Moca-output.log
Moca-is.B-orig-2016-03-01_14-03-40/stacks.log
Moca-is.B-orig-2016-03-01_14-03-40/is.B-orig.structs.csv
Moca-is.B-orig-2016-03-01_14-03-40/temp_5417
#+end_example

We start with the original is.B trace, see if the patterns are more
visible than on the class A, same analysis as [[*First look][above.]] 

#+begin_src sh :results output :exports both :session
DIR=Moca-is.B-orig-2016-03-01_14-03-40
MOCAPATH=~/Work/Moca
cd $DIR
$MOCAPATH/src/utils/create_event_producer.sh 4096 Moca-full-trace.csv
head Moca-framesoc.csv
awk -F , 'BEGIN{p="";cpt=1} {if(p==$1){n=$1"-"cpt;cpt++}\
else{cpt=1;n=$1};p=$1;print n","$2","$3}' \
is.B-orig.structs.csv > is.B-orig.structs-uniq.csv
cat  is.B-orig.structs-uniq.csv
#+end_src

#+RESULTS:
#+begin_example
Generating producer files
Generating framesoc trace file
Generating Virtual producers file
Generating Physical producers file
Virtual-producers.log Done
Physical-producers.log Done
Reading from Moca-full-trace.csv
770601 accesses on 67715 pages parsed from Moca-full-trace.csv
done in 00 h 00 min 23.992 sec
@Virt,@Phy,Nreads,Nwrites,CPUMask,Start,End,TaskId,Shared
0000000000400040,000062000b1dfa80,1,0,000001011,1,171,0,1
00000000004002a8,000062000b1dfa80,1,0,000001011,32663,34153,0,1
0000000000400bd4,000062000b1dfa80,1,0,000001011,55271,72678,0,1
00000000004009a0,000062000b1dfa80,1,0,000000011,88569,88776,1,1
00000000004009a0,000062000b1dfa80,1,0,000000111,92562,103554,7,1
00000000004009a0,000062000b1dfa80,1,0,000010011,238634,245102,2,1
00000000004009a0,000062000b1dfa80,1,0,001000000,254421,258859,4,1
00000000004009a0,000062000b1dfa80,1,0,001000000,258859,286485,4,2
0000000000400990,000062000b1dfa80,1,0,010000000,258859,286485,6,2
-1,,
__GI___pthread_keys,2196192,16384
__pthread_keys,2196192,16384
key_buff1,6305024,8388608
key_array,14693632,134217728
key_buff2,148911360,134217728
UnnamedStruct#2,283131920,32816
/tmp/NPB3.3-OMP/IS/is.c:494,283137392,4096
/tmp/NPB3.3-OMP/IS/is.c:494-1,283141504,4096
/tmp/NPB3.3-OMP/IS/is.c:494-2,283145616,4096
/tmp/NPB3.3-OMP/IS/is.c:494-3,283149728,4096
/tmp/NPB3.3-OMP/IS/is.c:494-4,283153840,4096
/tmp/NPB3.3-OMP/IS/is.c:494-5,283157952,4096
/tmp/NPB3.3-OMP/IS/is.c:494-6,283162064,4096
/tmp/NPB3.3-OMP/IS/is.c:494-7,283166176,4096
#+end_example


#+begin_src R :results output :session :exports both
computeType <- function(df){
  shared <-9
  write <- 4
  if(df[shared] >= 2){
    mytype <- "Shared"
  }else{
    mytype <- "Private"
  }
  if(df[write] >= 1){
     mytype <- paste(mytype,"Write" , sep="_")
  }else{
     mytype <- paste(mytype,"Read" , sep="_")
  }
  return(mytype)
}

k <- read.csv("Moca-is.B-orig-2016-03-01_14-03-40/Moca-framesoc.csv", header=T);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

k$Value <- apply(k,1,computeType)
k$Address <- sprintf("%f", as.numeric(paste("0x", k$Address, sep="")))
k$Phy <- NULL;
k$CPU <- NULL;
k$Tid <- NULL;
#k$Reads <- NULL ;
#k$Writes <- NULL ;
k$Duration <- k$End - k$Start
head(k);

g <- k
structs <- read.csv("Moca-is.B-orig-2016-03-01_14-03-40/is.B-orig.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressEnd = structs$AddressStart + structs$AddressSize;

library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.Reads, g.Writes, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);
#+end_src

#+RESULTS:
#+begin_example
            X.Virt            X.Phy Nreads Nwrites CPUMask  Start    End TaskId
1 0000000000400040 000062000b1dfa80      1       0    1011      1    171      0
2 00000000004002a8 000062000b1dfa80      1       0    1011  32663  34153      0
3 0000000000400bd4 000062000b1dfa80      1       0    1011  55271  72678      0
4 00000000004009a0 000062000b1dfa80      1       0      11  88569  88776      1
5 00000000004009a0 000062000b1dfa80      1       0     111  92562 103554      7
6 00000000004009a0 000062000b1dfa80      1       0   10011 238634 245102      2
  Shared
1      1
2      1
3      1
4      1
5      1
6      1
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
         Address Reads Writes  Start    End N        Value Duration
1 4194368.000000     1      0      1    171 1 Private_Read      170
2 4194984.000000     1      0  32663  34153 1 Private_Read     1490
3 4197332.000000     1      0  55271  72678 1 Private_Read    17407
4 4196768.000000     1      0  88569  88776 1 Private_Read      207
5 4196768.000000     1      0  92562 103554 1 Private_Read    10992
6 4196768.000000     1      0 238634 245102 1 Private_Read     6468
Loading required package: gsubfn
Loading required package: proto
Loading required package: RSQLite
Loading required package: DBI
 Loading required package: tcltk
         Address  Start    End Duration         Value Reads Writes N Structure
1 6307840.000000 279630 283344     3714 Private_Write     1      1 1 key_buff1
2 6307840.000000 310398 410993   100595 Private_Write     1      1 1 key_buff1
3 6307840.000000 452318 485570    33252 Private_Write     1      1 1 key_buff1
4 6307840.000000 485572 511748    26176 Private_Write     1      1 1 key_buff1
5 6307840.000000 511748 521080     9332  Shared_Write     1      1 2 key_buff1
6 6307840.000000 511748 521080     9332  Shared_Write     1      1 2 key_buff1
#+end_example


#+begin_src R :results output graphics :file img/intensity_is_B_orig_threads.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_is_B_orig_threads.png]]



#+begin_src R :results output :session :exports both
library(plyr)
n <- ddply(m,c("Structure"),summarize,Reads=sum(Reads), Writes=sum(Writes));
o <- n
o$Writes <- NULL
o$Type <- rep("Read", nrow(o))
names(o) <- c("Structure", "N", "Type")
q <- n
q$Reads <- NULL
q$Type <- rep("Write", nrow(o))
names(q) <- c("Structure", "N", "Type")
q <- rbind(q,o)
head(q)
#+end_src

#+RESULTS:
:                       Structure      N  Type
: 1                     key_array  76186 Write
: 2                     key_buff1  59945 Write
: 3                     key_buff2 406236 Write
: 4   /tmp/NPB3.3-OMP/IS/is.c:494     37 Write
: 5 /tmp/NPB3.3-OMP/IS/is.c:494-1     59 Write
: 6 /tmp/NPB3.3-OMP/IS/is.c:494-2     65 Write

#+begin_src R :results output graphics :file img/struct_importance_is_B_orig.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(q,aes(x=Structure,y=N, fill=Type)) +
  theme_bw() +
  geom_bar(stat="identity")
p
#+end_src

#+RESULTS:
[[file:img/struct_importance_is_B_orig.png]]


So far no suprise, the B class looks like the A.

#+begin_src R :results output graphics :file img/intensity_is_B_orig_threads_zoom.png :exports both :width 600 :height 400 :session
library(ggplot2);
r <- m[grepl("key_", m$Structure),]
p <- ggplot(r) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_is_B_orig_threads_zoom.png]]

So we can compare this visualisation to the previous one:
[[file:img/intensity_is_threads_zoom.png][file:~/Work/labbook-lucas/img/intensity_is_threads_zoom.png]]

- It seems that there are some writes on keyarray at the end of the
  execution.
- It is still hard to see anything on keybuff1.
- Although keybuff2 patterns differs than on the previous trace, we
  have again the exact same patterns of shared read and writes.

  
#+begin_src R :results output graphics :file img/intensity_is_B_orig_threads_zoom_nacc.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(r) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(Reads+Writes))) +
  facet_grid(Structure~Value, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_is_B_orig_threads_zoom_nacc.png]]

Still hard to see but there is a little something in the middle of keybuff1
Let's try to zoom as mush as possible:

#+begin_src R :results output graphics :file img/intensity_is_threads_zoom_nacc2.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(subset(r, r$Structure=="key_buff1")) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(Reads+Writes))) +
  facet_grid(Structure~., scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_is_threads_zoom_nacc2.png]]

Still hard to see anything ...
What happens if we do the same zoom on the thread based intensity ?

#+begin_src R :results output graphics :file img/intensity_is_B_orig_threads_zoo2m.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(subset(r,r$Structure=="key_buff1")) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~., scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_is_B_orig_threads_zoo2m.png]]

Still hard to see anything ...
Maybe it is harder to see such behavior over the time ...
So next step, compare these results to the modified version, maybe we
will be able to see something.

*** DONE Compare with modified trace
- State "DONE"       from "STARTED"    [2016-03-01 Tue 16:11]
- State "STARTED"    from "DONE"       [2016-03-01 Tue 16:09]
- State "DONE"       from "TODO"       [2016-03-01 Tue 15:19]
- State "TODO"       from              [2016-03-01 Tue 11:26]

Let's do this analysis one more time but with the modified version:

#+begin_src sh :results output :exports both :session
DIR=Moca-is.B-modif-2016-03-01_14-00-58
MOCAPATH=~/Work/Moca
cd $DIR
$MOCAPATH/src/utils/create_event_producer.sh 4096 Moca-full-trace.csv
head Moca-framesoc.csv
awk -F , 'BEGIN{p="";cpt=1} {if(p==$1){n=$1"-"cpt;cpt++}\
else{cpt=1;n=$1};p=$1;print n","$2","$3}' \
is.B-orig.structs.csv > is.B-orig.structs-uniq.csv
cat  is.B-orig.structs-uniq.csv
#+end_src

#+RESULTS:
#+begin_example
Generating producer files
Generating Virtual producers file
Generating framesoc trace file
Generating Physical producers file
Virtual-producers.log Done
Physical-producers.log Done
Reading from Moca-full-trace.csv
367388 accesses on 67713 pages parsed from Moca-full-trace.csv
done in 00 h 00 min 13.934 sec
@Virt,@Phy,Nreads,Nwrites,CPUMask,Start,End,TaskId,Shared
0000000000400040,00006200028860e0,1,0,000001000,1,169,0,1
00000000004002a8,00006200028860e0,1,0,000000010,32987,97290,0,1
00000000004002a8,00006200028860e0,1,0,000000010,97290,117666,0,2
0000000000400860,00006200028860e0,1,0,000010011,97290,117666,7,2
0000000000400860,00006200028860e0,1,0,000010011,117666,203309,7,1
0000000000400860,00006200028860e0,1,0,000010011,203309,204176,7,2
0000000000400860,00006200028860e0,1,0,000000011,203309,204176,6,2
0000000000400860,00006200028860e0,1,0,000000011,204176,242458,6,1
0000000000400860,00006200028860e0,1,0,000000011,242458,244604,6,2
#+end_example


#+begin_src R :results output :session :exports both
computeType <- function(df){
  shared <-9
  write <- 4
  if(df[shared] >= 2){
    mytype <- "Shared"
  }else{
    mytype <- "Private"
  }
  if(df[write] >= 1){
     mytype <- paste(mytype,"Write" , sep="_")
  }else{
     mytype <- paste(mytype,"Read" , sep="_")
  }
  return(mytype)
}

k <- read.csv("Moca-is.B-modif-2016-03-01_14-00-58/Moca-framesoc.csv", header=T);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

k$Value <- apply(k,1,computeType)
k$Address <- sprintf("%f", as.numeric(paste("0x", k$Address, sep="")))
k$Phy <- NULL;
k$CPU <- NULL;
k$Tid <- NULL;
#k$Reads <- NULL ;
#k$Writes <- NULL ;
k$Duration <- k$End - k$Start
head(k);

g <- k
structs <- read.csv("Moca-is.B-modif-2016-03-01_14-00-58/is.B-modif.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressEnd = structs$AddressStart + structs$AddressSize;

library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.Reads, g.Writes, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);
#+end_src

#+RESULTS:
#+begin_example
            X.Virt            X.Phy Nreads Nwrites CPUMask  Start    End TaskId
1 0000000000400040 00006200028860e0      1       0    1000      1    169      0
2 00000000004002a8 00006200028860e0      1       0      10  32987  97290      0
3 00000000004002a8 00006200028860e0      1       0      10  97290 117666      0
4 0000000000400860 00006200028860e0      1       0   10011  97290 117666      7
5 0000000000400860 00006200028860e0      1       0   10011 117666 203309      7
6 0000000000400860 00006200028860e0      1       0   10011 203309 204176      7
  Shared
1      1
2      1
3      2
4      2
5      1
6      2
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
         Address Reads Writes  Start    End N        Value Duration
1 4194368.000000     1      0      1    169 1 Private_Read      168
2 4194984.000000     1      0  32987  97290 1 Private_Read    64303
3 4194984.000000     1      0  97290 117666 2  Shared_Read    20376
4 4196448.000000     1      0  97290 117666 2  Shared_Read    20376
5 4196448.000000     1      0 117666 203309 1 Private_Read    85643
6 4196448.000000     1      0 203309 204176 2  Shared_Read      867
Error in file(file, "rt") : cannot open the connection
In addition: Warning message:
In file(file, "rt") :
  cannot open file 'Moca-is.B-modif-2016-03-01_14-00-58/is.B-modif.structs-uniq.csv': No such file or directory
         Address  Start    End Duration         Value Reads Writes N Structure
1 6307840.000000  32987 117666    84679 Private_Write     1      1 1 key_buff1
2 6307840.000000 120476 210547    90071 Private_Write     1      1 1 key_buff1
3 6307840.000000 221274 258171    36897 Private_Write     1      1 1 key_buff1
4 6307840.000000 258178 335045    76867 Private_Write     1      1 1 key_buff1
5 6311936.000000  32987 117666    84679 Private_Write     1      1 1 key_buff1
6 6311936.000000 120476 210547    90071 Private_Write     1      1 1 key_buff1
#+end_example

#+begin_src R :results output graphics :file img/intensity_is_B_modif_threads_zoom.png :exports both :width 600 :height 400 :session
library(ggplot2);
r <- m[grepl("key_", m$Structure),]
p <- ggplot(r) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_is_B_modif_threads_zoom.png]]



This is interesting, if it was hard to visualize the issue on the
original version (linked below), we can clearly see somme differences with the
modified version. Indeed, the amount of sharing on keybuff1 have
significantly decreased.
It seems to impact also a little bit the two other data structures.
Still the difference of behavior are not as impressive as what we saw
with Tabarnac, maybe we should try to plot this data in a different
way ...

[[file:img/intensity_is_B_orig_threads_zoom.png][file:~/Work/labbook-lucas/img/intensity_is_B_orig_threads_zoom.png]]

Before trying something else, let's compare the two version in terms
of number of accesses

#+begin_src R :results output graphics :file img/intensity_is_B_modif_threads_zoom_nacc.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(r) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(Reads+Writes))) +
  facet_grid(Structure~Value, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_is_B_modif_threads_zoom_nacc.png]]

Original verion here:
[[file:img/intensity_is_B_orig_threads_zoom_nacc.png][file:~/Work/labbook-lucas/img/intensity_is_B_orig_threads_zoom_nacc.png]]


I think the difference betweens these plots are quite similar to the
difference betwen the plots showing the intensity en terms of
threads, I guess it means that they are too similar. I'd really like
to see something like tabarnac's plot but over the time...

Maybe we should first do some plot similar to Tabarnac's ones without
time. It will tell us two different things: first if we have enough
information in Moca traces to see these behavior. The second thing is
that maybe, when we visualize the accesses over the time, we can't see
the differences because they are only significant when we sum
everything up.


*** DONE Tabarnac like plots wth Moca traces
- State "DONE"       from "TODO"       [2016-03-03 Thu 18:11]
- State "TODO"       from              [2016-03-01 Tue 15:21]

  
We restart from the original trace, but we keep the Tid in the dataframe:

#+begin_src R :results output :session :exports both
computeType <- function(df){
  shared <-9
  write <- 4
  if(df[shared] >= 2){
    mytype <- "Shared"
  }else{
    mytype <- "Private"
  }
  if(df[write] >= 1){
     mytype <- paste(mytype,"Write" , sep="_")
  }else{
     mytype <- paste(mytype,"Read" , sep="_")
  }
  return(mytype)
}

k <- read.csv("Moca-is.B-orig-2016-03-01_14-03-40/Moca-framesoc.csv", header=T);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

k$Value <- apply(k,1,computeType)
k$Address <- sprintf("%f", as.numeric(paste("0x", k$Address, sep="")))
k$Phy <- NULL;
k$CPU <- NULL;
#k$Tid <- NULL;
#k$Reads <- NULL ;
#k$Writes <- NULL ;
k$Duration <- k$End - k$Start
head(k);

g <- k
structs <- read.csv("Moca-is.B-orig-2016-03-01_14-03-40/is.B-orig.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressEnd = structs$AddressStart + structs$AddressSize;

library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.Reads, g.Writes, g.Tid, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);
#+end_src

#+RESULTS:
#+begin_example
            X.Virt            X.Phy Nreads Nwrites CPUMask  Start    End TaskId
1 0000000000400040 000062000b1dfa80      1       0    1011      1    171      0
2 00000000004002a8 000062000b1dfa80      1       0    1011  32663  34153      0
3 0000000000400bd4 000062000b1dfa80      1       0    1011  55271  72678      0
4 00000000004009a0 000062000b1dfa80      1       0      11  88569  88776      1
5 00000000004009a0 000062000b1dfa80      1       0     111  92562 103554      7
6 00000000004009a0 000062000b1dfa80      1       0   10011 238634 245102      2
  Shared
1      1
2      1
3      1
4      1
5      1
6      1
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
         Address Reads Writes  Start    End Tid N        Value Duration
1 4194368.000000     1      0      1    171   0 1 Private_Read      170
2 4194984.000000     1      0  32663  34153   0 1 Private_Read     1490
3 4197332.000000     1      0  55271  72678   0 1 Private_Read    17407
4 4196768.000000     1      0  88569  88776   1 1 Private_Read      207
5 4196768.000000     1      0  92562 103554   7 1 Private_Read    10992
6 4196768.000000     1      0 238634 245102   2 1 Private_Read     6468
Loading required package: gsubfn
Loading required package: proto
Loading required package: RSQLite
Loading required package: DBI
 Loading required package: tcltk
         Address  Start    End Duration         Value Reads Writes Tid N
1 6307840.000000 279630 283344     3714 Private_Write     1      1   7 1
2 6307840.000000 310398 410993   100595 Private_Write     1      1   6 1
3 6307840.000000 452318 485570    33252 Private_Write     1      1   6 1
4 6307840.000000 485572 511748    26176 Private_Write     1      1   6 1
5 6307840.000000 511748 521080     9332  Shared_Write     1      1   6 2
6 6307840.000000 511748 521080     9332  Shared_Write     1      1   0 2
  Structure
1 key_buff1
2 key_buff1
3 key_buff1
4 key_buff1
5 key_buff1
6 key_buff1
#+end_example

Now we sum up the date to remove the temporal information.

#+begin_src R :results output :session :exports both
r <- m[grepl("key_",m$Structure),]
r <- ddply(r, c("Address","Tid", "Structure"), summarize, N=sum(Reads)+sum(Writes))
head(r) 
#+end_src

#+RESULTS:
:            Address Tid Structure  N
: 1 100000888.000000   6 key_array  4
: 2 100003840.000000   3 key_array 11
: 3 100007216.000000   6 key_array  4
: 4 100007936.000000   3 key_array 11
: 5 100009484.000000   6 key_array  4
: 6 100012032.000000   3 key_array 11

#+begin_src R :results output graphics :file img/tabarnac_is_b_orig.png :exports both :width 600 :height 400 :session
library(ggplot2);
s <- r[grepl("key_buff1",r$Structure),]
p <- ggplot(s) +
  theme_bw() +
  geom_point(aes(x=Address,y=Tid,color=N)) +
  #facet_wrap(~Structure, ncol=1) +
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/tabarnac_is_b_orig.png]]

Still hard to see anything, maybe we can group the number of accesses
per pages:
#+begin_src R :results output :session :exports both
s <- r[grepl("key_",r$Structure),]
#head(s)
library(gmp)
pageAddr <- function(df){
    a <- as.bigz(gsub('\\..*', '', df[1]))
    a <- a - mod.bigz(a,4096)*4096
    return (as.character(a,b=10))
}
s$Page <- apply(s,1,pageAddr)
head(s)
t <- ddply(s,c("Page","Tid","Structure"), summarize, N=sum(N))
head(t)
#+end_src

#+RESULTS:
#+begin_example

Attaching package: ‘gmp’

The following objects are masked from ‘package:base’:

    %*%, apply, crossprod, matrix, tcrossprod
           Address Tid Structure  N      Page
1 100000888.000000   6 key_array  4  95315064
2 100003840.000000   3 key_array 11 100003840
3 100007216.000000   6 key_array  4  86179120
4 100007936.000000   3 key_array 11 100007936
5 100009484.000000   6 key_array  4  93668876
6 100012032.000000   3 key_array 11 100012032
       Page Tid Structure  N
1 100003840   3 key_array 11
2 100007936   3 key_array 11
3 100012032   3 key_array 11
4 100016128   3 key_array 11
5 100020224   3 key_array 11
6  10002432   0 key_buff1  4
#+end_example

#+begin_src R :results output graphics :file img/tabarnac_page_is_b_orig.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(t,aes(x=Page,y=Tid,color=N)) +
  theme_bw() +
  geom_point() +
  facet_wrap(~Structure) +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/tabarnac_page_is_b_orig.png]]



Still the same issue, we are not able to see any pattern.
Maybe the issue is not in Moca traces, but in my R: the addresses used
for plotting are stored as factor, because they are 64 bits integer
and the numeric representation keeps only the high part of the
addresses.
Let see if I manage to plot something using the gmp library:

#+begin_src R :results output :session :exports both
library(gmp)
head(t)
str(t)
t$PageB <- as.bigz(t$Page)
head(t)
str(t)
#+end_src

#+RESULTS:
#+begin_example
       Page Tid Structure  N
1 100003840   3 key_array 11
2 100007936   3 key_array 11
3 100012032   3 key_array 11
4 100016128   3 key_array 11
5 100020224   3 key_array 11
6  10002432   0 key_buff1  4
'data.frame':	337133 obs. of  4 variables:
 $ Page     : chr  "100003840" "100007936" "100012032" "100016128" ...
 $ Tid      : int  3 3 3 3 3 0 1 2 5 6 ...
 $ Structure: Factor w/ 14 levels "__GI___pthread_keys",..: 2 2 2 2 2 3 3 3 3 3 ...
 $ N        : int  11 11 11 11 11 4 2 4 4 4 ...
       Page Tid Structure  N     PageB
1 100003840   3 key_array 11 100003840
2 100007936   3 key_array 11 100007936
3 100012032   3 key_array 11 100012032
4 100016128   3 key_array 11 100016128
5 100020224   3 key_array 11 100020224
6  10002432   0 key_buff1  4  10002432
'data.frame':	337133 obs. of  5 variables:
 $ Page     : chr  "100003840" "100007936" "100012032" "100016128" ...
 $ Tid      : int  3 3 3 3 3 0 1 2 5 6 ...
 $ Structure: Factor w/ 14 levels "__GI___pthread_keys",..: 2 2 2 2 2 3 3 3 3 3 ...
 $ N        : int  11 11 11 11 11 4 2 4 4 4 ...
 $ PageB    :Class 'bigz'  raw [1:4045600] ed 24 05 00 ...
#+end_example

Was it that easy ?

#+begin_src R :results output graphics :file img/tabarnac_page_is_b_orig_bigz.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(t,aes(x=PageB,y=Tid,color=N)) +
  theme_bw() +
  geom_point() +
  facet_wrap(~Structure) +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/tabarnac_page_is_b_orig_bigz.png]]

Obviously it is not working we can try to unclass the dataframe, not
sure how it works:

#+begin_src R :results output graphics :file img/tabarnac_page_is_b_orig_bigz1.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(unclass(t),aes(x=PageB,y=Tid,color=N)) +
  theme_bw() +
  geom_point() +
  facet_wrap(~Structure) +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/tabarnac_page_is_b_orig_bigz1.png]]

That was a bad idea ...

I think it will be simpler to affect to each page a number
corresponding to it's delta in the structure:

#+begin_src R :results output :session :exports both
pageId <- function(df){
    base <- as.bigz(structs[grepl(df[3],structs$Structure),]$AddressStart)
    return(as.integer(as.character(df[5] - base)))
}
str(structs)
head(t)
t$PageI <- apply(t,1,pageId)
head(t)
#+end_src

#+RESULTS:
#+begin_example
'data.frame':	14 obs. of  4 variables:
 $ Structure   : Factor w/ 14 levels "__GI___pthread_keys",..: 1 5 3 2 4 14 6 7 8 9 ...
 $ AddressStart: int  2196192 2196192 6305024 14693632 148911360 283131920 283137392 283141504 283145616 283149728 ...
 $ AddressSize : int  16384 16384 8388608 134217728 134217728 32816 4096 4096 4096 4096 ...
 $ AddressEnd  : int  2212576 2212576 14693632 148911360 283129088 283164736 283141488 283145600 283149712 283153824 ...
       Page Tid Structure  N     PageB
1 100003840   3 key_array 11 100003840
2 100007936   3 key_array 11 100007936
3 100012032   3 key_array 11 100012032
4 100016128   3 key_array 11 100016128
5 100020224   3 key_array 11 100020224
6  10002432   0 key_buff1  4  10002432
       Page Tid Structure  N     PageB    PageI
1 100003840   3 key_array 11 100003840 85310208
2 100007936   3 key_array 11 100007936 85314304
3 100012032   3 key_array 11 100012032 85318400
4 100016128   3 key_array 11 100016128 85322496
5 100020224   3 key_array 11 100020224 85326592
6  10002432   0 key_buff1  4  10002432  3697408
#+end_example


#+begin_src R :results output graphics :file img/tabarnac_page_is_b_orig_int.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(t,aes(x=PageI,y=Tid,color=N)) +
  theme_bw() +
  geom_point() +
  facet_wrap(~Structure) +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/tabarnac_page_is_b_orig_int.png]]



We should plot data structure separatly, keybuff1 is so small we can't
see anything:

#+begin_src R :results output :session :exports both
head(s)
head(t)
heat(t[grepl("key_buff1",t$Structure),],n=50)
#+end_src

#+RESULTS:
#+begin_example
           Address Tid Structure  N      Page
1 100000888.000000   6 key_array  4  95315064
2 100003840.000000   3 key_array 11 100003840
3 100007216.000000   6 key_array  4  86179120
4 100007936.000000   3 key_array 11 100007936
5 100009484.000000   6 key_array  4  93668876
6 100012032.000000   3 key_array 11 100012032
       Page Tid Structure  N     PageB    PageI
1 100003840   3 key_array 11 100003840 85310208
2 100007936   3 key_array 11 100007936 85314304
3 100012032   3 key_array 11 100012032 85318400
4 100016128   3 key_array 11 100016128 85322496
5 100020224   3 key_array 11 100020224 85326592
6  10002432   0 key_buff1  4  10002432  3697408
        Page Tid Structure  N    PageB   PageI
6   10002432   0 key_buff1  4 10002432 3697408
7   10002432   1 key_buff1  2 10002432 3697408
8   10002432   2 key_buff1  4 10002432 3697408
9   10002432   5 key_buff1  4 10002432 3697408
10  10002432   6 key_buff1  4 10002432 3697408
24  10006528   0 key_buff1  2 10006528 3701504
25  10006528   1 key_buff1  2 10006528 3701504
26  10006528   4 key_buff1  6 10006528 3701504
27  10006528   5 key_buff1  6 10006528 3701504
28  10006528   6 key_buff1  6 10006528 3701504
31  10007088   5 key_buff1  5 10007088 3702064
43  10010624   1 key_buff1 10 10010624 3705600
44  10010624   2 key_buff1  4 10010624 3705600
45  10010624   3 key_buff1  8 10010624 3705600
46  10010624   5 key_buff1  4 10010624 3705600
47  10010624   6 key_buff1  4 10010624 3705600
60  10014720   0 key_buff1  4 10014720 3709696
61  10014720   1 key_buff1 10 10014720 3709696
62  10014720   2 key_buff1  6 10014720 3709696
63  10014720   3 key_buff1  8 10014720 3709696
64  10014720   5 key_buff1  8 10014720 3709696
65  10014720   6 key_buff1  4 10014720 3709696
78  10018816   4 key_buff1  4 10018816 3713792
79  10018816   5 key_buff1  2 10018816 3713792
80  10018816   6 key_buff1  2 10018816 3713792
81  10018816   7 key_buff1  6 10018816 3713792
93  10022912   0 key_buff1  6 10022912 3717888
94  10022912   1 key_buff1  4 10022912 3717888
95  10022912   4 key_buff1  8 10022912 3717888
96  10022912   5 key_buff1  8 10022912 3717888
97  10022912   6 key_buff1  2 10022912 3717888
98  10022912   7 key_buff1 16 10022912 3717888
109 10027008   0 key_buff1  2 10027008 3721984
110 10027008   1 key_buff1 10 10027008 3721984
111 10027008   2 key_buff1  4 10027008 3721984
112 10027008   6 key_buff1  4 10027008 3721984
113 10027008   7 key_buff1 14 10027008 3721984
126 10031104   0 key_buff1  2 10031104 3726080
127 10031104   1 key_buff1 10 10031104 3726080
128 10031104   7 key_buff1 20 10031104 3726080
143 10035200   0 key_buff1  6 10035200 3730176
144 10035200   2 key_buff1  4 10035200 3730176
145 10035200   3 key_buff1  4 10035200 3730176
146 10035200   6 key_buff1  2 10035200 3730176
157 10039296   0 key_buff1  6 10039296 3734272
158 10039296   2 key_buff1  4 10039296 3734272
159 10039296   3 key_buff1  4 10039296 3734272
160 10039296   6 key_buff1  2 10039296 3734272
164 10040148   0 key_buff1  4 10040148 3735124
174 10043392   0 key_buff1  2 10043392 3738368
#+end_example


#+begin_src R :results output graphics :file img/tabarnac_page_is_b_orig_int_kb1.png :exports both :width 600 :height 400 :session
library(ggplot2);
u<-t[grepl("key_buff1",t$Structure),];
p <- ggplot(u,aes(x=PageI,y=Tid,color=N)) +
  theme_bw() +
  geom_point() +
  facet_wrap(~Structure) +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/tabarnac_page_is_b_orig_int_kb1.png]]


There are some negative pageIds I don't know why, but it is late and
I'm exhausted, I'll fix that tomorrow.

* DONE 2016-03-02 Continue on Tabarnac likes plot                     :David:
- State "DONE"       from "TODO"       [2016-03-03 Thu 15:11]
- State "TODO"       from              [2016-03-02 Wed 10:58]
  
We continue on the analysis from: [[*Tabarnac like plots wth Moca traces][yesterday]] trying to fix the
"addresses as factor" issue, to do so, we parse the addresses as bigz
as soon as possible:

#+begin_src R :results output :session :exports both
library(gmp)
computeType <- function(df){
  shared <-9
  write <- 4
  if(df[shared] >= 2){
    mytype <- "Shared"
  }else{
    mytype <- "Private"
  }
  if(df[write] >= 1){
     mytype <- paste(mytype,"Write" , sep="_")
  }else{
     mytype <- paste(mytype,"Read" , sep="_")
  }
  return(mytype)
}

k <- read.csv("Moca-is.B-orig-2016-03-01_14-03-40/Moca-framesoc.csv", header=T);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

k$Value <- apply(k,1,computeType)
# Use bigz to parse
k$Address <- as.character(as.bigz(paste("0x", k$Address, sep="")))
k$Phy <- NULL;
k$CPU <- NULL;
#k$Tid <- NULL;
#k$Reads <- NULL ;
#k$Writes <- NULL ;
k$Duration <- k$End - k$Start
head(k);
str(k)

# Add structure info
g <- k
structs <- read.csv("Moca-is.B-orig-2016-03-01_14-03-40/is.B-orig.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
# Use bigz to compute End, then go back tochar at sqldf does not handle bigz
structs$AddressStart <- as.bigz(structs$AddressStart)
structs$AddressSize <- as.bigz(structs$AddressSize)
structs$AddressEnd = as.character(structs$AddressStart + structs$AddressSize);
structs$AddressStart <- as.character(structs$AddressStart)
structs$AddressSize <-  as.character(structs$AddressSize)

str(structs)
show(structs)

library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.Reads, g.Writes, g.Tid, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);
#+end_src

#+RESULTS:
#+begin_example
            X.Virt            X.Phy Nreads Nwrites CPUMask  Start    End TaskId
1 0000000000400040 000062000b1dfa80      1       0    1011      1    171      0
2 00000000004002a8 000062000b1dfa80      1       0    1011  32663  34153      0
3 0000000000400bd4 000062000b1dfa80      1       0    1011  55271  72678      0
4 00000000004009a0 000062000b1dfa80      1       0      11  88569  88776      1
5 00000000004009a0 000062000b1dfa80      1       0     111  92562 103554      7
6 00000000004009a0 000062000b1dfa80      1       0   10011 238634 245102      2
  Shared
1      1
2      1
3      1
4      1
5      1
6      1
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
  Address Reads Writes  Start    End Tid N        Value Duration
1 4194368     1      0      1    171   0 1 Private_Read      170
2 4194984     1      0  32663  34153   0 1 Private_Read     1490
3 4197332     1      0  55271  72678   0 1 Private_Read    17407
4 4196768     1      0  88569  88776   1 1 Private_Read      207
5 4196768     1      0  92562 103554   7 1 Private_Read    10992
6 4196768     1      0 238634 245102   2 1 Private_Read     6468
'data.frame':	1157330 obs. of  9 variables:
 $ Address : chr  "4194368" "4194984" "4197332" "4196768" ...
 $ Reads   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes  : int  0 0 0 0 0 0 0 0 0 0 ...
 $ Start   : int  1 32663 55271 88569 92562 238634 254421 258859 258859 286485 ...
 $ End     : int  171 34153 72678 88776 103554 245102 258859 286485 286485 310331 ...
 $ Tid     : int  0 0 0 1 7 2 4 4 6 6 ...
 $ N       : int  1 1 1 1 1 1 1 2 2 1 ...
 $ Value   : chr  "Private_Read" "Private_Read" "Private_Read" "Private_Read" ...
 $ Duration: int  170 1490 17407 207 10992 6468 4438 27626 27626 23846 ...
'data.frame':	14 obs. of  4 variables:
 $ Structure   : Factor w/ 14 levels "__GI___pthread_keys",..: 1 5 3 2 4 14 6 7 8 9 ...
 $ AddressStart: chr  "2196192" "2196192" "6305024" "14693632" ...
 $ AddressSize : chr  "16384" "16384" "8388608" "134217728" ...
 $ AddressEnd  : chr  "2212576" "2212576" "14693632" "148911360" ...
                       Structure AddressStart AddressSize AddressEnd
1            __GI___pthread_keys      2196192       16384    2212576
2                 __pthread_keys      2196192       16384    2212576
3                      key_buff1      6305024     8388608   14693632
4                      key_array     14693632   134217728  148911360
5                      key_buff2    148911360   134217728  283129088
6                UnnamedStruct#2    283131920       32816  283164736
7    /tmp/NPB3.3-OMP/IS/is.c:494    283137392        4096  283141488
8  /tmp/NPB3.3-OMP/IS/is.c:494-1    283141504        4096  283145600
9  /tmp/NPB3.3-OMP/IS/is.c:494-2    283145616        4096  283149712
10 /tmp/NPB3.3-OMP/IS/is.c:494-3    283149728        4096  283153824
11 /tmp/NPB3.3-OMP/IS/is.c:494-4    283153840        4096  283157936
12 /tmp/NPB3.3-OMP/IS/is.c:494-5    283157952        4096  283162048
13 /tmp/NPB3.3-OMP/IS/is.c:494-6    283162064        4096  283166160
14 /tmp/NPB3.3-OMP/IS/is.c:494-7    283166176        4096  283170272
   Address  Start    End Duration         Value Reads Writes Tid N Structure
1 14693632      1    171      170 Private_Write     1      1   0 1 key_array
2 14693636  55271  72678    17407 Private_Write     1      1   0 1 key_array
3 14693632  88513 100648    12135  Private_Read     1      0   0 1 key_array
4 14695032 100662 103515     2853  Private_Read     1      0   0 1 key_array
5 14693632 341425 377139    35714  Private_Read     1      0   0 1 key_array
6 14693632 377139 384252     7113   Shared_Read     1      0   0 2 key_array
#+end_example

From now on we should be able to use bigz only, so let's compute the
Page and Offset of each accesses

#+begin_src R :results output :session :exports both
n <- m[grepl("key_",m$Structure),]
# Compute the first page of each structure
pageAddr <- function(df,addrcol=1){
    addrCol <- 1
    a <- as.bigz(df[addrCol])
    return (as.character(a - mod.bigz(a,4096)));
}
#structs$Page <- apply(structs[c("AddressStart","Structure")],1,pageAddr);
show(structs)
offset <- function(df){
    AddrCol <- 1
    #PageCol <- 11
    structCol <- 10
    base <- as.bigz(structs[grepl(df[structCol],structs$Structure),]$AddressStart)
    return(as.integer(as.character((as.bigz(df[AddrCol]) - base))));
}
#n$Page <- apply(n,1,pageAddr)
n$Offset <- apply(n,1,offset)
str(n)
head(n)
#+end_src

#+RESULTS:
#+begin_example
                       Structure AddressStart AddressSize AddressEnd
1            __GI___pthread_keys      2196192       16384    2212576
2                 __pthread_keys      2196192       16384    2212576
3                      key_buff1      6305024     8388608   14693632
4                      key_array     14693632   134217728  148911360
5                      key_buff2    148911360   134217728  283129088
6                UnnamedStruct#2    283131920       32816  283164736
7    /tmp/NPB3.3-OMP/IS/is.c:494    283137392        4096  283141488
8  /tmp/NPB3.3-OMP/IS/is.c:494-1    283141504        4096  283145600
9  /tmp/NPB3.3-OMP/IS/is.c:494-2    283145616        4096  283149712
10 /tmp/NPB3.3-OMP/IS/is.c:494-3    283149728        4096  283153824
11 /tmp/NPB3.3-OMP/IS/is.c:494-4    283153840        4096  283157936
12 /tmp/NPB3.3-OMP/IS/is.c:494-5    283157952        4096  283162048
13 /tmp/NPB3.3-OMP/IS/is.c:494-6    283162064        4096  283166160
14 /tmp/NPB3.3-OMP/IS/is.c:494-7    283166176        4096  283170272
'data.frame':	792868 obs. of  11 variables:
 $ Address  : chr  "14693632" "14693636" "14693632" "14695032" ...
 $ Start    : int  1 55271 88513 100662 341425 377139 546598 618709 659766 1 ...
 $ End      : int  171 72678 100648 103515 377139 384252 618709 659753 689920 171 ...
 $ Duration : int  170 17407 12135 2853 35714 7113 72111 41044 30154 170 ...
 $ Value    : chr  "Private_Write" "Private_Write" "Private_Read" "Private_Read" ...
 $ Reads    : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes   : int  1 1 0 0 0 0 0 0 0 1 ...
 $ Tid      : int  0 0 0 0 0 0 0 0 0 0 ...
 $ N        : int  1 1 1 1 1 2 2 1 1 1 ...
 $ Structure: Factor w/ 14 levels "__GI___pthread_keys",..: 2 2 2 2 2 2 2 2 2 2 ...
 $ Offset   : int  0 4 0 1400 0 0 0 0 0 2816 ...
   Address  Start    End Duration         Value Reads Writes Tid N Structure
1 14693632      1    171      170 Private_Write     1      1   0 1 key_array
2 14693636  55271  72678    17407 Private_Write     1      1   0 1 key_array
3 14693632  88513 100648    12135  Private_Read     1      0   0 1 key_array
4 14695032 100662 103515     2853  Private_Read     1      0   0 1 key_array
5 14693632 341425 377139    35714  Private_Read     1      0   0 1 key_array
6 14693632 377139 384252     7113   Shared_Read     1      0   0 2 key_array
  Offset
1      0
2      4
3      0
4   1400
5      0
6      0
#+end_example

Let's check if it's ok:
#+begin_src R :results output :session :exports both
head(subset(n,n$Offset < 0)) 
#+end_src

#+RESULTS:
#+begin_example
     Address  Start    End Duration         Value Reads Writes Tid N Structure
944 14893056    178   2972     2794 Private_Write     1      1   0 1 key_buff2
945 14893056  55271  72678    17407  Private_Read     1      0   0 1 key_buff2
946 14893056 106948 117919    10971  Private_Read     1      0   0 1 key_buff2
947 14893056 313094 341415    28321  Private_Read     1      0   0 1 key_buff2
948 14893056 341425 384252    42827  Private_Read     1      0   0 1 key_buff2
949 14893056 384254 444926    60672  Private_Read     1      0   0 1 key_buff2
        Offset
944 -134018304
945 -134018304
946 -134018304
947 -134018304
948 -134018304
949 -134018304
#+end_example

We have some negative offset again, I guess that the sqldf is not
working as it is doing comparison on factors, let see if we can do
this comparing big integers:

#+begin_src R :results output :session :exports both
library(gmp)


k <- read.csv("Moca-is.B-orig-2016-03-01_14-03-40/Moca-framesoc.csv", header=T);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

# Use bigz to parse
k$Address <- as.bigz(paste("0x", k$Address, sep=""))
k$Phy <- NULL;
k$CPU <- NULL;
k$Duration <- k$End - k$Start
head(k);
str(k)

# Add structure info
structs <- read.csv("Moca-is.B-orig-2016-03-01_14-03-40/is.B-orig.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressStart <- as.bigz(structs$AddressStart)
structs$AddressSize <- as.bigz(structs$AddressSize)
structs$AddressEnd <- structs$AddressStart + structs$AddressSize


# Filter interesting data structure as soon as possible
structs <- structs[grepl("key_",structs$Structure),]
str(structs)
show(structs)
#+end_src

#+RESULTS:
#+begin_example

Attaching package: ‘gmp’

The following objects are masked from ‘package:base’:

    %*%, apply, crossprod, matrix, tcrossprod
            X.Virt            X.Phy Nreads Nwrites CPUMask  Start    End TaskId
1 0000000000400040 000062000b1dfa80      1       0    1011      1    171      0
2 00000000004002a8 000062000b1dfa80      1       0    1011  32663  34153      0
3 0000000000400bd4 000062000b1dfa80      1       0    1011  55271  72678      0
4 00000000004009a0 000062000b1dfa80      1       0      11  88569  88776      1
5 00000000004009a0 000062000b1dfa80      1       0     111  92562 103554      7
6 00000000004009a0 000062000b1dfa80      1       0   10011 238634 245102      2
  Shared
1      1
2      1
3      1
4      1
5      1
6      1
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
  Address Reads Writes  Start    End Tid N Duration
1 4194368     1      0      1    171   0 1      170
2 4194984     1      0  32663  34153   0 1     1490
3 4197332     1      0  55271  72678   0 1    17407
4 4196768     1      0  88569  88776   1 1      207
5 4196768     1      0  92562 103554   7 1    10992
6 4196768     1      0 238634 245102   2 1     6468
'data.frame':	1157330 obs. of  8 variables:
 $ Address :Class 'bigz'  raw [1:13892924] d2 a8 11 00 ...
 $ Reads   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes  : int  0 0 0 0 0 0 0 0 0 0 ...
 $ Start   : int  1 32663 55271 88569 92562 238634 254421 258859 258859 286485 ...
 $ End     : int  171 34153 72678 88776 103554 245102 258859 286485 286485 310331 ...
 $ Tid     : int  0 0 0 1 7 2 4 4 6 6 ...
 $ N       : int  1 1 1 1 1 1 1 2 2 1 ...
 $ Duration: int  170 1490 17407 207 10992 6468 4438 27626 27626 23846 ...
'data.frame':	3 obs. of  4 variables:
 $ Structure   : Factor w/ 14 levels "__GI___pthread_keys",..: 3 2 4
 $ AddressStart:Class 'bigz'  raw [1:40] 03 00 00 00 ...
 $ AddressSize :Class 'bigz'  raw [1:40] 03 00 00 00 ...
 $ AddressEnd  :Class 'bigz'  raw [1:40] 03 00 00 00 ...
  Structure AddressStart AddressSize AddressEnd
3 key_buff1      6305024     8388608   14693632
4 key_array     14693632   134217728  148911360
5 key_buff2    148911360   134217728  283129088
#+end_example

We now that because of the preprocessing both k and structs are sorted
increasingly, we can use this to compute quickly data structure
without using sqldf (which does not handle big integers).
First let filter out everything that is not in a data structure:

#+begin_src R :results output :session :exports both
nrow(k)
minA <- structs[1,2]
maxA <- structs[3,4]
l <- subset(k, k$Address >= minA & k$Address <= maxA)
computeType <- function(df){
  shared <- 7
  write  <- 3
  if(df[shared] >= 2){
    mytype <- "Shared"
  }else{
    mytype <- "Private"
  }
  if(df[write] >= 1){
     mytype <- paste(mytype,"Write" , sep="_")
  }else{
     mytype <- paste(mytype,"Read" , sep="_")
  }
  return(mytype)
}
l$Value <- apply(l,1,computeType)
nrow(l)
head(l)
getStruct <- function(vect){
    aCol <- 1
    while(vect[1] > structs[curStruct,4]){
      curStruct <- curStruct +1;
    }
    return(structs[curStruct,1]);
}
curStruct <- 1
l$Structure <- apply(l,1,getStruct)
head(l)
#+end_src

#+RESULTS:
#+begin_example
[1] 1157330
[1] 1150520
   Address Reads Writes  Start    End Tid N Duration         Value
80 6307840     1      1 279630 283344   7 1     3714 Private_Write
81 6307840     1      1 310398 410993   6 1   100595 Private_Write
82 6307840     1      1 452318 485570   6 1    33252 Private_Write
83 6307840     1      1 485572 511748   6 1    26176 Private_Write
84 6307840     1      1 511748 521080   6 2     9332  Shared_Write
85 6307840     1      1 511748 521080   0 2     9332  Shared_Write
   Address Reads Writes  Start    End Tid N Duration         Value Structure
80 6307840     1      1 279630 283344   7 1     3714 Private_Write key_buff1
81 6307840     1      1 310398 410993   6 1   100595 Private_Write key_buff1
82 6307840     1      1 452318 485570   6 1    33252 Private_Write key_buff1
83 6307840     1      1 485572 511748   6 1    26176 Private_Write key_buff1
84 6307840     1      1 511748 521080   6 2     9332  Shared_Write key_buff1
85 6307840     1      1 511748 521080   0 2     9332  Shared_Write key_buff1
#+end_example

This is clearly not the R way to do this and it is not very efficient
(about 5'), but it works.
We can now compute offset and it shouldn't be negative:

#+begin_src R :results output :session :exports both
pageAddr <- function(df,addrcol=1){
    addrCol <- 1
    a <- as.bigz(df[addrCol])
    return (as.character(a - mod.bigz(a,4096)));
}
structs$Page <- apply(structs[c("AddressStart","Structure")],1,pageAddr);
show(structs)
offset <- function(df){
    PageCol <- 11
    structCol <- 10
    base <- as.bigz(structs[grepl(df[structCol],structs$Structure),]$Page)
    return(as.integer(as.character((as.bigz(df[PageCol]) - base)))/4096);
}
l$Page <- apply(l,1,pageAddr)
l$Offset <- apply(l,1,offset)
str(l)
head(l)
#+end_src

#+RESULTS:
#+begin_example
  Structure AddressStart AddressSize AddressEnd      Page
3 key_buff1      6305024     8388608   14693632   6303744
4 key_array     14693632   134217728  148911360  14692352
5 key_buff2    148911360   134217728  283129088 148910080
'data.frame':	1150520 obs. of  12 variables:
 $ Address  :Class 'bigz'  raw [1:13806244] 38 8e 11 00 ...
 $ Reads    : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Start    : int  279630 310398 452318 485572 511748 511748 521080 522640 522640 538401 ...
 $ End      : int  283344 410993 485570 511748 521080 521080 522640 538401 538401 578774 ...
 $ Tid      : int  7 6 6 6 6 0 0 0 6 6 ...
 $ N        : int  1 1 1 1 2 2 1 2 2 1 ...
 $ Duration : int  3714 100595 33252 26176 9332 9332 1560 15761 15761 40373 ...
 $ Value    : chr  "Private_Write" "Private_Write" "Private_Write" "Private_Write" ...
 $ Structure: Factor w/ 14 levels "__GI___pthread_keys",..: 3 3 3 3 3 3 3 3 3 3 ...
 $ Page     : chr  "6307840" "6307840" "6307840" "6307840" ...
 $ Offset   : num  1 1 1 1 1 1 1 1 1 1 ...
   Address Reads Writes  Start    End Tid N Duration         Value Structure
80 6307840     1      1 279630 283344   7 1     3714 Private_Write key_buff1
81 6307840     1      1 310398 410993   6 1   100595 Private_Write key_buff1
82 6307840     1      1 452318 485570   6 1    33252 Private_Write key_buff1
83 6307840     1      1 485572 511748   6 1    26176 Private_Write key_buff1
84 6307840     1      1 511748 521080   6 2     9332  Shared_Write key_buff1
85 6307840     1      1 511748 521080   0 2     9332  Shared_Write key_buff1
      Page Offset
80 6307840      1
81 6307840      1
82 6307840      1
83 6307840      1
84 6307840      1
85 6307840      1
#+end_example

Once again around 5 minutes, I guess we can improve this, but for now
let's continue

#+begin_src R :results output :session :exports both
library(plyr)
m <- ddply(l,.(Offset, Tid, Structure), summarize, N=sum(Reads)+sum(Writes));
str(m)
head(m)
#+end_src

This was creazily slow, from what I read, I guess that aggregate
should be faster, let's give it a try:

#+begin_src R :results output :session :exports both
m <- aggregate(l[,c('Reads','Writes', 'N')],l[,c('Tid','Structure','Offset')], function(d) sum(d));
str(m)
head(m)
#+end_src

#+RESULTS:
#+begin_example
'data.frame':	201665 obs. of  6 variables:
 $ Tid      : int  0 0 1 2 3 4 5 6 7 0 ...
 $ Structure: Factor w/ 14 levels "__GI___pthread_keys",..: 2 4 4 4 4 4 4 4 4 2 ...
 $ Offset   : num  0 0 0 0 0 0 0 0 0 1 ...
 $ Reads    : int  2 13 5 20 15 11 18 23 25 14 ...
 $ Writes   : int  1 6 5 20 15 10 10 12 14 2 ...
 $ N        : int  2 39 15 42 34 31 58 75 80 14 ...
  Tid Structure Offset Reads Writes  N
1   0 key_array      0     2      1  2
2   0 key_buff2      0    13      6 39
3   1 key_buff2      0     5      5 15
4   2 key_buff2      0    20     20 42
5   3 key_buff2      0    15     15 34
6   4 key_buff2      0    11     10 31
#+end_example

It tooks only a few seconds, this is impressive !

#+begin_src R :results output graphics :file img/tabarnac_page_is_b_offsetfix.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(m,aes(x=Offset,y=Tid,color=Reads+Writes)) +
  theme_bw() +
  geom_point() +
  facet_wrap(~Structure) +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/tabarnac_page_is_b_offsetfix.png]]


No more negative offset, this looks great, let's focus on keybuff1

#+begin_src R :results output graphics :file img/tabarnac_page_is_b_offsetfix_kb1.png :exports both :width 600 :height 400 :session
library(ggplot2);
n <- m[grepl("key_buff1", m$Structure),];
p <- ggplot(n,aes(x=Offset,y=Tid,color=Reads+Writes)) +
  theme_bw() +
  geom_point() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/tabarnac_page_is_b_offsetfix_kb1.png]]

And here comes the bad news: Moca traces are not precise enough to see
the fact that the middle addresses of keybuff1 are accessed more often
than the others...


What happens if we plot the number of threads using the page at the
same time:

#+begin_src R :results output graphics :file img/is_b_intensity_offset.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(m,aes(x=Offset,y=Tid,color=N)) +
  theme_bw() +
  geom_point() +
  theme(legend.title=element_blank()) +
  facet_wrap(~Structure) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/is_b_intensity_offset.png]]

Once again we need to zoom

#+begin_src R :results output graphics :file img/is_b_intensity_offset_kb1.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(n,aes(x=Offset,y=Tid,color=N)) +
  theme_bw() +
  geom_point() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/is_b_intensity_offset_kb1.png]]


And once again we can't see anything.

So it appears that with Moca if we gain the temporal information, our
traces are not precise enough to see the same things as Tabarnac.

While I was writing the code to do these plots, I fixed the ugly
addresses issue, I think I should redo the plot from [[*IShttp:][IS]] but with the
addresses fixed, maybe a pattern can appear.

My R code I very ugly and not really R-ish, @Lucas if you have some
time maybe you can speed up (the call to apply are very slow).

* 2016-03-03 Redo analysis from [[*IS][IS]] with addresses fixed               :David:

Let prepare the data as in [[*2016-03-02 Continue on Tabarnac likes plot][2016-03-02 Continue on Tabarnac likes plot]]:


#+begin_src R :results output :session :exports both
library(gmp)


k <- read.csv("Moca-is.B-orig-2016-03-01_14-03-40/Moca-framesoc.csv", header=T);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

# Use bigz to parse
k$Address <- as.bigz(paste("0x", k$Address, sep=""))
k$Phy <- NULL;
k$CPU <- NULL;
k$Duration <- k$End - k$Start
head(k);
str(k)

# Add structure info
structs <- read.csv("Moca-is.B-orig-2016-03-01_14-03-40/is.B-orig.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressStart <- as.bigz(structs$AddressStart)
structs$AddressSize <- as.bigz(structs$AddressSize)
structs$AddressEnd <- structs$AddressStart + structs$AddressSize


# Filter interesting data structure as soon as possible
structs <- structs[grepl("key_",structs$Structure),]
str(structs)
show(structs)

# Retrieve struct infos
nrow(k)
minA <- structs[1,2]
maxA <- structs[3,4]
l <- subset(k, k$Address >= minA & k$Address <= maxA)
computeType <- function(df){
  shared <- 7
  write  <- 3
  if(df[shared] >= 2){
    mytype <- "Shared"
  }else{
    mytype <- "Private"
  }
  if(df[write] >= 1){
     mytype <- paste(mytype,"Write" , sep="_")
  }else{
     mytype <- paste(mytype,"Read" , sep="_")
  }
  return(mytype)
}
l$Value <- apply(l,1,computeType)
nrow(l)
head(l)
getStruct <- function(vect){
    aCol <- 1
    while(vect[1] > structs[curStruct,4]){
      curStruct <- curStruct +1;
    }
    return(structs[curStruct,1]);
}
curStruct <- 1
l$Structure <- apply(l,1,getStruct)
head(l)
#+end_src

#+RESULTS:
#+begin_example

Attaching package: ‘gmp’

The following objects are masked from ‘package:base’:

    %*%, apply, crossprod, matrix, tcrossprod
            X.Virt            X.Phy Nreads Nwrites CPUMask  Start    End TaskId
1 0000000000400040 000062000b1dfa80      1       0    1011      1    171      0
2 00000000004002a8 000062000b1dfa80      1       0    1011  32663  34153      0
3 0000000000400bd4 000062000b1dfa80      1       0    1011  55271  72678      0
4 00000000004009a0 000062000b1dfa80      1       0      11  88569  88776      1
5 00000000004009a0 000062000b1dfa80      1       0     111  92562 103554      7
6 00000000004009a0 000062000b1dfa80      1       0   10011 238634 245102      2
  Shared
1      1
2      1
3      1
4      1
5      1
6      1
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
  Address Reads Writes  Start    End Tid N Duration
1 4194368     1      0      1    171   0 1      170
2 4194984     1      0  32663  34153   0 1     1490
3 4197332     1      0  55271  72678   0 1    17407
4 4196768     1      0  88569  88776   1 1      207
5 4196768     1      0  92562 103554   7 1    10992
6 4196768     1      0 238634 245102   2 1     6468
'data.frame':	1157330 obs. of  8 variables:
 $ Address :Class 'bigz'  raw [1:13892924] d2 a8 11 00 ...
 $ Reads   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes  : int  0 0 0 0 0 0 0 0 0 0 ...
 $ Start   : int  1 32663 55271 88569 92562 238634 254421 258859 258859 286485 ...
 $ End     : int  171 34153 72678 88776 103554 245102 258859 286485 286485 310331 ...
 $ Tid     : int  0 0 0 1 7 2 4 4 6 6 ...
 $ N       : int  1 1 1 1 1 1 1 2 2 1 ...
 $ Duration: int  170 1490 17407 207 10992 6468 4438 27626 27626 23846 ...
'data.frame':	3 obs. of  4 variables:
 $ Structure   : Factor w/ 14 levels "__GI___pthread_keys",..: 3 2 4
 $ AddressStart:Class 'bigz'  raw [1:40] 03 00 00 00 ...
 $ AddressSize :Class 'bigz'  raw [1:40] 03 00 00 00 ...
 $ AddressEnd  :Class 'bigz'  raw [1:40] 03 00 00 00 ...
  Structure AddressStart AddressSize AddressEnd
3 key_buff1      6305024     8388608   14693632
4 key_array     14693632   134217728  148911360
5 key_buff2    148911360   134217728  283129088
[1] 1157330
[1] 1150520
   Address Reads Writes  Start    End Tid N Duration         Value
80 6307840     1      1 279630 283344   7 1     3714 Private_Write
81 6307840     1      1 310398 410993   6 1   100595 Private_Write
82 6307840     1      1 452318 485570   6 1    33252 Private_Write
83 6307840     1      1 485572 511748   6 1    26176 Private_Write
84 6307840     1      1 511748 521080   6 2     9332  Shared_Write
85 6307840     1      1 511748 521080   0 2     9332  Shared_Write
   Address Reads Writes  Start    End Tid N Duration         Value Structure
80 6307840     1      1 279630 283344   7 1     3714 Private_Write key_buff1
81 6307840     1      1 310398 410993   6 1   100595 Private_Write key_buff1
82 6307840     1      1 452318 485570   6 1    33252 Private_Write key_buff1
83 6307840     1      1 485572 511748   6 1    26176 Private_Write key_buff1
84 6307840     1      1 511748 521080   6 2     9332  Shared_Write key_buff1
85 6307840     1      1 511748 521080   0 2     9332  Shared_Write key_buff1
#+end_example

Now compute offset for each addresses instead of for each pages:

#+begin_src R :results output :session :exports both
# Compute offset
#pageAddr <- function(df,addrcol=1){
#    addrCol <- 1
#    a <- as.bigz(df[addrCol])
#    return (as.character(a - mod.bigz(a,4096)));
#}
#structs$Page <- apply(structs[c("AddressStart","Structure")],1,pageAddr);
#show(structs)
m <- l
offset <- function(df){
    AddrCol <- 1
    structCol <- 10
    base <- as.bigz(structs[grepl(df[structCol],structs$Structure),]$AddressStart)
    return(as.integer(as.character((as.bigz(df[AddrCol]) - base))));
}
#l$Page <- apply(l,1,pageAddr)
m$Offset <- apply(m,1,offset)
str(m)
head(m)
#+end_src

#+RESULTS:
#+begin_example
'data.frame':	1150520 obs. of  11 variables:
 $ Address  :Class 'bigz'  raw [1:13806244] 38 8e 11 00 ...
 $ Reads    : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Start    : int  279630 310398 452318 485572 511748 511748 521080 522640 522640 538401 ...
 $ End      : int  283344 410993 485570 511748 521080 521080 522640 538401 538401 578774 ...
 $ Tid      : int  7 6 6 6 6 0 0 0 6 6 ...
 $ N        : int  1 1 1 1 2 2 1 2 2 1 ...
 $ Duration : int  3714 100595 33252 26176 9332 9332 1560 15761 15761 40373 ...
 $ Value    : chr  "Private_Write" "Private_Write" "Private_Write" "Private_Write" ...
 $ Structure: Factor w/ 14 levels "__GI___pthread_keys",..: 3 3 3 3 3 3 3 3 3 3 ...
 $ Offset   : int  2816 2816 2816 2816 2816 2816 2816 2816 2816 2816 ...
   Address Reads Writes  Start    End Tid N Duration         Value Structure
80 6307840     1      1 279630 283344   7 1     3714 Private_Write key_buff1
81 6307840     1      1 310398 410993   6 1   100595 Private_Write key_buff1
82 6307840     1      1 452318 485570   6 1    33252 Private_Write key_buff1
83 6307840     1      1 485572 511748   6 1    26176 Private_Write key_buff1
84 6307840     1      1 511748 521080   6 2     9332  Shared_Write key_buff1
85 6307840     1      1 511748 521080   0 2     9332  Shared_Write key_buff1
   Offset
80   2816
81   2816
82   2816
83   2816
84   2816
85   2816
#+end_example

#+begin_src R :results output :session :exports both
n <- aggregate(m[,c('Reads','Writes', 'N')],m[,c('Structure','Offset', 'Value', 'Start', 'End')], function(d) sum(d));
str(n)
head(n)
#+end_src

#+RESULTS:
#+begin_example
'data.frame':	1078089 obs. of  8 variables:
 $ Structure: Factor w/ 14 levels "__GI___pthread_keys",..: 2 2 2 3 3 3 3 3 3 3 ...
 $ Offset   : int  83884800 2816 6912 981472 1014168 1019864 1025192 1027256 1034226 1035544 ...
 $ Value    : chr  "Private_Write" "Private_Write" "Private_Write" "Private_Write" ...
 $ Start    : int  157 1 1 1 1 1 1 1 1 1 ...
 $ End      : int  158 171 171 171 171 171 171 171 171 171 ...
 $ Reads    : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ N        : int  1 1 1 1 1 1 1 1 1 1 ...
  Structure   Offset         Value Start End Reads Writes N
1 key_array 83884800 Private_Write   157 158     1      1 1
2 key_array     2816 Private_Write     1 171     1      1 1
3 key_array     6912 Private_Write     1 171     1      1 1
4 key_buff1   981472 Private_Write     1 171     1      1 1
5 key_buff1  1014168 Private_Write     1 171     1      1 1
6 key_buff1  1019864 Private_Write     1 171     1      1 1
#+end_example

#+begin_src R :results output graphics :file img/intensity_Rw_is_B_fixy.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(n) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Offset,yend=Offset, color=Reads+Writes)) +
  facet_grid(Structure~Value, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_Rw_is_B_fixy.png]]

This is the fixed version of 
[[file:img/intensity_is_B_orig_threads_zoom_nacc.png][file:~/Work/labbook-lucas/img/intensity_is_B_orig_threads_zoom_nacc.png]]

The patterns are quite similar, we can see some differences on keyarray.


What happens if we look at the intensity in terms of number of
threads:

#+begin_src R :results output graphics :file img/intensity_Th_is_B_fixy.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Offset,yend=Offset, color=N)) +
  facet_grid(Structure~Value, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_Th_is_B_fixy.png]]

The original version  was 

[[file:img/intensity_is_threads_zoom.png][file:~/Work/labbook-lucas/img/intensity_is_threads_zoom.png]]


Once again we can't see a difference of pattern between the addresses
of IS, still the change on the way we compute the addresses has an
important impact on the resulting visualization. I think we need to
redo the analysis of IS modif and the two matrix, but maybe we should
improve my R code before.

 If we can't see the difference of pattern inside keybuff1 as we did
 with tabarnac, we can still identify that keybuff1 usage is
 problematic as it is intesensively shared in write mode by more than
 half the threads.

* 2016-03-07 Improve parsing time                                     :David:

Same analysis as [[*2016-03-03%20Redo%20analysis%20from%20%5B%5B*IS%5D%5BIS%5D%5D%20with%20addresses%20fixed][2016-03-03 Redo analysis from IS with addresses fixed]]
but try to do it faster

First let compute the base time
#+begin_src R :results output :session :exports both
library(gmp)


system.time(k <- read.csv("Moca-is.B-orig-2016-03-01_14-03-40/Moca-framesoc.csv", header=T));
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

# Use bigz to parse
k$Address <- as.bigz(paste("0x", k$Address, sep=""))
k$Phy <- NULL;
k$CPU <- NULL;
k$Duration <- k$End - k$Start
head(k);
str(k)

# Add structure info
structs <- read.csv("Moca-is.B-orig-2016-03-01_14-03-40/is.B-orig.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressStart <- as.bigz(structs$AddressStart)
structs$AddressSize <- as.bigz(structs$AddressSize)
structs$AddressEnd <- structs$AddressStart + structs$AddressSize


# Filter interesting data structure as soon as possible
structs <- structs[grepl("key_",structs$Structure),]
str(structs)
show(structs)

# Retrieve struct infos
nrow(k)
minA <- structs[1,2]
maxA <- structs[3,4]
system.time(l <- subset(k, k$Address >= minA & k$Address <= maxA));
computeType <- function(df){
  shared <- 7
  write  <- 3
  if(df[shared] >= 2){
    mytype <- "Shared"
  }else{
    mytype <- "Private"
  }
  if(df[write] >= 1){
     mytype <- paste(mytype,"Write" , sep="_")
  }else{
     mytype <- paste(mytype,"Read" , sep="_")
  }
  return(mytype)
}
system.time(l$Value <- apply(l,1,computeType));
nrow(l)
head(l)
getStruct <- function(vect){
    aCol <- 1
    while(vect[1] > structs[curStruct,4]){
      curStruct <- curStruct +1;
    }
    return(structs[curStruct,1]);
}
curStruct <- 1
system.time(l$Structure <- apply(l,1,getStruct))
head(l)
#+end_src

#+RESULTS:
#+begin_example

Attaching package: ‘gmp’

The following objects are masked from ‘package:base’:

    %*%, apply, crossprod, matrix, tcrossprod
   user  system elapsed 
  7.476   0.088   7.566
            X.Virt            X.Phy Nreads Nwrites CPUMask  Start    End TaskId
1 0000000000400040 000062000b1dfa80      1       0    1011      1    171      0
2 00000000004002a8 000062000b1dfa80      1       0    1011  32663  34153      0
3 0000000000400bd4 000062000b1dfa80      1       0    1011  55271  72678      0
4 00000000004009a0 000062000b1dfa80      1       0      11  88569  88776      1
5 00000000004009a0 000062000b1dfa80      1       0     111  92562 103554      7
6 00000000004009a0 000062000b1dfa80      1       0   10011 238634 245102      2
  Shared
1      1
2      1
3      1
4      1
5      1
6      1
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
  Address Reads Writes  Start    End Tid N Duration
1 4194368     1      0      1    171   0 1      170
2 4194984     1      0  32663  34153   0 1     1490
3 4197332     1      0  55271  72678   0 1    17407
4 4196768     1      0  88569  88776   1 1      207
5 4196768     1      0  92562 103554   7 1    10992
6 4196768     1      0 238634 245102   2 1     6468
'data.frame':	1157330 obs. of  8 variables:
 $ Address :Class 'bigz'  raw [1:13892924] d2 a8 11 00 ...
 $ Reads   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes  : int  0 0 0 0 0 0 0 0 0 0 ...
 $ Start   : int  1 32663 55271 88569 92562 238634 254421 258859 258859 286485 ...
 $ End     : int  171 34153 72678 88776 103554 245102 258859 286485 286485 310331 ...
 $ Tid     : int  0 0 0 1 7 2 4 4 6 6 ...
 $ N       : int  1 1 1 1 1 1 1 2 2 1 ...
 $ Duration: int  170 1490 17407 207 10992 6468 4438 27626 27626 23846 ...
'data.frame':	3 obs. of  4 variables:
 $ Structure   : Factor w/ 14 levels "__GI___pthread_keys",..: 3 2 4
 $ AddressStart:Class 'bigz'  raw [1:40] 03 00 00 00 ...
 $ AddressSize :Class 'bigz'  raw [1:40] 03 00 00 00 ...
 $ AddressEnd  :Class 'bigz'  raw [1:40] 03 00 00 00 ...
  Structure AddressStart AddressSize AddressEnd
3 key_buff1      6305024     8388608   14693632
4 key_array     14693632   134217728  148911360
5 key_buff2    148911360   134217728  283129088
[1] 1157330
   user  system elapsed 
  2.604   0.044   2.645
   user  system elapsed 
 23.712   0.092  23.812
[1] 1150520
   Address Reads Writes  Start    End Tid N Duration         Value
80 6307840     1      1 279630 283344   7 1     3714 Private_Write
81 6307840     1      1 310398 410993   6 1   100595 Private_Write
82 6307840     1      1 452318 485570   6 1    33252 Private_Write
83 6307840     1      1 485572 511748   6 1    26176 Private_Write
84 6307840     1      1 511748 521080   6 2     9332  Shared_Write
85 6307840     1      1 511748 521080   0 2     9332  Shared_Write
   user  system elapsed 
200.472   0.396 200.992
   Address Reads Writes  Start    End Tid N Duration         Value Structure
80 6307840     1      1 279630 283344   7 1     3714 Private_Write key_buff1
81 6307840     1      1 310398 410993   6 1   100595 Private_Write key_buff1
82 6307840     1      1 452318 485570   6 1    33252 Private_Write key_buff1
83 6307840     1      1 485572 511748   6 1    26176 Private_Write key_buff1
84 6307840     1      1 511748 521080   6 2     9332  Shared_Write key_buff1
85 6307840     1      1 511748 521080   0 2     9332  Shared_Write key_buff1
#+end_example

As noticed before, the slow path correspond to the apply calls.
Let se if we can replace it by ddply:

#+begin_src R :results output :session :exports both
library(plyr)
m <- l
m$Type <- NULL
m$Structure <- NULL
m$shared <- k$shared
computeType <- function(df){
  shared <- 1
  write  <- 2
  if(df[shared] >= 2){
    mytype <- "Shared"
  }else{
    mytype <- "Private"
  }
  if(df[write] >= 1){
     mytype <- paste(mytype,"Write" , sep="_")
  }else{
     mytype <- paste(mytype,"Read" , sep="_")
  }
  return(mytype)
}
curStruct <- 1
getStruct <- function(vect){
    aCol <- 1
    while(vect[1] > structs[curStruct,4]){
      curStruct <- curStruct +1;
    }
    return(structs[curStruct,1]);
}
system.time(n <- ddply(m,.(Address,Start,End,Tid),Reads=Reads,Writes=Writes,Value=computeType(shared,Writes),
structure=getStruct(Address)));
nrow(n)
head(n)
#+end_src

This is worst, I killed R after around 20 minutes of computing with
results ...

let's retry focus only on access type for now

Redo the parsing step properly:

#+begin_src R :results output :session :exports both
library(gmp)


system.time(k <- read.csv("Moca-is.B-orig-2016-03-01_14-03-40/Moca-framesoc.csv", header=T));
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

# Use bigz to parse
k$Address <- as.bigz(paste("0x", k$Address, sep=""))
k$Phy <- NULL;
k$CPU <- NULL;
k$Duration <- k$End - k$Start
head(k);
str(k)

# Add structure info
structs <- read.csv("Moca-is.B-orig-2016-03-01_14-03-40/is.B-orig.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressStart <- as.bigz(structs$AddressStart)
structs$AddressSize <- as.bigz(structs$AddressSize)
structs$AddressEnd <- structs$AddressStart + structs$AddressSize


# Filter interesting data structure as soon as possible
structs <- structs[grepl("key_",structs$Structure),]
str(structs)
show(structs)

# Retrieve struct infos
nrow(k)
minA <- structs[1,2]
maxA <- structs[3,4]
system.time(l <- subset(k, k$Address >= minA & k$Address <= maxA));
head(l)
str(l)
#+end_src

#+RESULTS:
#+begin_example

Attaching package: ‘gmp’

The following objects are masked from ‘package:base’:

    %*%, apply, crossprod, matrix, tcrossprod
   user  system elapsed 
  7.804   0.212   8.032
            X.Virt            X.Phy Nreads Nwrites CPUMask  Start    End TaskId
1 0000000000400040 000062000b1dfa80      1       0    1011      1    171      0
2 00000000004002a8 000062000b1dfa80      1       0    1011  32663  34153      0
3 0000000000400bd4 000062000b1dfa80      1       0    1011  55271  72678      0
4 00000000004009a0 000062000b1dfa80      1       0      11  88569  88776      1
5 00000000004009a0 000062000b1dfa80      1       0     111  92562 103554      7
6 00000000004009a0 000062000b1dfa80      1       0   10011 238634 245102      2
  Shared
1      1
2      1
3      1
4      1
5      1
6      1
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
  Address Reads Writes  Start    End Tid N Duration
1 4194368     1      0      1    171   0 1      170
2 4194984     1      0  32663  34153   0 1     1490
3 4197332     1      0  55271  72678   0 1    17407
4 4196768     1      0  88569  88776   1 1      207
5 4196768     1      0  92562 103554   7 1    10992
6 4196768     1      0 238634 245102   2 1     6468
'data.frame':	1157330 obs. of  8 variables:
 $ Address :Class 'bigz'  raw [1:13892924] d2 a8 11 00 ...
 $ Reads   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes  : int  0 0 0 0 0 0 0 0 0 0 ...
 $ Start   : int  1 32663 55271 88569 92562 238634 254421 258859 258859 286485 ...
 $ End     : int  171 34153 72678 88776 103554 245102 258859 286485 286485 310331 ...
 $ Tid     : int  0 0 0 1 7 2 4 4 6 6 ...
 $ N       : int  1 1 1 1 1 1 1 2 2 1 ...
 $ Duration: int  170 1490 17407 207 10992 6468 4438 27626 27626 23846 ...
'data.frame':	3 obs. of  4 variables:
 $ Structure   : Factor w/ 14 levels "__GI___pthread_keys",..: 3 2 4
 $ AddressStart:Class 'bigz'  raw [1:40] 03 00 00 00 ...
 $ AddressSize :Class 'bigz'  raw [1:40] 03 00 00 00 ...
 $ AddressEnd  :Class 'bigz'  raw [1:40] 03 00 00 00 ...
  Structure AddressStart AddressSize AddressEnd
3 key_buff1      6305024     8388608   14693632
4 key_array     14693632   134217728  148911360
5 key_buff2    148911360   134217728  283129088
[1] 1157330
   user  system elapsed 
  2.652   0.032   2.692
   Address Reads Writes  Start    End Tid N Duration
80 6307840     1      1 279630 283344   7 1     3714
81 6307840     1      1 310398 410993   6 1   100595
82 6307840     1      1 452318 485570   6 1    33252
83 6307840     1      1 485572 511748   6 1    26176
84 6307840     1      1 511748 521080   6 2     9332
85 6307840     1      1 511748 521080   0 2     9332
'data.frame':	1150520 obs. of  8 variables:
 $ Address :Class 'bigz'  raw [1:13806244] 38 8e 11 00 ...
 $ Reads   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes  : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Start   : int  279630 310398 452318 485572 511748 511748 521080 522640 522640 538401 ...
 $ End     : int  283344 410993 485570 511748 521080 521080 522640 538401 538401 578774 ...
 $ Tid     : int  7 6 6 6 6 0 0 0 6 6 ...
 $ N       : int  1 1 1 1 2 2 1 2 2 1 ...
 $ Duration: int  3714 100595 33252 26176 9332 9332 1560 15761 15761 40373 ...
#+end_example

Now we can work on a clean data frame

#+begin_src R :results output :session :exports both
library(plyr)
m <- l
m$Type <- NULL
m$Structure <- NULL
computeType <- function(df){
  shared <- 1
  write  <- 2
  if(df[shared] >= 2){
    mytype <- "Shared"
  }else{
    mytype <- "Private"
  }
  if(df[write] >= 1){
     mytype <- paste(mytype,"Write" , sep="_")
  }else{
     mytype <- paste(mytype,"Read" , sep="_")
  }
  return(mytype)
}

system.time(n <- ddply(m,.(Address,Reads,Writes,Start,End,Tid,N,Duration),summarize,Value=computeType(N,Writes)));
nrow(n)
head(n)
#+end_src

Killed after 10 minute this time, let's forgot ddply, it does not
seems to be a good idea

We can use the ifelse function for the time:

#+begin_src R :results output :session :exports both
m <- l
system.time(m$aType <- ifelse(m$Write >0,"Write", "Read"));
system.time(m$sType <- ifelse(m$N > 1,"Shared","Private"));
system.time(m$Type <- paste(m$sType,m$aType,sep="_"));
m$sType <- NULL
m$aType <- NULL
head(m)
#+end_src

#+RESULTS:
#+begin_example
   user  system elapsed 
  0.428   0.008   0.437
   user  system elapsed 
  0.368   0.000   0.371
   user  system elapsed 
  0.224   0.000   0.224
   Address Reads Writes  Start    End Tid N Duration          Type
80 6307840     1      1 279630 283344   7 1     3714 Private_Write
81 6307840     1      1 310398 410993   6 1   100595 Private_Write
82 6307840     1      1 452318 485570   6 1    33252 Private_Write
83 6307840     1      1 485572 511748   6 1    26176 Private_Write
84 6307840     1      1 511748 521080   6 2     9332  Shared_Write
85 6307840     1      1 511748 521080   0 2     9332  Shared_Write
#+end_example


That was fast !

Maybe we can use something simlar, doing the apply on structs:

#+begin_src R :results output :session :exports both
n <- m
n$Structure <- NULL
structs <- structs[grepl("key_",structs$Structure),]
show(structs)
getStructReverse <- function (vect){
  name <- 1
  start <- 2
  end <- 4
  return (ifelse(n$Address >= vect[start] & n$Address <= vect[end],vect[name],""));
}
system.time(ans <- as.data.frame(apply(structs,1,getStructReverse)))
system.time(n$Structure <- apply(ans,1,paste,collapse=""));
head(n)
nrow(n)
#+end_src

#+RESULTS:
#+begin_example
  Structure AddressStart AddressSize AddressEnd
3 key_buff1      6305024     8388608   14693632
4 key_array     14693632   134217728  148911360
5 key_buff2    148911360   134217728  283129088
   user  system elapsed 
  3.144   0.000   3.144
   user  system elapsed 
  5.292   0.000   5.309
   Address Reads Writes  Start    End Tid N Duration          Type Structure
80 6307840     1      1 279630 283344   7 1     3714 Private_Write key_buff1
81 6307840     1      1 310398 410993   6 1   100595 Private_Write key_buff1
82 6307840     1      1 452318 485570   6 1    33252 Private_Write key_buff1
83 6307840     1      1 485572 511748   6 1    26176 Private_Write key_buff1
84 6307840     1      1 511748 521080   6 2     9332  Shared_Write key_buff1
85 6307840     1      1 511748 521080   0 2     9332  Shared_Write key_buff1
[1] 1150520
#+end_example

This is way faster than the previous method, about 8 seconds instead
of 200.

Let see if the data are correct (aka try to reproduce the same plots)

Hum the code of the followin step look slow, let see

#+begin_src R :results output :session :exports both
o <- n
offset <- function(df){
    AddrCol <- 1
    structCol <- 10
    base <- as.bigz(structs[grepl(df[structCol],structs$Structure),]$AddressStart)
    return(as.integer(as.character((as.bigz(df[AddrCol]) - base))));
}
system.time(o$Offset <- apply(o,1,offset))
str(o)
head(o)
#+end_src

#+RESULTS:
#+begin_example
   user  system elapsed 
288.736   0.384 289.671
[list output truncated]
   Address Reads Writes  Start    End Tid N Duration          Type Structure
80 6307840     1      1 279630 283344   7 1     3714 Private_Write key_buff1
81 6307840     1      1 310398 410993   6 1   100595 Private_Write key_buff1
82 6307840     1      1 452318 485570   6 1    33252 Private_Write key_buff1
83 6307840     1      1 485572 511748   6 1    26176 Private_Write key_buff1
84 6307840     1      1 511748 521080   6 2     9332  Shared_Write key_buff1
85 6307840     1      1 511748 521080   0 2     9332  Shared_Write key_buff1
   Offset
80   2816
81   2816
82   2816
83   2816
84   2816
85   2816
#+end_example

This is indeed quite slow ...
Maybe we can improve this by computing the offset while we retrieve
data structures:

#+begin_src R :results output :session :exports both
n <- m
n$Structure <- NULL
structs <- structs[grepl("key_",structs$Structure),]
show(structs)
getStructReverse <- function (vect){
  name <- 1
  start <- 2
  end <- 4
  return (ifelse(n$Address >= vect[start] & n$Address <= vect[end],
                paste(vect[name],as.bigz(n$Address) - as.bigz(vect[start]),sep="@"),""));
}
system.time(ans <- as.data.frame(apply(structs,1,getStructReverse)))
system.time(vect <- apply(ans,1,paste,collapse=""));
str(vect)
system.time(vect <- strsplit(vect,"@"))
str(vect)
system.time(n$Structure <- unlist(lapply(vect,"[[",1)))
system.time(n$Offset <- as.integer(unlist(lapply(vect,"[[",2))));
str(n)
head(n)
nrow(n)
#+end_src

#+RESULTS:
#+begin_example
  Structure AddressStart AddressSize AddressEnd
3 key_buff1      6305024     8388608   14693632
4 key_array     14693632   134217728  148911360
5 key_buff2    148911360   134217728  283129088
   user  system elapsed 
 11.308   0.036  11.357
   user  system elapsed 
  5.068   0.000   5.071
 chr [1:1150520] "key_buff1@2816" "key_buff1@2816" "key_buff1@2816" ...
   user  system elapsed 
  1.932   0.000   1.933
List of 1150520
 $ : chr [1:2] "key_buff1" "2816"
 $ : chr [1:2] "key_buff1" "2816"
 $ : chr [1:2] "key_buff1" "2816"
 $ : chr [1:2] "key_buff1" "2816"
 $ : chr [1:2] "key_buff1" "2816"
 $ : chr [1:2] "key_buff1" "2816"
 $ : chr [1:2] "key_buff1" "2816"
 $ : chr [1:2] "key_buff1" "2816"
 $ : chr [1:2] "key_buff1" "2816"
 $ : chr [1:2] "key_buff1" "2816"
 $ : chr [1:2] "key_buff1" "2816"
 $ : chr [1:2] "key_buff1" "2816"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "11008"
 $ : chr [1:2] "key_buff1" "11008"
 $ : chr [1:2] "key_buff1" "11008"
 $ : chr [1:2] "key_buff1" "11008"
 $ : chr [1:2] "key_buff1" "11008"
 $ : chr [1:2] "key_buff1" "11008"
 $ : chr [1:2] "key_buff1" "11008"
 $ : chr [1:2] "key_buff1" "11008"
 $ : chr [1:2] "key_buff1" "11008"
 $ : chr [1:2] "key_buff1" "11008"
 $ : chr [1:2] "key_buff1" "11008"
 $ : chr [1:2] "key_buff1" "11008"
 $ : chr [1:2] "key_buff1" "11008"
 $ : chr [1:2] "key_buff1" "11008"
 $ : chr [1:2] "key_buff1" "16384"
 $ : chr [1:2] "key_buff1" "16384"
 $ : chr [1:2] "key_buff1" "16384"
 $ : chr [1:2] "key_buff1" "16384"
 $ : chr [1:2] "key_buff1" "16384"
 $ : chr [1:2] "key_buff1" "16384"
 $ : chr [1:2] "key_buff1" "16384"
 $ : chr [1:2] "key_buff1" "16384"
 $ : chr [1:2] "key_buff1" "16384"
 $ : chr [1:2] "key_buff1" "16384"
 $ : chr [1:2] "key_buff1" "16384"
 $ : chr [1:2] "key_buff1" "16384"
 $ : chr [1:2] "key_buff1" "16384"
 $ : chr [1:2] "key_buff1" "15104"
 $ : chr [1:2] "key_buff1" "15104"
 $ : chr [1:2] "key_buff1" "19200"
 $ : chr [1:2] "key_buff1" "19200"
 $ : chr [1:2] "key_buff1" "19200"
 $ : chr [1:2] "key_buff1" "19200"
 $ : chr [1:2] "key_buff1" "19200"
 $ : chr [1:2] "key_buff1" "19200"
 $ : chr [1:2] "key_buff1" "19200"
  [list output truncated]
   user  system elapsed 
  0.552   0.000   0.550
   user  system elapsed 
  0.660   0.000   0.661 
Warning message:
In system.time(n$Offset <- as.integer(unlist(lapply(vect, "[[",  :
  NAs introduced by coercion
'data.frame':	1150520 obs. of  11 variables:
 $ Address  :Class 'bigz'  raw [1:13806244] 38 8e 11 00 ...
 $ Reads    : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Start    : int  279630 310398 452318 485572 511748 511748 521080 522640 522640 538401 ...
 $ End      : int  283344 410993 485570 511748 521080 521080 522640 538401 538401 578774 ...
 $ Tid      : int  7 6 6 6 6 0 0 0 6 6 ...
 $ N        : int  1 1 1 1 2 2 1 2 2 1 ...
 $ Duration : int  3714 100595 33252 26176 9332 9332 1560 15761 15761 40373 ...
 $ Type     : chr  "Private_Write" "Private_Write" "Private_Write" "Private_Write" ...
 $ Structure: chr  "key_buff1" "key_buff1" "key_buff1" "key_buff1" ...
 $ Offset   : int  2816 2816 2816 2816 2816 2816 2816 2816 2816 2816 ...
   Address Reads Writes  Start    End Tid N Duration          Type Structure
80 6307840     1      1 279630 283344   7 1     3714 Private_Write key_buff1
81 6307840     1      1 310398 410993   6 1   100595 Private_Write key_buff1
82 6307840     1      1 452318 485570   6 1    33252 Private_Write key_buff1
83 6307840     1      1 485572 511748   6 1    26176 Private_Write key_buff1
84 6307840     1      1 511748 521080   6 2     9332  Shared_Write key_buff1
85 6307840     1      1 511748 521080   0 2     9332  Shared_Write key_buff1
   Offset
80   2816
81   2816
82   2816
83   2816
84   2816
85   2816
[1] 1150520
#+end_example

Ok fast enough for me, I guess this is it, let's aggregate and do the plots:

#+begin_src R :results output :session :exports both
system.time(o <- aggregate(n[,c('Reads','Writes', 'N')],n[,c('Structure','Offset', 'Type', 'Start', 'End')], function(d) sum(d)));
str(o)
head(o)
#+end_src

#+RESULTS:
#+begin_example
   user  system elapsed 
 64.948   0.132  65.145
'data.frame':	1078075 obs. of  8 variables:
 $ Structure: chr  "key_array" "key_array" "key_array" "key_buff1" ...
 $ Offset   : int  83884800 2816 6912 981472 1014168 1019864 1025192 1027256 1034226 1035544 ...
 $ Type     : chr  "Private_Write" "Private_Write" "Private_Write" "Private_Write" ...
 $ Start    : int  157 1 1 1 1 1 1 1 1 1 ...
 $ End      : int  158 171 171 171 171 171 171 171 171 171 ...
 $ Reads    : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ N        : int  1 1 1 1 1 1 1 1 1 1 ...
  Structure   Offset          Type Start End Reads Writes N
1 key_array 83884800 Private_Write   157 158     1      1 1
2 key_array     2816 Private_Write     1 171     1      1 1
3 key_array     6912 Private_Write     1 171     1      1 1
4 key_buff1   981472 Private_Write     1 171     1      1 1
5 key_buff1  1014168 Private_Write     1 171     1      1 1
6 key_buff1  1019864 Private_Write     1 171     1      1 1
#+end_example

This step is a bit slow, but I dont now how to make it go faster, so
for now let keep it this way.

So now we should be able to redo the plots from [[*2016-03-03%20Redo%20analysis%20from%20%5B%5B*IS%5D%5BIS%5D%5D%20with%20addresses%20fixed][last thursday]] 

#+begin_src R :results output graphics :file img/intensity_Rw_is_B_fixy_replay.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(o) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Offset,yend=Offset, color=Reads+Writes)) +
  facet_grid(Structure~Type, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_Rw_is_B_fixy_replay.png]]


this is the same as:

[[file:img/intensity_Rw_is_B_fixy.png][file:~/Work/labbook-lucas/img/intensity_Rw_is_B_fixy.png]]


So our improvements work, there is the whole post processing phase as
one block:


#+begin_src R :results output :session :exports both
ptm <- proc.time()
library(gmp)


system.time(k <- read.csv("Moca-is.B-orig-2016-03-01_14-03-40/Moca-framesoc.csv", header=T));
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

# Use bigz to parse
k$Address <- as.bigz(paste("0x", k$Address, sep=""))
k$Phy <- NULL;
k$CPU <- NULL;
k$Duration <- k$End - k$Start
head(k);
str(k)

# Add structure info
structs <- read.csv("Moca-is.B-orig-2016-03-01_14-03-40/is.B-orig.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressStart <- as.bigz(structs$AddressStart)
structs$AddressSize <- as.bigz(structs$AddressSize)
structs$AddressEnd <- structs$AddressStart + structs$AddressSize


# Filter interesting data structure as soon as possible
# The following line is specific to IS.B, adapt it for other analysis
structs <- structs[grepl("key_",structs$Structure),]
str(structs)
show(structs)

# Retrieve struct infos
nrow(k)
# These lines are specific to IS.B, adapt it for other analysis
minA <- structs[1,2]
maxA <- structs[3,4]
system.time(l <- subset(k, k$Address >= minA & k$Address <= maxA));
head(l)
str(l)

# Compute accesses type

m <- l
system.time(m$aType <- ifelse(m$Write >0,"Write", "Read"));
system.time(m$sType <- ifelse(m$N > 1,"Shared","Private"));
system.time(m$Type <- paste(m$sType,m$aType,sep="_"));
m$sType <- NULL
m$aType <- NULL
head(m)

# Compute data structure name and offset
n <- m
show(structs)
getStructReverse <- function (vect){
  name <- 1
  start <- 2
  end <- 4
  return (ifelse(n$Address >= vect[start] & n$Address <= vect[end],
                paste(vect[name],as.bigz(n$Address) - as.bigz(vect[start]),sep="@"),""));
}
system.time(ans <- as.data.frame(apply(structs,1,getStructReverse)))
system.time(vect <- apply(ans,1,paste,collapse=""));
#str(vect)
system.time(vect <- strsplit(vect,"@"))
#str(vect)
system.time(n$Structure <- unlist(lapply(vect,"[[",1)))
system.time(n$Offset <- as.integer(unlist(lapply(vect,"[[",2))));
#str(n)
head(n)
nrow(n)

# Aggregate
system.time(o <- aggregate(n[,c('Reads','Writes', 'N')],n[,c('Structure','Offset', 'Type', 'Start', 'End')], function(d) sum(d)));
str(o)
head(o)

proc.time() - ptm
#+end_src

#+RESULTS:
#+begin_example
   user  system elapsed 
  6.212   0.044   6.283
            X.Virt            X.Phy Nreads Nwrites CPUMask  Start    End TaskId
1 0000000000400040 000062000b1dfa80      1       0    1011      1    171      0
2 00000000004002a8 000062000b1dfa80      1       0    1011  32663  34153      0
3 0000000000400bd4 000062000b1dfa80      1       0    1011  55271  72678      0
4 00000000004009a0 000062000b1dfa80      1       0      11  88569  88776      1
5 00000000004009a0 000062000b1dfa80      1       0     111  92562 103554      7
6 00000000004009a0 000062000b1dfa80      1       0   10011 238634 245102      2
  Shared
1      1
2      1
3      1
4      1
5      1
6      1
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
  Address Reads Writes  Start    End Tid N Duration
1 4194368     1      0      1    171   0 1      170
2 4194984     1      0  32663  34153   0 1     1490
3 4197332     1      0  55271  72678   0 1    17407
4 4196768     1      0  88569  88776   1 1      207
5 4196768     1      0  92562 103554   7 1    10992
6 4196768     1      0 238634 245102   2 1     6468
'data.frame':	1157330 obs. of  8 variables:
 $ Address :Class 'bigz'  raw [1:13892924] d2 a8 11 00 ...
 $ Reads   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes  : int  0 0 0 0 0 0 0 0 0 0 ...
 $ Start   : int  1 32663 55271 88569 92562 238634 254421 258859 258859 286485 ...
 $ End     : int  171 34153 72678 88776 103554 245102 258859 286485 286485 310331 ...
 $ Tid     : int  0 0 0 1 7 2 4 4 6 6 ...
 $ N       : int  1 1 1 1 1 1 1 2 2 1 ...
 $ Duration: int  170 1490 17407 207 10992 6468 4438 27626 27626 23846 ...
'data.frame':	3 obs. of  4 variables:
 $ Structure   : Factor w/ 14 levels "__GI___pthread_keys",..: 3 2 4
 $ AddressStart:Class 'bigz'  raw [1:40] 03 00 00 00 ...
 $ AddressSize :Class 'bigz'  raw [1:40] 03 00 00 00 ...
 $ AddressEnd  :Class 'bigz'  raw [1:40] 03 00 00 00 ...
  Structure AddressStart AddressSize AddressEnd
3 key_buff1      6305024     8388608   14693632
4 key_array     14693632   134217728  148911360
5 key_buff2    148911360   134217728  283129088
[1] 1157330
   user  system elapsed 
  2.644   0.000   2.642
   Address Reads Writes  Start    End Tid N Duration
80 6307840     1      1 279630 283344   7 1     3714
81 6307840     1      1 310398 410993   6 1   100595
82 6307840     1      1 452318 485570   6 1    33252
83 6307840     1      1 485572 511748   6 1    26176
84 6307840     1      1 511748 521080   6 2     9332
85 6307840     1      1 511748 521080   0 2     9332
'data.frame':	1150520 obs. of  8 variables:
 $ Address :Class 'bigz'  raw [1:13806244] 38 8e 11 00 ...
 $ Reads   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes  : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Start   : int  279630 310398 452318 485572 511748 511748 521080 522640 522640 538401 ...
 $ End     : int  283344 410993 485570 511748 521080 521080 522640 538401 538401 578774 ...
 $ Tid     : int  7 6 6 6 6 0 0 0 6 6 ...
 $ N       : int  1 1 1 1 2 2 1 2 2 1 ...
 $ Duration: int  3714 100595 33252 26176 9332 9332 1560 15761 15761 40373 ...
   user  system elapsed 
  0.364   0.004   0.368
   user  system elapsed 
  0.364   0.000   0.367
   user  system elapsed 
   0.24    0.00    0.24
   Address Reads Writes  Start    End Tid N Duration          Type
80 6307840     1      1 279630 283344   7 1     3714 Private_Write
81 6307840     1      1 310398 410993   6 1   100595 Private_Write
82 6307840     1      1 452318 485570   6 1    33252 Private_Write
83 6307840     1      1 485572 511748   6 1    26176 Private_Write
84 6307840     1      1 511748 521080   6 2     9332  Shared_Write
85 6307840     1      1 511748 521080   0 2     9332  Shared_Write
  Structure AddressStart AddressSize AddressEnd
3 key_buff1      6305024     8388608   14693632
4 key_array     14693632   134217728  148911360
5 key_buff2    148911360   134217728  283129088
   user  system elapsed 
 11.496   0.024  11.528
   user  system elapsed 
  5.236   0.040   5.277
   user  system elapsed 
  1.924   0.004   1.930
   user  system elapsed 
  0.512   0.000   0.513
   user  system elapsed 
  0.656   0.000   0.656 
Warning message:
In system.time(n$Offset <- as.integer(unlist(lapply(vect, "[[",  :
  NAs introduced by coercion
   Address Reads Writes  Start    End Tid N Duration          Type Structure
80 6307840     1      1 279630 283344   7 1     3714 Private_Write key_buff1
81 6307840     1      1 310398 410993   6 1   100595 Private_Write key_buff1
82 6307840     1      1 452318 485570   6 1    33252 Private_Write key_buff1
83 6307840     1      1 485572 511748   6 1    26176 Private_Write key_buff1
84 6307840     1      1 511748 521080   6 2     9332  Shared_Write key_buff1
85 6307840     1      1 511748 521080   0 2     9332  Shared_Write key_buff1
   Offset
80   2816
81   2816
82   2816
83   2816
84   2816
85   2816
[1] 1150520
   user  system elapsed 
 63.424   0.156  63.705
'data.frame':	1078075 obs. of  8 variables:
 $ Structure: chr  "key_array" "key_array" "key_array" "key_buff1" ...
 $ Offset   : int  83884800 2816 6912 981472 1014168 1019864 1025192 1027256 1034226 1035544 ...
 $ Type     : chr  "Private_Write" "Private_Write" "Private_Write" "Private_Write" ...
 $ Start    : int  157 1 1 1 1 1 1 1 1 1 ...
 $ End      : int  158 171 171 171 171 171 171 171 171 171 ...
 $ Reads    : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ N        : int  1 1 1 1 1 1 1 1 1 1 ...
  Structure   Offset          Type Start End Reads Writes N
1 key_array 83884800 Private_Write   157 158     1      1 1
2 key_array     2816 Private_Write     1 171     1      1 1
3 key_array     6912 Private_Write     1 171     1      1 1
4 key_buff1   981472 Private_Write     1 171     1      1 1
5 key_buff1  1014168 Private_Write     1 171     1      1 1
6 key_buff1  1019864 Private_Write     1 171     1      1 1
   user  system elapsed 
100.220   0.296 107.203
#+end_example

So the whole process is almost 3 times faster than the slowest step of
the previous version. I think we can still improve it but I don't know
how ... Also a process that takes less than 2 minutes is reasably slow
from my point of view.
* 2016-03-08 Continue analysis with last version of scripts           :David:

While we were working on IS traces, we fixed several things in the
visu and in the scripts.

I'd like to redo the plots of the two matrix multiplications, see if
they changed:

Let's start with the matrix modulo from [[*Continue previous analysis][here]] 

First redo the post-processing


#+begin_src sh :results output :exports both :session
cd Moca-matrix-modulo-2016-02-29_11-14-03
~/Work/Moca/src/utils/create_event_producer.sh 4096 Moca-full-trace.csv
head Moca-framesoc.csv
awk -F , 'BEGIN{p="";cpt=1} {if(p==$1){n=$1"-"cpt;cpt++}\
else{cpt=1;n=$1};p=$1;print n","$2","$3}' \
matrix.structs.csv > matrix-modulo.structs-uniq.csv
cat  matrix-modulo.structs-uniq.csv
#+end_src

#+RESULTS:
#+begin_example
Generating producer files
Generating framesoc trace file
Generating Virtual producers file
Generating Physical producers file
Physical-producers.log Done
Virtual-producers.log Done
Reading from Moca-full-trace.csv
102894 accesses on 6000 pages parsed from Moca-full-trace.csv
done in 00 h 00 min 12.542 sec
@Virt,@Phy,Nreads,Nwrites,CPUMask,Start,End,TaskId,Shared
0000000000400040,00006200028a0630,1,0,000010110,1,3492,0,1
0000000000400a18,00006200028a0630,1,0,000010110,5923,7920,0,1
0000000000400c20,00006200028a0630,1,0,000100110,7927,24611,2,1
0000000000400270,0000000000400270,1,0,010000110,94264,94505,2,1
0000000000400270,0000000000400270,1,0,010000110,94505,108267,2,2
0000000000400270,0000000000400270,1,0,001000110,94505,108267,3,2
0000000000400270,0000000000400270,1,0,001000110,108267,108267,3,1
0000000000405435,0000000000405435,1,0,010000110,1,3492,0,1
000000000041d800,000000000041d800,1,0,010000110,1,3492,0,1
-1,,
__GI___pthread_keys,2196192,16384
__pthread_keys,2196192,16384
UnnamedStruct#0,6303760,5280
UnnamedStruct#1,6303888,32816
UnnamedStruct#2,6303888,32816
/home/david/Work/Bench/matrix/matrix_naif.c:140,140737313341456,8000000
/home/david/Work/Bench/matrix/matrix_naif.c:123,140737321345040,8000000
/home/david/Work/Bench/matrix/matrix_naif.c:122,140737329348624,8000000
#+end_example

Looks good, we can continue:

#+begin_src R :results output :session :exports both
ptm <- proc.time()
library(gmp)


system.time(k <- read.csv("Moca-matrix-modulo-2016-02-29_11-14-03/Moca-framesoc.csv", header=T));
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

# Use bigz to parse
k$Address <- as.bigz(paste("0x", k$Address, sep=""))
k$Phy <- NULL;
k$CPU <- NULL;
k$Duration <- k$End - k$Start
head(k);
str(k)

# Add structure info
structs <- read.csv("Moca-matrix-modulo-2016-02-29_11-14-03/matrix-modulo.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressStart <- as.bigz(structs$AddressStart)
structs$AddressSize <- as.bigz(structs$AddressSize)
structs$AddressEnd <- structs$AddressStart + structs$AddressSize
show(structs)
# Filter interesting data structure as soon as possible
# The following line is specific to matrix, adapt it for other analysis
structs <- structs[grepl("matrix",structs$Structure),]
str(structs)
show(structs)

# Retrieve struct infos
nrow(k)
# These lines are specific to matrix, adapt it for other analysis
minA <- structs[1,2]
maxA <- structs[3,4]
system.time(l <- subset(k, k$Address >= minA & k$Address <= maxA));
head(l)
str(l)

proc.time() - ptm
#+end_src

#+RESULTS:
#+begin_example

Attaching package: ‘gmp’

The following objects are masked from ‘package:base’:

    %*%, apply, crossprod, matrix, tcrossprod
   user  system elapsed 
  6.248   0.112   6.365
            X.Virt            X.Phy Nreads Nwrites  CPUMask Start    End TaskId
1 0000000000400040 00006200028a0630      1       0    10110     1   3492      0
2 0000000000400a18 00006200028a0630      1       0    10110  5923   7920      0
3 0000000000400c20 00006200028a0630      1       0   100110  7927  24611      2
4 0000000000400270 0000000000400270      1       0 10000110 94264  94505      2
5 0000000000400270 0000000000400270      1       0 10000110 94505 108267      2
6 0000000000400270 0000000000400270      1       0  1000110 94505 108267      3
  Shared
1      1
2      1
3      1
4      1
5      2
6      2
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
  Address Reads Writes Start    End Tid N Duration
1 4194368     1      0     1   3492   0 1     3491
2 4196888     1      0  5923   7920   0 1     1997
3 4197408     1      0  7927  24611   2 1    16684
4 4194928     1      0 94264  94505   2 1      241
5 4194928     1      0 94505 108267   2 2    13762
6 4194928     1      0 94505 108267   3 2    13762
'data.frame':	1459247 obs. of  8 variables:
 $ Address :Class 'bigz'  raw [1:23347716] 2f 44 16 00 ...
 $ Reads   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes  : int  0 0 0 0 0 0 0 0 0 0 ...
 $ Start   : int  1 5923 7927 94264 94505 94505 108267 1 1 1 ...
 $ End     : int  3492 7920 24611 94505 108267 108267 108267 3492 3492 3492 ...
 $ Tid     : int  0 0 2 2 2 3 3 0 0 0 ...
 $ N       : int  1 1 1 1 2 2 1 1 1 1 ...
 $ Duration: int  3491 1997 16684 241 13762 13762 0 3491 3491 3491 ...
                                        Structure    AddressStart AddressSize
1                             __GI___pthread_keys         2196192       16384
2                                  __pthread_keys         2196192       16384
3                                 UnnamedStruct#0         6303760        5280
4                                 UnnamedStruct#1         6303888       32816
5                                 UnnamedStruct#2         6303888       32816
6 /home/david/Work/Bench/matrix/matrix_naif.c:140 140737313341456     8000000
7 /home/david/Work/Bench/matrix/matrix_naif.c:123 140737321345040     8000000
8 /home/david/Work/Bench/matrix/matrix_naif.c:122 140737329348624     8000000
       AddressEnd
1         2212576
2         2212576
3         6309040
4         6336704
5         6336704
6 140737321341456
7 140737329345040
8 140737337348624
'data.frame':	3 obs. of  4 variables:
 $ Structure   : Factor w/ 8 levels "__GI___pthread_keys",..: 4 3 2
 $ AddressStart:Class 'bigz'  raw [1:52] 03 00 00 00 ...
 $ AddressSize :Class 'bigz'  raw [1:40] 03 00 00 00 ...
 $ AddressEnd  :Class 'bigz'  raw [1:52] 03 00 00 00 ...
                                        Structure    AddressStart AddressSize
6 /home/david/Work/Bench/matrix/matrix_naif.c:140 140737313341456     8000000
7 /home/david/Work/Bench/matrix/matrix_naif.c:123 140737321345040     8000000
8 /home/david/Work/Bench/matrix/matrix_naif.c:122 140737329348624     8000000
       AddressEnd
6 140737321341456
7 140737329345040
8 140737337348624
[1] 1459247
   user  system elapsed 
  5.520   0.128   5.653
            Address Reads Writes Start   End Tid N Duration
195 140737313341456     1      1  5923  7920   0 1     1997
196 140737313341464     1      0  7927 24611   2 1    16684
197 140737313345536     1      1     1  3492   0 1     3491
198 140737313345536     1      1  5923  7920   0 1     1997
199 140737313345560     1      0  7927  7998   2 1       71
200 140737313345560     1      0  7998 10000   2 2     2002
'data.frame':	1458807 obs. of  8 variables:
 $ Address :Class 'bigz'  raw [1:23340916] 77 42 16 00 ...
 $ Reads   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes  : int  1 0 1 1 0 0 0 0 0 0 ...
 $ Start   : int  5923 7927 1 5923 7927 7998 7998 10000 10000 10000 ...
 $ End     : int  7920 24611 3492 7920 7998 10000 10000 10090 10090 10090 ...
 $ Tid     : int  0 2 0 0 2 2 3 2 3 4 ...
 $ N       : int  1 1 1 1 1 2 2 3 3 3 ...
 $ Duration: int  1997 16684 3491 1997 71 2002 2002 90 90 90 ...
   user  system elapsed 
 15.076   0.488  17.161
#+end_example

So far so good let's finish parsing:

#+begin_src R :results output :session :exports both
ptm <- proc.time()

# Compute accesses type

m <- l
system.time(m$aType <- ifelse(m$Write >0,"Write", "Read"));
system.time(m$sType <- ifelse(m$N > 1,"Shared","Private"));
system.time(m$Type <- paste(m$sType,m$aType,sep="_"));
m$sType <- NULL
m$aType <- NULL
head(m)

# Compute data structure name and offset
n <- m
show(structs)
getStructReverse <- function (vect){
  name <- 1
  start <- 2
  end <- 4
  return (ifelse(n$Address >= vect[start] & n$Address <= vect[end],
                paste(vect[name],as.bigz(n$Address) - as.bigz(vect[start]),sep="@"),""));
}
system.time(ans <- as.data.frame(apply(structs,1,getStructReverse)))
system.time(vect <- apply(ans,1,paste,collapse=""));
#str(vect)
system.time(vect <- strsplit(vect,"@"))
#str(vect)
system.time(n$Structure <- unlist(lapply(vect,"[[",1)))
system.time(n$Offset <- as.integer(unlist(lapply(vect,"[[",2))));
#str(n)
head(n)
nrow(n)

# Aggregate
system.time(o <- aggregate(n[,c('Reads','Writes', 'N')],n[,c('Structure','Offset', 'Type', 'Start', 'End')], function(d) sum(d)));
str(o)
head(o)

proc.time() - ptm
#+end_src

#+RESULTS:
#+begin_example
   user  system elapsed 
  0.528   0.016   0.544
   user  system elapsed 
  0.504   0.024   0.526
   user  system elapsed 
  0.360   0.000   0.358
            Address Reads Writes Start   End Tid N Duration          Type
195 140737313341456     1      1  5923  7920   0 1     1997 Private_Write
196 140737313341464     1      0  7927 24611   2 1    16684  Private_Read
197 140737313345536     1      1     1  3492   0 1     3491 Private_Write
198 140737313345536     1      1  5923  7920   0 1     1997 Private_Write
199 140737313345560     1      0  7927  7998   2 1       71  Private_Read
200 140737313345560     1      0  7998 10000   2 2     2002   Shared_Read
                                        Structure    AddressStart AddressSize
6 /home/david/Work/Bench/matrix/matrix_naif.c:140 140737313341456     8000000
7 /home/david/Work/Bench/matrix/matrix_naif.c:123 140737321345040     8000000
8 /home/david/Work/Bench/matrix/matrix_naif.c:122 140737329348624     8000000
       AddressEnd
6 140737321341456
7 140737329345040
8 140737337348624
   user  system elapsed 
  13.99    0.38   14.38
   user  system elapsed 
  8.900   0.020   8.932
   user  system elapsed 
  6.292   0.016   6.310
Error in FUN(X[[i]], ...) : subscript out of bounds
Timing stopped at: 0.012 0 0.013
Error in FUN(X[[i]], ...) : subscript out of bounds
Timing stopped at: 0.008 0 0.008
            Address Reads Writes Start   End Tid N Duration          Type
195 140737313341456     1      1  5923  7920   0 1     1997 Private_Write
196 140737313341464     1      0  7927 24611   2 1    16684  Private_Read
197 140737313345536     1      1     1  3492   0 1     3491 Private_Write
198 140737313345536     1      1  5923  7920   0 1     1997 Private_Write
199 140737313345560     1      0  7927  7998   2 1       71  Private_Read
200 140737313345560     1      0  7998 10000   2 2     2002   Shared_Read
[1] 1458807
Error in `[.data.frame`(n, , c("Structure", "Offset", "Type", "Start",  : 
  undefined columns selected
Timing stopped at: 0.004 0 0.001
Error in str(o) : object 'o' not found
Error in head(o) : object 'o' not found
   user  system elapsed 
  32.33    0.54   35.49
#+end_example

Hum this was buggy, it seems that everything went well until the
strsplit call

#+begin_src R :results output :session :exports both
# Compute accesses type
str(vect)
lapply(vect,"[[",1)
#+end_src

#+RESULTS:
#+begin_example
List of 1458807
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "0"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "8"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "4080"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "4080"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "4104"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "4104"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "4080"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "4104"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "4080"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "4088"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "4104"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "4080"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "4088"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "4096"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "4104"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "4080"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "4088"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "4104"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "4080"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "4080"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "8176"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "8176"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "8200"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "8200"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "8176"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "8200"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "8176"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "8184"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "8200"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "8176"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "8184"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "8192"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "8200"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "8176"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "8184"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "8200"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "8176"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "8176"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "12272"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "12272"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "12296"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "12296"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "12272"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "12296"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "12272"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "12280"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "12296"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "12272"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "12280"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "12288"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "12296"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "12272"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "12280"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "12296"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "12272"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "12272"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "16368"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "16368"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "16392"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "16392"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "16368"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "16392"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "16368"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "16376"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "16392"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "16368"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "16376"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "16384"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "16392"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "16368"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "16376"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "16392"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "16368"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "16368"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "20464"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "20464"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "20488"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "20488"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "20464"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "20464"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "24560"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "24560"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "24560"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "28656"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "28656"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "28656"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "32752"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "32752"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "32752"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "36848"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "36848"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "36848"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "40944"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "40944"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "40944"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "45040"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "45040"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "45040"
 $ : chr [1:2] "/home/david/Work/Bench/matrix/matrix_naif.c:140" "49136"
  [list output truncated]
Error in FUN(X[[i]], ...) : subscript out of bounds
#+end_example



So It seems that the lapply doesn't work here ...
Let see how can we manipulate this weird list:

#+begin_src R :results output :session :exports both
# Compute accesses type
head(lapply(vect,"[",1));
#+end_src

#+RESULTS:
#+begin_example
[[1]]
[1] "/home/david/Work/Bench/matrix/matrix_naif.c:140"

[[2]]
[1] "/home/david/Work/Bench/matrix/matrix_naif.c:140"

[[3]]
[1] "/home/david/Work/Bench/matrix/matrix_naif.c:140"

[[4]]
[1] "/home/david/Work/Bench/matrix/matrix_naif.c:140"

[[5]]
[1] "/home/david/Work/Bench/matrix/matrix_naif.c:140"

[[6]]
[1] "/home/david/Work/Bench/matrix/matrix_naif.c:140"
#+end_example

Ok this looks like magic, but it works, let's finish the analysis this way


#+begin_src R :results output :session :exports both
ptm <- proc.time()

# Compute accesses type

m <- l
system.time(m$aType <- ifelse(m$Write >0,"Write", "Read"));
system.time(m$sType <- ifelse(m$N > 1,"Shared","Private"));
system.time(m$Type <- paste(m$sType,m$aType,sep="_"));
m$sType <- NULL
m$aType <- NULL
head(m)

# Compute data structure name and offset
n <- m
show(structs)
getStructReverse <- function (vect){
  name <- 1
  start <- 2
  end <- 4
  return (ifelse(n$Address >= vect[start] & n$Address <= vect[end],
                paste(vect[name],as.bigz(n$Address) - as.bigz(vect[start]),sep="@"),""));
}
system.time(ans <- as.data.frame(apply(structs,1,getStructReverse)))
system.time(vect <- apply(ans,1,paste,collapse=""));
#str(vect)
system.time(vect <- strsplit(vect,"@"))
#str(vect)
system.time(n$Structure <- unlist(lapply(vect,"[",1)))
system.time(n$Offset <- as.integer(unlist(lapply(vect,"[",2))));
#str(n)
head(n)
nrow(n)

# Aggregate
system.time(o <- aggregate(n[,c('Reads','Writes', 'N')],n[,c('Structure','Offset', 'Type', 'Start', 'End')], function(d) sum(d)));
str(o)
head(o)

proc.time() - ptm
#+end_src

#+RESULTS:
#+begin_example
   user  system elapsed 
  0.444   0.020   0.464
   user  system elapsed 
  0.464   0.004   0.468
   user  system elapsed 
  0.308   0.000   0.309
            Address Reads Writes Start   End Tid N Duration          Type
195 140737313341456     1      1  5923  7920   0 1     1997 Private_Write
196 140737313341464     1      0  7927 24611   2 1    16684  Private_Read
197 140737313345536     1      1     1  3492   0 1     3491 Private_Write
198 140737313345536     1      1  5923  7920   0 1     1997 Private_Write
199 140737313345560     1      0  7927  7998   2 1       71  Private_Read
200 140737313345560     1      0  7998 10000   2 2     2002   Shared_Read
                                        Structure    AddressStart AddressSize
6 /home/david/Work/Bench/matrix/matrix_naif.c:140 140737313341456     8000000
7 /home/david/Work/Bench/matrix/matrix_naif.c:123 140737321345040     8000000
8 /home/david/Work/Bench/matrix/matrix_naif.c:122 140737329348624     8000000
       AddressEnd
6 140737321341456
7 140737329345040
8 140737337348624
   user  system elapsed 
  14.03    0.20   14.24
   user  system elapsed 
  8.120   0.036   8.160
   user  system elapsed 
  6.248   0.000   6.252
   user  system elapsed 
  1.156   0.000   1.157
   user  system elapsed 
  0.868   0.000   0.867
            Address Reads Writes Start   End Tid N Duration          Type
195 140737313341456     1      1  5923  7920   0 1     1997 Private_Write
196 140737313341464     1      0  7927 24611   2 1    16684  Private_Read
197 140737313345536     1      1     1  3492   0 1     3491 Private_Write
198 140737313345536     1      1  5923  7920   0 1     1997 Private_Write
199 140737313345560     1      0  7927  7998   2 1       71  Private_Read
200 140737313345560     1      0  7998 10000   2 2     2002   Shared_Read
                                          Structure Offset
195 /home/david/Work/Bench/matrix/matrix_naif.c:140      0
196 /home/david/Work/Bench/matrix/matrix_naif.c:140      8
197 /home/david/Work/Bench/matrix/matrix_naif.c:140   4080
198 /home/david/Work/Bench/matrix/matrix_naif.c:140   4080
199 /home/david/Work/Bench/matrix/matrix_naif.c:140   4104
200 /home/david/Work/Bench/matrix/matrix_naif.c:140   4104
[1] 1458807
   user  system elapsed 
  67.82    0.20   68.06
'data.frame':	1216302 obs. of  8 variables:
 $ Structure: chr  "/home/david/Work/Bench/matrix/matrix_naif.c:122" "/home/david/Work/Bench/matrix/matrix_naif.c:123" "/home/david/Work/Bench/matrix/matrix_naif.c:140" "/home/david/Work/Bench/matrix/matrix_naif.c:122" ...
 $ Offset   : int  4080 4080 4080 8176 8176 8176 12272 12272 12272 16368 ...
 $ Type     : chr  "Private_Write" "Private_Write" "Private_Write" "Private_Write" ...
 $ Start    : int  1 1 1 1 1 1 1 1 1 1 ...
 $ End      : int  3492 3492 3492 3492 3492 3492 3492 3492 3492 3492 ...
 $ Reads    : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ N        : int  1 1 1 1 1 1 1 1 1 1 ...
                                        Structure Offset          Type Start
1 /home/david/Work/Bench/matrix/matrix_naif.c:122   4080 Private_Write     1
2 /home/david/Work/Bench/matrix/matrix_naif.c:123   4080 Private_Write     1
3 /home/david/Work/Bench/matrix/matrix_naif.c:140   4080 Private_Write     1
4 /home/david/Work/Bench/matrix/matrix_naif.c:122   8176 Private_Write     1
5 /home/david/Work/Bench/matrix/matrix_naif.c:123   8176 Private_Write     1
6 /home/david/Work/Bench/matrix/matrix_naif.c:140   8176 Private_Write     1
   End Reads Writes N
1 3492     1      1 1
2 3492     1      1 1
3 3492     1      1 1
4 3492     1      1 1
5 3492     1      1 1
6 3492     1      1 1
   user  system elapsed 
102.116   0.528 106.911
#+end_example


Here we go

#+begin_src R :results output graphics :file img/intensity_Rw_mat_modulo_replay.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(o) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Offset,yend=Offset, color=Reads+Writes)) +
  facet_grid(Structure~Type, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_Rw_mat_modulo_replay.png]]


#+begin_src R :results output graphics :file img/intensity_threads_mat_modulo_replay.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(o) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Offset,yend=Offset, color=N)) +
  facet_grid(Structure~Type, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

Same thing in terms of number of threads:

#+RESULTS:
[[file:img/intensity_threads_mat_modulo_replay.png]]


Woa N  goes up to 40, this is wrong! N should be the number of thread,
I think the aggregate step is buggy let add the tid inside it:


#+begin_src R :results output graphics :file img/intensity_threads_mat_modulo_replay_fix.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(n) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Offset,yend=Offset, color=as.factor(N))) +
  facet_grid(Structure~Type)
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_threads_mat_modulo_replay_fix.png]]


This looks better, I think we shouldn't work on the aggregated version
for this plot.

I don't know why there is a NA line here but it seems empty so I guess
it's not a big deal for now.
This plot is very similar to what we had with the buggy y:

[[file:img/intensity_modulo_threads.png][file:~/Work/labbook-lucas/img/intensity_modulo_threads.png]]

So I guess we can stop here for the matrix.

The next step is to trace some other / unknown applications and visualize them.

**  BT Traces


There is yet another trace as usual the ariche is on ligcloud:
https://ligcloud.imag.fr/public.php?service=files&t=0c9e24f93a596051bfc0335da4028dfa

and here is the md5sum:

#+begin_src sh :results output :exports both :session
md5sum moca-bt.tgz
#+end_src

#+RESULTS:
: aa72bd181b8a6430388858fb6264fa08  moca-bt.tgz

#+begin_src sh :results output :exports both :session
cd Moca-bt.A-2016-02-26_16-30-03 
~/Work/Moca/src/utils/create_event_producer.sh 4096 Moca-full-trace.csv
head Moca-framesoc.csv
awk -F , 'BEGIN{p="";cpt=1} {if(p==$1){n=$1"-"cpt;cpt++}\
else{cpt=1;n=$1};p=$1;print n","$2","$3}' \
bt.A.structs.csv > bt.A.structs-uniq.csv
cat  bt.A.structs-uniq.csv
#+end_src

#+RESULTS:
#+begin_example
Generating producer files
Generating framesoc trace file
Generating Virtual producers file
Generating Physical producers file
Virtual-producers.log Done
Physical-producers.log Done
Reading from Moca-full-trace.csv
1565940 accesses on 11390 pages parsed from Moca-full-trace.csv
done in 00 h 00 min 48.340 sec
@Virt,@Phy,Nreads,Nwrites,CPUMask,Start,End,TaskId,Shared
0000000000400040,00006200158a8718,1,0,000001000,1,324,0,1
0000000000400040,00006200158a8718,1,0,000001000,324,328,0,2
0000000000400c60,00006200158a8718,1,0,000100000,324,328,4,2
0000000000400040,00006200158a8718,1,0,000001000,328,331,0,3
0000000000400c60,00006200158a8718,1,0,000100000,328,331,4,3
0000000000400739,00006200158a8718,1,0,000000011,328,331,7,3
0000000000400c60,00006200158a8718,1,0,000100000,331,19074,4,2
0000000000400739,00006200158a8718,1,0,000000011,331,19074,7,2
0000000000400c60,00006200158a8718,1,0,000100000,19074,22038,4,3
-1,,
__GI___pthread_keys,2196192,16384
__pthread_keys,2196192,16384
fields_,6367808,45427200
UnnamedStruct#0,51798032,5280
UnnamedStruct#1,51806224,32816
#+end_example

So 3 usefull data structures here let's do the parsing

#+begin_src R :results output :session :exports both
ptm <- proc.time()
library(gmp)


system.time(k <- read.csv("Moca-bt.A-2016-02-26_16-30-03/Moca-framesoc.csv", header=T));
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

# Use bigz to parse
k$Address <- as.bigz(paste("0x", k$Address, sep=""))
k$Phy <- NULL;
k$CPU <- NULL;
k$Duration <- k$End - k$Start
head(k);
str(k)

# Add structure info
structs <- read.csv("Moca-bt.A-2016-02-26_16-30-03/bt.A.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressStart <- as.bigz(structs$AddressStart)
structs$AddressSize <- as.bigz(structs$AddressSize)
structs$AddressEnd <- structs$AddressStart + structs$AddressSize
show(structs)
# Filter interesting data structure as soon as possible
# The following line is specific to matrix, adapt it for other analysis
structs <- structs[!grepl("thread",structs$Structure),]
#str(structs)
#show(structs)

# Retrieve struct infos
nrow(k)
# These lines are specific to matrix, adapt it for other analysis
minA <- structs[1,2]
maxA <- structs[3,4]
system.time(l <- subset(k, k$Address >= minA & k$Address <= maxA));
head(l)
str(l)

proc.time() - ptm
#+end_src


 Killed too slow during the subset step ...

#+begin_src R :results output :session :exports both
ptm <- proc.time()
library(gmp)


system.time(k <- read.csv("Moca-bt.A-2016-02-26_16-30-03/Moca-framesoc.csv", header=T));
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

# Use bigz to parse
k$Address <- as.bigz(paste("0x", k$Address, sep=""))
k$Phy <- NULL;
k$CPU <- NULL;
k$Duration <- k$End - k$Start
head(k);
str(k)

# Add structure info
structs <- read.csv("Moca-bt.A-2016-02-26_16-30-03/bt.A.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressStart <- as.bigz(structs$AddressStart)
structs$AddressSize <- as.bigz(structs$AddressSize)
structs$AddressEnd <- structs$AddressStart + structs$AddressSize
show(structs)
# Filter interesting data structure as soon as possible
# The following line is specific to matrix, adapt it for other analysis
structs <- structs[!grepl("thread",structs$Structure),]
#str(structs)
#show(structs)

# Retrieve struct infos
nrow(k)
# These lines are specific to matrix, adapt it for other analysis
minA <- structs[1,2]
maxA <- structs[3,4]
proc.time() - ptm
#+end_src

#+RESULTS:
#+begin_example

Attaching package: ‘gmp’

The following objects are masked from ‘package:base’:

    %*%, apply, crossprod, matrix, tcrossprod
   user  system elapsed 
  9.556   0.308   9.898
            X.Virt            X.Phy Nreads Nwrites CPUMask Start End TaskId
1 0000000000400040 00006200158a8718      1       0    1000     1 324      0
2 0000000000400040 00006200158a8718      1       0    1000   324 328      0
3 0000000000400c60 00006200158a8718      1       0  100000   324 328      4
4 0000000000400040 00006200158a8718      1       0    1000   328 331      0
5 0000000000400c60 00006200158a8718      1       0  100000   328 331      4
6 0000000000400739 00006200158a8718      1       0      11   328 331      7
  Shared
1      1
2      2
3      2
4      3
5      3
6      3
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
  Address Reads Writes Start End Tid N Duration
1 4194368     1      0     1 324   0 1      323
2 4194368     1      0   324 328   0 2        4
3 4197472     1      0   324 328   4 2        4
4 4194368     1      0   328 331   0 3        3
5 4197472     1      0   328 331   4 3        3
6 4196153     1      0   328 331   7 3        3
'data.frame':	2215106 obs. of  8 variables:
 $ Address :Class 'bigz'  raw [1:26687140] c2 cc 21 00 ...
 $ Reads   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes  : int  0 0 0 0 0 0 0 0 0 0 ...
 $ Start   : int  1 324 324 328 328 328 331 331 19074 19074 ...
 $ End     : int  324 328 328 331 331 331 19074 19074 22038 22038 ...
 $ Tid     : int  0 0 4 0 4 7 4 7 4 7 ...
 $ N       : int  1 2 2 3 3 3 2 2 3 3 ...
 $ Duration: int  323 4 4 3 3 3 18743 18743 2964 2964 ...
            Structure AddressStart AddressSize AddressEnd
1 __GI___pthread_keys      2196192       16384    2212576
2      __pthread_keys      2196192       16384    2212576
3             fields_      6367808    45427200   51795008
4     UnnamedStruct#0     51798032        5280   51803312
5     UnnamedStruct#1     51806224       32816   51839040
[1] 2215106
   user  system elapsed 
  13.30    0.48   16.20
#+end_example


Now lets try to do an efficient subset:



#+begin_src R :results output :session :exports both
minA <- structs[1,2]
maxA <- structs[3,4]
#system.time(l <- subset(k, k$Address >= minA & k$Address <= maxA));
system.time(l <- k[which(k$Address >= minA & k$Address <= maxA),]);
head(l)
str(l)
#+end_src

#+RESULTS:
#+begin_example
   user  system elapsed 
  2.400   0.120   2.523
      Address Reads Writes Start   End Tid N Duration
48788 6369280     1      1     1   331   0 1      330
48789 6369280     1      1   342 11591   0 1    11249
48790 6370456     1      0 11612 17469   0 1     5857
48791 6370472     1      0 18778 21849   0 1     3071
48792 6370696     1      0 21853 26963   0 1     5110
48793 6370472     1      0 28358 30081   0 1     1723
'data.frame':	2138288 obs. of  8 variables:
 $ Address :Class 'bigz'  raw [1:25659460] b0 a0 20 00 ...
 $ Reads   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes  : int  1 1 0 0 0 0 0 0 0 0 ...
 $ Start   : int  1 342 11612 18778 21853 28358 30082 39552 45883 49481 ...
 $ End     : int  331 11591 17469 21849 26963 30081 35997 44326 49479 54997 ...
 $ Tid     : int  0 0 0 0 0 0 0 0 0 0 ...
 $ N       : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Duration: int  330 11249 5857 3071 5110 1723 5915 4774 3596 5516 ...
#+end_example

Ok this was way more efficient than what I thought.

#+begin_src R :results output :session :exports both
ptm <- proc.time()

# Compute accesses type

m <- l
system.time(m$aType <- ifelse(m$Write >0,"Write", "Read"));
system.time(m$sType <- ifelse(m$N > 1,"Shared","Private"));
system.time(m$Type <- paste(m$sType,m$aType,sep="_"));
m$sType <- NULL
m$aType <- NULL
head(m)

# Compute data structure name and offset
n <- m
show(structs)
getStructReverse <- function (vect){
  name <- 1
  start <- 2
  end <- 4
  return (ifelse(n$Address >= vect[start] & n$Address <= vect[end],
                paste(vect[name],as.bigz(n$Address) - as.bigz(vect[start]),sep="@"),""));
}
system.time(ans <- as.data.frame(apply(structs,1,getStructReverse)))
system.time(vect <- apply(ans,1,paste,collapse=""));
#str(vect)
system.time(vect <- strsplit(vect,"@"))
#str(vect)
system.time(n$Structure <- unlist(lapply(vect,"[",1)))
system.time(n$Offset <- as.integer(unlist(lapply(vect,"[",2))));
#str(n)
head(n)
nrow(n)

# Aggregate
system.time(o <- aggregate(n[,c('Reads','Writes', 'N')],n[,c('Structure','Offset', 'Type', 'Start', 'End')], function(d) sum(d)));
str(o)
head(o)

proc.time() - ptm
#+end_src

#+RESULTS:
#+begin_example
   user  system elapsed 
  0.684   0.020   0.706
   user  system elapsed 
  0.692   0.000   0.693
   user  system elapsed 
  0.440   0.000   0.441
      Address Reads Writes Start   End Tid N Duration          Type
48788 6369280     1      1     1   331   0 1      330 Private_Write
48789 6369280     1      1   342 11591   0 1    11249 Private_Write
48790 6370456     1      0 11612 17469   0 1     5857  Private_Read
48791 6370472     1      0 18778 21849   0 1     3071  Private_Read
48792 6370696     1      0 21853 26963   0 1     5110  Private_Read
48793 6370472     1      0 28358 30081   0 1     1723  Private_Read
        Structure AddressStart AddressSize AddressEnd
3         fields_      6367808    45427200   51795008
4 UnnamedStruct#0     51798032        5280   51803312
5 UnnamedStruct#1     51806224       32816   51839040
   user  system elapsed 
  19.08    0.58   19.69
   user  system elapsed 
 11.208   0.056  11.284
   user  system elapsed 
  3.392   0.000   3.397
   user  system elapsed 
  1.236   0.008   1.246
   user  system elapsed 
  1.312   0.000   1.328
      Address Reads Writes Start   End Tid N Duration          Type Structure
48788 6369280     1      1     1   331   0 1      330 Private_Write   fields_
48789 6369280     1      1   342 11591   0 1    11249 Private_Write   fields_
48790 6370456     1      0 11612 17469   0 1     5857  Private_Read   fields_
48791 6370472     1      0 18778 21849   0 1     3071  Private_Read   fields_
48792 6370696     1      0 21853 26963   0 1     5110  Private_Read   fields_
48793 6370472     1      0 28358 30081   0 1     1723  Private_Read   fields_
      Offset
48788   1472
48789   1472
48790   2648
48791   2664
48792   2888
48793   2664
[1] 2138288
   user  system elapsed 
125.668   0.492 126.331
'data.frame':	2006909 obs. of  8 variables:
 $ Structure: chr  "fields_" "fields_" "fields_" "fields_" ...
 $ Offset   : int  951384 957080 962408 964472 971442 8114672 8117240 8119840 8123840 8127936 ...
 $ Type     : chr  "Private_Write" "Private_Write" "Private_Write" "Private_Write" ...
 $ Start    : int  1 1 1 1 1 320 320 320 320 320 ...
 $ End      : int  320 320 320 320 320 321 321 321 321 321 ...
 $ Reads    : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes   : int  1 1 1 1 1 0 0 0 0 0 ...
 $ N        : int  1 1 1 1 1 1 1 1 1 1 ...
  Structure  Offset          Type Start End Reads Writes N
1   fields_  951384 Private_Write     1 320     1      1 1
2   fields_  957080 Private_Write     1 320     1      1 1
3   fields_  962408 Private_Write     1 320     1      1 1
4   fields_  964472 Private_Write     1 320     1      1 1
5   fields_  971442 Private_Write     1 320     1      1 1
6   fields_ 8114672  Private_Read   320 321     1      0 1
   user  system elapsed 
167.168   1.332 174.633
#+end_example

#+begin_src R :results output graphics :file img/intensity_Rw_bt.A.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(o) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Offset,yend=Offset, color=Reads+Writes)) +
  facet_grid(Structure~Type, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_Rw_bt.A.png]]

From here I think We can focus on the fields datastructure, but first
let see the patterns in terms of thread sharing:

#+begin_src R :results output graphics :file img/intensity_Th_bt.A.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(n) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Offset,yend=Offset, color=as.factor(N))) +
  facet_grid(Structure~Type)
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_Th_bt.A.png]]

So there are two things noticable here:
 - fields seems to be shared always by 2 threads at a time which seems
   quite reasonnable
 - The UnamedStruct#1 is intensively shared in write mode by up to 8
   threads, it might be a bottleneck
  
Let's look at this data structure:

#+begin_src R :results output graphics :file img/intensity_Th_bt.A_zoom_un1.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(n[which(n$Structure=="UnnamedStruct#1"),]) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Offset,yend=Offset, color=as.factor(N))) +
  facet_grid(.~Type)
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_Th_bt.A_zoom_un1.png]]


The sharing seems to appear on a very small set of addresses and
happens during all the execution.

Is  it a huge number of accesses ?

#+begin_src R :results output :session :exports both
q <- n[which(n$Structure=="UnnamedStruct#1"),]
system.time(q <- aggregate(q[,c('Reads','Writes')],q[,c('Structure','Offset', 'Type')], function(d) sum(d)));
q$N <- q$Reads + q$Writes
str(q)
head(q)
#+end_src

#+RESULTS:
#+begin_example
   user  system elapsed 
  0.040   0.000   0.041
'data.frame':	34 obs. of  6 variables:
 $ Structure: chr  "UnnamedStruct#1" "UnnamedStruct#1" "UnnamedStruct#1" "UnnamedStruct#1" ...
 $ Offset   : int  1456 10496 20408 24344 24352 24484 25804 27252 31848 40 ...
 $ Type     : chr  "Private_Read" "Private_Read" "Private_Read" "Private_Read" ...
 $ Reads    : int  12 12 1 60 6 72 1 11 1 1 ...
 $ Writes   : int  0 0 0 0 0 0 0 0 0 1 ...
 $ N        : int  12 12 1 60 6 72 1 11 1 2 ...
        Structure Offset         Type Reads Writes  N
1 UnnamedStruct#1   1456 Private_Read    12      0 12
2 UnnamedStruct#1  10496 Private_Read    12      0 12
3 UnnamedStruct#1  20408 Private_Read     1      0  1
4 UnnamedStruct#1  24344 Private_Read    60      0 60
5 UnnamedStruct#1  24352 Private_Read     6      0  6
6 UnnamedStruct#1  24484 Private_Read    72      0 72
#+end_example

#+begin_src R :results output graphics :file img/num_acc_bt.A_zoom_un1.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(q, aes(x=Offset,y=N, color=Type)) +
  theme_bw() +
  geom_point() +
  theme_bw() +
  theme(legend.title=element_blank()) +
  scale_y_log10() +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/num_acc_bt.A_zoom_un1.png]]


 So it's between 100 and 10000 accesses for the most used addresses.
 
Before looking at bt source code, I'd like to zoom on fields:

#+begin_src R :results output graphics :file img/intensity_Rw_bt.A_zoom_fields.png :exports both :width 600 :height 400 :session
r <- o[which(o$Structure=="fields_"),]
library(ggplot2);
p <- ggplot(r) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Offset,yend=Offset, color=Reads+Writes)) +
  facet_grid(Structure~Type, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_Rw_bt.A_zoom_fields.png]]


We have an interesting pattern here: the whole data structure is
accessed in an unstructured way, yet most of the sharing (especially
the write sharing) happens in the middle addresses.

Let see the same plot in terms of threads:

#+begin_src R :results output graphics :file img/intensity_Th_bt.A_zoom_fields.png :exports both :width 600 :height 400 :session
s <- n[which(n$Structure=="fields_"),]
library(ggplot2);
p <- ggplot(s) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Offset,yend=Offset, color=as.factor(N))) +
  facet_grid(Structure~Type)
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_Th_bt.A_zoom_fields.png]]


The zoom doesn't give anymore information than what we have at the
first view, the sharing is almost always by groups of two threads,
maybe we should re run the benchmark with 8 threads, to see if this
grows to 4 or stay identical.

One last plot before looking at the code: the number of accesses per
offset on fields:

#+begin_src R :results output :session :exports both
t <- n[which(n$Structure=="fields_"),]
system.time(t <- aggregate(t[,c('Reads','Writes')],t[,c('Structure','Offset', 'Type')], function(d) sum(d)));
t$N <- t$Reads + t$Writes
str(t)
head(t)
#+end_src

#+RESULTS:
#+begin_example
   user  system elapsed 
  5.476   0.020   5.500
'data.frame':	77723 obs. of  6 variables:
 $ Structure: chr  "fields_" "fields_" "fields_" "fields_" ...
 $ Offset   : int  1480 2648 2664 2688 2888 3088 3928 4448 4608 4808 ...
 $ Type     : chr  "Private_Read" "Private_Read" "Private_Read" "Private_Read" ...
 $ Reads    : int  44 131 23 1 8 1 1 1 1 1 ...
 $ Writes   : int  0 0 0 0 0 0 0 0 0 0 ...
 $ N        : int  44 131 23 1 8 1 1 1 1 1 ...
  Structure Offset         Type Reads Writes   N
1   fields_   1480 Private_Read    44      0  44
2   fields_   2648 Private_Read   131      0 131
3   fields_   2664 Private_Read    23      0  23
4   fields_   2688 Private_Read     1      0   1
5   fields_   2888 Private_Read     8      0   8
6   fields_   3088 Private_Read     1      0   1
#+end_example

#+begin_src R :results output graphics :file img/num_acc_bt.A_zoom_un1.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(t, aes(x=Offset,y=N, color=Type)) +
  theme_bw() +
  geom_point() +
  theme_bw() +
  theme(legend.title=element_blank()) +
  scale_y_log10() +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/num_acc_bt.A_zoom_un1.png]]


This is beautifull, but I'm not sure to know how to interpret it.
So:
    - Each addresses is accesses from 1 to 500 times
    - As stated earlier most of the sharing occurs in the page that
      are in the middle of fields

      
I think that it's enough plots for now, let's look at bt source code.

** BT code examination

There is an archive to the NPB version that I'm using on ligcloud:
https://ligcloud.imag.fr/public.php?service=files&t=c755eeddfc585aa055dbe5c2dd03c43f

#+begin_src sh :results output :session :exports both
md5sum npb.tgz
#+end_src

#+RESULTS:
: 6362aee43eeb34590d68754087afa5df  npb.tgz

Lets recompire bt, we will need it later:
#+begin_src sh :results output :session :exports both
cd NPB3.3-OMP
make bt CLASS=A
#+end_src

#+RESULTS:
#+begin_example
cd sys; make all
make[1]: Entering directory '/home/david/Work/Bench/NPB3.3-OMP/sys'
make[1]: Nothing to be done for 'all'.
make[1]: Leaving directory '/home/david/Work/Bench/NPB3.3-OMP/sys'
   ============================================
   =      NAS PARALLEL BENCHMARKS 3.3         =
   =      OpenMP Versions                     =
   =      F77/C                               =
   ============================================

cd BT; make CLASS=A VERSION=
make[1]: Entering directory '/home/david/Work/Bench/NPB3.3-OMP/BT'
make[2]: Entering directory '/home/david/Work/Bench/NPB3.3-OMP/sys'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/home/david/Work/Bench/NPB3.3-OMP/sys'
../sys/setparams bt A
make[2]: Entering directory '/home/david/Work/Bench/NPB3.3-OMP/BT'
gfortran -O2 -fopenmp -o ../bin/bt.A.x bt.o  initialize.o exact_solution.o exact_rhs.o set_constants.o adi.o  rhs.o x_solve.o y_solve.o solve_subs.o z_solve.o add.o error.o verify.o ../common/print_results.o ../common/timers.o ../common/wtime.o 
make[2]: Leaving directory '/home/david/Work/Bench/NPB3.3-OMP/BT'
cp ../bin/bt.A.x ../bin/bt.A
make[1]: Leaving directory '/home/david/Work/Bench/NPB3.3-OMP/BT'
#+end_example


Sadly BT code is Fortran and I don't really now this language, but
I'll try to guess a few things:
   - UnamedStruct#1:
       - The name of this structure indicate that it's a dynamically
         allocated structure in some code compiled without the debug
         flags.
         As we have compiled bt with debug flags, I assume that
         it is an external library.
                  #+begin_src sh :results output :session :exports both
         cd NPB3.3-OMP
         ldd ./bin/bt.A
         #+end_src

         #+RESULTS:
         #+begin_example
                 linux-vdso.so.1 (0x00007ffdf3d4d000)
                 libgfortran.so.3 => /usr/lib/x86_64-linux-gnu/libgfortran.so.3 (0x00007ff36a739000)
                 libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007ff36a434000)
                 libgomp.so.1 => /usr/lib/x86_64-linux-gnu/libgomp.so.1 (0x00007ff36a211000)
                 libgcc_s.so.1 => /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007ff369ffb000)
                 libquadmath.so.0 => /usr/lib/x86_64-linux-gnu/libquadmath.so.0 (0x00007ff369dbc000)
                 libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007ff369b9e000)
                 libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007ff3697fa000)
                 libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007ff3695f6000)
                 /lib64/ld-linux-x86-64.so.2 (0x00005620cdbb1000)
         #+end_example
         This is to much library to rely on a lucky guess, I should
         add a copy of /proc/pid/maps to my traces to know at least
         from which library the unnamed structures comes.
   - fields:
       - There is no field data structure in the code, yet it appears
         in several binaries and in a comment, the author speak about
         common /fields/:
         #+begin_src sh :results output :session :exports both
         cd NPB3.3-OMP/BT
         grep -Rni "field" .
         #+end_src

         #+RESULTS:
         #+begin_example
         Binary file ./add.o matches
         Binary file ./verify.o matches
         Binary file ./exact_solution.o matches
         Binary file ./error.o matches
         Binary file ./set_constants.o matches
         Binary file ./x_solve.o matches
         Binary file ./initialize.o matches
         Binary file ./y_solve.o matches
         Binary file ./exact_rhs.o matches
         Binary file ./bt.o matches
         ./header.h:79:      common /fields/  u, us, vs, ws, qs, rho_i, square, 
         ./initialize.f:10:c     This subroutine initializes the field variable u using 
         Binary file ./z_solve.o matches
         ./bt.f:31:!          Moffett Field, CA   94035-1000                                 !
         Binary file ./rhs.o matches
         #+end_example
         I guess I need to know a little bit more about fortran to
         understant this ...

* 2016-04-01 Processing Sofa traces                                   :David:

This is just a test on Sofa traces, my version of Sofa is out of date
and I am not planning to do any improvements on Sofa from these
visu. I just want to see if we manage to see something on these traces.

#+begin_src sh :results output :exports both :session
cd Moca-runSofa-2016-04-01_16-43-01
~/Work/Moca/src/utils/create_event_producer.sh 4096 Moca-full-trace.csv
head Moca-framesoc.csv
awk -F , 'BEGIN{p="";cpt=1} {if(p==$1){n=$1"-"cpt;cpt++}\
else{cpt=1;n=$1};p=$1;print n","$2","$3","$4}' \
structs.csv > structs-uniq.csv
head  structs-uniq.csv
#+end_src

#+RESULTS:
#+begin_example
Generating producer files
Generating framesoc trace file
Generating Virtual producers file
Generating Physical producers file
Physical-producers.log Done
Virtual-producers.log Done
Reading from Moca-full-trace.csv
287245 accesses on 49008 pages parsed from Moca-full-trace.csv
done in 00 h 00 min 09.236 sec
@Virt,@Phy,Nreads,Nwrites,CPUMask,Start,End,TaskId,Shared
0000000000400040,000062000d743e58,1,0,00110,1,533,0,1
0000000000400940,000062000cec9640,1,0,01100,124524,125251,0,1
0000000000400200,000062000cec9640,1,0,01100,125252,125823,0,1
0000000000400200,000062000cec9640,1,0,01100,125824,126463,0,1
0000000000400200,000062000df5f6c8,1,0,01100,126464,127049,0,1
0000000000400200,000062000df5f6c8,1,0,01100,127050,127497,0,1
0000000000400200,000062000df5f6c8,1,0,01100,127498,127998,0,1
0000000000400200,000062000df5f6c8,1,0,01100,127999,127999,0,1
0000000000400200,000062000df5f6c8,1,0,01100,127999,129349,0,1
name,addr,size,backtrace
_ZN4sofa9component10forcefield39HexahedronCompositeFEMForceFieldAndMassINS_11defaulttype14StdVectorTypesINS3_3VecILi3EdEES6_dEEE24WEIGHT_MASK_CROSSED_DIFFE,4043264,7776,NA
_ZN4sofa9component10forcefield39HexahedronCompositeFEMForceFieldAndMassINS_11defaulttype14StdVectorTypesINS3_3VecILi3EdEES6_dEEE11WEIGHT_MASKE,4058816,7776,NA
_ZN4sofa9component10forcefield39HexahedronCompositeFEMForceFieldAndMassINS_11defaulttype14StdVectorTypesINS3_3VecILi3EfEES6_fEEE19WEIGHT_MASK_CROSSEDE,4023712,7776,NA
_ZN4sofa9component10forcefield39HexahedronCompositeFEMForceFieldAndMassINS_11defaulttype14StdVectorTypesINS3_3VecILi3EfEES6_fEEE24WEIGHT_MASK_CROSSED_DIFFE,4015936,7776,NA
_ZN4sofa9component10forcefield39HexahedronCompositeFEMForceFieldAndMassINS_11defaulttype14StdVectorTypesINS3_3VecILi3EdEES6_dEEE19WEIGHT_MASK_CROSSEDE,4051040,7776,NA
_ZN4sofa9component10forcefield39HexahedronCompositeFEMForceFieldAndMassINS_11defaulttype14StdVectorTypesINS3_3VecILi3EfEES6_fEEE11WEIGHT_MASKE,4031488,7776,NA
_ZN4sofa9component9container11SpatialGridINS1_16SpatialGridTypesINS_11defaulttype14StdVectorTypesINS4_3VecILi2EdEES7_dEEEEE9emptyGridE,5156832,12344,NA
_ZN4sofa9component9container11SpatialGridINS0_7mapping31SPHFluidSurfaceMappingGridTypesINS_11defaulttype14StdVectorTypesINS5_3VecILi3EfEES8_fEES9_EEE9emptyGridE,5218944,16440,NA
_ZN4sofa9component9container11SpatialGridINS0_7mapping31SPHFluidSurfaceMappingGridTypesINS_11defaulttype14StdVectorTypesINS5_3VecILi3EdEES8_dEENS5_14ExtVectorTypesINS7_ILi3EfEESB_fEEEEE9emptyGridE,5202432,16440,NA
#+end_example

#+begin_src R :results output :session :exports both
ptm <- proc.time()
library(gmp)


system.time(k <- read.csv("Moca-runSofa-2016-04-01_16-43-01/Moca-framesoc.csv", header=T));
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

# Use bigz to parse
k$Address <- as.bigz(paste("0x", k$Address, sep=""))
k$Phy <- NULL;
k$CPU <- NULL;
k$Duration <- k$End - k$Start
head(k);
str(k)

# Add structure info
structs <- read.csv("Moca-runSofa-2016-04-01_16-43-01/structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize", "BackTrace");
structs$AddressStart <- as.bigz(structs$AddressStart)
structs$AddressSize <- as.bigz(structs$AddressSize)
structs$AddressEnd <- structs$AddressStart + structs$AddressSize
head(structs)
# Filter interesting data structure as soon as possible
# The following line is specific to matrix, adapt it for other analysis
# structs <- structs[!grepl("thread",structs$Structure),]
#str(structs)
#show(structs)

# Retrieve struct infos
nrow(k)
# These lines are specific to matrix, adapt it for other analysis
minA <- structs[1,2]
maxA <- structs[nrow(structs),5]
proc.time() - ptm
show(minA)
show(maxA)
#+end_src

#+RESULTS:
#+begin_example

Attaching package: ‘gmp’

The following objects are masked from ‘package:base’:

    %*%, apply, crossprod, matrix, tcrossprod
   user  system elapsed 
  2.884   0.020   2.903
            X.Virt            X.Phy Nreads Nwrites CPUMask  Start    End TaskId
1 0000000000400040 000062000d743e58      1       0     110      1    533      0
2 0000000000400940 000062000cec9640      1       0    1100 124524 125251      0
3 0000000000400200 000062000cec9640      1       0    1100 125252 125823      0
4 0000000000400200 000062000cec9640      1       0    1100 125824 126463      0
5 0000000000400200 000062000df5f6c8      1       0    1100 126464 127049      0
6 0000000000400200 000062000df5f6c8      1       0    1100 127050 127497      0
  Shared
1      1
2      1
3      1
4      1
5      1
6      1
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
  Address Reads Writes  Start    End Tid N Duration
1 4194368     1      0      1    533   0 1      532
2 4196672     1      0 124524 125251   0 1      727
3 4194816     1      0 125252 125823   0 1      571
4 4194816     1      0 125824 126463   0 1      639
5 4194816     1      0 126464 127049   0 1      585
6 4194816     1      0 127050 127497   0 1      447
'data.frame':	308400 obs. of  8 variables:
 $ Address :Class 'bigz'  raw [1:4848740] b0 b4 04 00 ...
 $ Reads   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes  : int  0 0 0 0 0 0 0 0 0 0 ...
 $ Start   : int  1 124524 125252 125824 126464 127050 127498 127999 127999 127999 ...
 $ End     : int  533 125251 125823 126463 127049 127497 127998 127999 129349 129349 ...
 $ Tid     : int  0 0 0 0 0 0 0 0 0 0 ...
 $ N       : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Duration: int  532 727 571 639 585 447 500 0 1350 1350 ...
                                                                                                                                                    Structure
1 _ZN4sofa9component10forcefield39HexahedronCompositeFEMForceFieldAndMassINS_11defaulttype14StdVectorTypesINS3_3VecILi3EdEES6_dEEE24WEIGHT_MASK_CROSSED_DIFFE
2              _ZN4sofa9component10forcefield39HexahedronCompositeFEMForceFieldAndMassINS_11defaulttype14StdVectorTypesINS3_3VecILi3EdEES6_dEEE11WEIGHT_MASKE
3      _ZN4sofa9component10forcefield39HexahedronCompositeFEMForceFieldAndMassINS_11defaulttype14StdVectorTypesINS3_3VecILi3EfEES6_fEEE19WEIGHT_MASK_CROSSEDE
4 _ZN4sofa9component10forcefield39HexahedronCompositeFEMForceFieldAndMassINS_11defaulttype14StdVectorTypesINS3_3VecILi3EfEES6_fEEE24WEIGHT_MASK_CROSSED_DIFFE
5      _ZN4sofa9component10forcefield39HexahedronCompositeFEMForceFieldAndMassINS_11defaulttype14StdVectorTypesINS3_3VecILi3EdEES6_dEEE19WEIGHT_MASK_CROSSEDE
6              _ZN4sofa9component10forcefield39HexahedronCompositeFEMForceFieldAndMassINS_11defaulttype14StdVectorTypesINS3_3VecILi3EfEES6_fEEE11WEIGHT_MASKE
  AddressStart AddressSize BackTrace AddressEnd
1      4043264        7776      <NA>    4051040
2      4058816        7776      <NA>    4066592
3      4023712        7776      <NA>    4031488
4      4015936        7776      <NA>    4023712
5      4051040        7776      <NA>    4058816
6      4031488        7776      <NA>    4039264
[1] 308400
   user  system elapsed 
  3.760   0.044   4.879
Big Integer ('bigz') :
[1] 4043264
Big Integer ('bigz') :
[1] 577982816
#+end_example

#+begin_src R :results output :session :exports both
#system.time(l <- subset(k, k$Address >= minA & k$Address <= maxA));
system.time(l <- k[which(k$Address >= minA & k$Address <= maxA),]);
head(l)
str(l)
#+end_src

#+RESULTS:
#+begin_example
   user  system elapsed 
  0.312   0.000   0.313
  Address Reads Writes  Start    End Tid N Duration
1 4194368     1      0      1    533   0 1      532
2 4196672     1      0 124524 125251   0 1      727
3 4194816     1      0 125252 125823   0 1      571
4 4194816     1      0 125824 126463   0 1      639
5 4194816     1      0 126464 127049   0 1      585
6 4194816     1      0 127050 127497   0 1      447
'data.frame':	21416 obs. of  8 variables:
 $ Address :Class 'bigz'  raw [1:256996] a8 53 00 00 ...
 $ Reads   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes  : int  0 0 0 0 0 0 0 0 0 0 ...
 $ Start   : int  1 124524 125252 125824 126464 127050 127498 127999 127999 127999 ...
 $ End     : int  533 125251 125823 126463 127049 127497 127998 127999 129349 129349 ...
 $ Tid     : int  0 0 0 0 0 0 0 0 0 0 ...
 $ N       : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Duration: int  532 727 571 639 585 447 500 0 1350 1350 ...
#+end_example

#+begin_src R :results output :session :exports both
ptm <- proc.time()

# Compute accesses type

m <- l
system.time(m$aType <- ifelse(m$Write >0,"Write", "Read"));
system.time(m$sType <- ifelse(m$N > 1,"Shared","Private"));
system.time(m$Type <- paste(m$sType,m$aType,sep="_"));
m$sType <- NULL
m$aType <- NULL
head(m)

# Compute data structure name and offset
n <- m
structs$BackTrace <- NULL
head(structs)
getStructReverse <- function (vect){
  name <- 1
  start <- 2
  end <- 4
  return (ifelse(n$Address >= vect[start] & n$Address <= vect[end],
                paste(vect[name],as.bigz(n$Address) - as.bigz(vect[start]),sep="@"),""));
}
system.time(ans <- as.data.frame(apply(structs,1,getStructReverse)))
system.time(vect <- apply(ans,1,paste,collapse=""));
#str(vect)
system.time(vect <- strsplit(vect,"@"))
#str(vect)
system.time(n$Structure <- unlist(lapply(vect,"[",1)))
system.time(n$Offset <- as.integer(unlist(lapply(vect,"[",2))));
#str(n)
head(n)
nrow(n)

# Aggregate
system.time(o <- aggregate(n[,c('Reads','Writes', 'N')],n[,c('Structure','Offset', 'Type', 'Start', 'End')], function(d) sum(d)));
str(o)
head(o)

proc.time() - ptm
#+end_src

#+RESULTS:
#+begin_example
   user  system elapsed 
  0.016   0.000   0.015
   user  system elapsed 
  0.008   0.000   0.011
   user  system elapsed 
  0.004   0.000   0.006
  Address Reads Writes  Start    End Tid N Duration         Type
1 4194368     1      0      1    533   0 1      532 Private_Read
2 4196672     1      0 124524 125251   0 1      727 Private_Read
3 4194816     1      0 125252 125823   0 1      571 Private_Read
4 4194816     1      0 125824 126463   0 1      639 Private_Read
5 4194816     1      0 126464 127049   0 1      585 Private_Read
6 4194816     1      0 127050 127497   0 1      447 Private_Read
                                                                                                                                                    Structure
1 _ZN4sofa9component10forcefield39HexahedronCompositeFEMForceFieldAndMassINS_11defaulttype14StdVectorTypesINS3_3VecILi3EdEES6_dEEE24WEIGHT_MASK_CROSSED_DIFFE
2              _ZN4sofa9component10forcefield39HexahedronCompositeFEMForceFieldAndMassINS_11defaulttype14StdVectorTypesINS3_3VecILi3EdEES6_dEEE11WEIGHT_MASKE
3      _ZN4sofa9component10forcefield39HexahedronCompositeFEMForceFieldAndMassINS_11defaulttype14StdVectorTypesINS3_3VecILi3EfEES6_fEEE19WEIGHT_MASK_CROSSEDE
4 _ZN4sofa9component10forcefield39HexahedronCompositeFEMForceFieldAndMassINS_11defaulttype14StdVectorTypesINS3_3VecILi3EfEES6_fEEE24WEIGHT_MASK_CROSSED_DIFFE
5      _ZN4sofa9component10forcefield39HexahedronCompositeFEMForceFieldAndMassINS_11defaulttype14StdVectorTypesINS3_3VecILi3EdEES6_dEEE19WEIGHT_MASK_CROSSEDE
6              _ZN4sofa9component10forcefield39HexahedronCompositeFEMForceFieldAndMassINS_11defaulttype14StdVectorTypesINS3_3VecILi3EfEES6_fEEE11WEIGHT_MASKE
  AddressStart AddressSize AddressEnd
1      4043264        7776    4051040
2      4058816        7776    4066592
3      4023712        7776    4031488
4      4015936        7776    4023712
5      4051040        7776    4058816
6      4031488        7776    4039264
   user  system elapsed 
  27.41    0.10   27.61
   user  system elapsed 
  4.516   0.080   4.597
   user  system elapsed 
  0.008   0.000   0.008
   user  system elapsed 
  0.016   0.000   0.017
   user  system elapsed 
  0.012   0.000   0.014
  Address Reads Writes  Start    End Tid N Duration         Type Structure
1 4194368     1      0      1    533   0 1      532 Private_Read      <NA>
2 4196672     1      0 124524 125251   0 1      727 Private_Read      <NA>
3 4194816     1      0 125252 125823   0 1      571 Private_Read      <NA>
4 4194816     1      0 125824 126463   0 1      639 Private_Read      <NA>
5 4194816     1      0 126464 127049   0 1      585 Private_Read      <NA>
6 4194816     1      0 127050 127497   0 1      447 Private_Read      <NA>
  Offset
1     NA
2     NA
3     NA
4     NA
5     NA
6     NA
[1] 21416
   user  system elapsed 
  0.036   0.000   0.035
'data.frame':	1432 obs. of  8 variables:
 $ Structure: chr  "malloc#0" "calloc#3" "malloc#1" "calloc#2" ...
 $ Offset   : int  312 984 1720 3144 4456 5128 5864 8600 10008 12744 ...
 $ Type     : chr  "Private_Write" "Private_Write" "Private_Write" "Private_Write" ...
 $ Start    : int  124524 124524 124524 124524 124524 124524 124524 124524 124524 124524 ...
 $ End      : int  125251 125251 125251 125251 125251 125251 125251 125251 125251 125251 ...
 $ Reads    : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ N        : int  1 1 1 1 1 1 1 1 1 1 ...
  Structure Offset          Type  Start    End Reads Writes N
1  malloc#0    312 Private_Write 124524 125251     1      1 1
2  calloc#3    984 Private_Write 124524 125251     1      1 1
3  malloc#1   1720 Private_Write 124524 125251     1      1 1
4  calloc#2   3144 Private_Write 124524 125251     1      1 1
5  malloc#0   4456 Private_Write 124524 125251     1      1 1
6  calloc#3   5128 Private_Write 124524 125251     1      1 1
   user  system elapsed 
 32.440   0.228  34.033
#+end_example

#+begin_src R :results output graphics :file img/intensity_Rw_runsofa.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(o) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Offset,yend=Offset, color=Reads+Writes)) +
  facet_grid(Structure~Type, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_Rw_runsofa.png]]


Ok This is way to much data structures, let's eliminate some of them:

#+begin_src R :results output graphics :file img/struct_importance_fixaddr_v2.png :exports both :width 600 :height 400 :session
library(plyr)
q <- ddply(o,.(Structure),summarize,Nacc=sum(N))
library(ggplot2);
p <- ggplot(q,aes(x=Structure,y=Nacc, fill=Structure)) +
  geom_bar(stat="identity") +
  theme_bw() +
  theme(panel.grid.minor = element_line(colour = "black", linetype="dashed", size = 0.1),
    panel.grid.major = element_line(colour = "black", size = 0.1)) +
  scale_y_log10()
  #lab=("Data structure name") +
  #ylab=("Number of accesses") +
p
#+end_src

#+RESULTS:
[[file:img/struct_importance_fixaddr_v2.png]]


Let's remove every structures with less than 100 accesses

#+begin_src R :results output :session :exports both
nrow(q)
s <- subset(q,q$Nacc > 100)
nrow(s)
nrow(o)
t <- subset(o,o$Struct %in% s$Struct)
nrow(t)
length(unique(o$Struct))
length(unique(t$Struct))
#+end_src

#+RESULTS:
: [1] 36
: [1] 6
: [1] 1432
: [1] 1201
: [1] 36
: [1] 6

#+begin_src R :results output graphics :file img/intensity_Rw_runsofa2.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(t) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Offset,yend=Offset, color=Reads+Writes)) +
  facet_grid(Structure~Type, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_Rw_runsofa2.png]]


This looks better, most structures seems to be private except the
malloc#30, If we were actually trying to do some improvements on Sofa
we should focus on it.

I will stop here for Sofa and work on some other benchmarks, once I
manage to do some performance improvements on a small kernel or two I
will go back to Sofa.

* 2016-05 Buggy Moca traces                                           :David:
** 2016-05-02 Ziad's benchmarks                                      :David:
*** First try 

Ziad is working on linear algebra kernels, he told me that his
benchmarks can interest me.

So the benchmarks are available at github:
https://github.com/linbox-team/fflas-ffpack

And I will with the dgemm benchmark:

TODO: Add archive link and md5sum

#+begin_src sh :results output :exports both :session
cd Moca-benchmark-fgemm-2016-04-19_15-56-38
# Already done on grid5000 (requires a huge amount of memory)
#~/Work/Moca/src/utils/create_event_producer.sh 4096 Moca-full-trace.csv
head Moca-framesoc.csv
sort -n -t',' -k2 structs.csv | \
awk -F , 'BEGIN{p="";cpt=1} {if(p==$1){n=$1"-"cpt;cpt++}\
else{cpt=1;n=$1};p=$1;print n","$2","$3","$4}'  > structs-uniq.csv
head  structs-uniq.csv
#+end_src

#+RESULTS:
#+begin_example
@Virt,@Phy,Nreads,Nwrites,CPUMask,Start,End,TaskId,Shared
0000000000400040,000062000b3531f0,1,0,000010110,1,232,0,1
0000000000400270,000062000b3531f0,1,0,010000110,234,236,2,1
0000000000400270,000062000b3531f0,1,0,010000110,236,8408,2,2
0000000000400270,000062000b3531f0,1,0,000000111,236,8408,4,2
0000000000400270,000062000b3531f0,1,0,000000111,8408,14840,4,1
000000000040049d,000062000b3531f0,1,0,001000110,29490,29506,0,1
0000000000405435,000062000b23f2b0,1,0,010000110,1,232,0,1
0000000000411960,000062000b23bb20,1,0,000010110,1,232,0,1
0000000000411665,000062000b23bb20,1,0,000001110,233,18208,1,1
name,addr,size,backtrace
_ZN6Givaro12BlocFreeList7TabSizeE,132288,4096,NA
_ZN6Givaro8Primes167_primesE,137536,52336,NA
_ZN6Givaro8AdicSize8qadic_64E,189888,31752,NA
_ZN6Givaro8AdicSize8n_max_64E,221696,31752,NA
_ZN6Givaro12BlocFreeList7TabFreeE,2439552,4096,NA
_ZN6GivaroL9SortedAllE,2443904,4096,NA
_ZN6GivaroL3AllE,2448000,8192,NA
_ZN6Givaro8AdicSize8qadic_53E,253504,11088,NA
_ZN6Givaro8AdicSize8n_max_53E,264640,11088,NA
#+end_example

#+begin_src R :results output :session :exports both
ptm <- proc.time()
library(gmp)


system.time(k <- read.csv("Moca-benchmark-fgemm-2016-04-19_15-56-38/Moca-framesoc.csv", header=T));
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

# Use bigz to parse
k$Address <- as.bigz(paste("0x", k$Address, sep=""))
k$Phy <- NULL;
k$CPU <- NULL;
k$Duration <- k$End - k$Start
head(k);
str(k)

# Add structure info
structs <- read.csv("Moca-benchmark-fgemm-2016-04-19_15-56-38/structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize", "BackTrace");
structs$AddressStart <- as.bigz(structs$AddressStart)
structs$AddressSize <- as.bigz(structs$AddressSize)
structs$AddressEnd <- structs$AddressStart + structs$AddressSize
head(structs)
# Filter interesting data structure as soon as possible
# The following line is specific to matrix, adapt it for other analysis
# structs <- structs[!grepl("thread",structs$Structure),]
str(structs)
show(structs)

# Retrieve struct infos
nrow(k)
# These lines are specific to matrix, adapt it for other analysis
minA <- structs[1,2]
maxA <- structs[nrow(structs),5]
proc.time() - ptm
show(minA)
show(maxA)
nrow(k)
#+end_src

#+RESULTS:
#+begin_example
   user  system elapsed 
  0.520   0.004   0.524
            X.Virt            X.Phy Nreads Nwrites  CPUMask Start   End TaskId
1 0000000000400040 000062000b3531f0      1       0    10110     1   232      0
2 0000000000400270 000062000b3531f0      1       0 10000110   234   236      2
3 0000000000400270 000062000b3531f0      1       0 10000110   236  8408      2
4 0000000000400270 000062000b3531f0      1       0      111   236  8408      4
5 0000000000400270 000062000b3531f0      1       0      111  8408 14840      4
6 000000000040049d 000062000b3531f0      1       0  1000110 29490 29506      0
  Shared
1      1
2      1
3      2
4      2
5      1
6      1
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
  Address Reads Writes Start   End Tid N Duration
1 4194368     1      0     1   232   0 1      231
2 4194928     1      0   234   236   2 1        2
3 4194928     1      0   236  8408   2 2     8172
4 4194928     1      0   236  8408   4 2     8172
5 4194928     1      0  8408 14840   4 1     6432
6 4195485     1      0 29490 29506   0 1       16
'data.frame':	60213 obs. of  8 variables:
 $ Address :Class 'bigz'  raw [1:962836] 35 eb 00 00 ...
 $ Reads   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes  : int  0 0 0 0 0 0 0 0 0 0 ...
 $ Start   : int  1 234 236 236 8408 29490 1 1 233 23419 ...
 $ End     : int  232 236 8408 8408 14840 29506 232 232 18208 29548 ...
 $ Tid     : int  0 2 2 4 4 0 0 0 1 4 ...
 $ N       : int  1 1 2 2 1 1 1 1 1 1 ...
 $ Duration: int  231 2 8172 8172 6432 16 231 231 17975 6129 ...
                          Structure AddressStart AddressSize BackTrace
1 _ZN6Givaro12BlocFreeList7TabSizeE       132288        4096      <NA>
2      _ZN6Givaro8Primes167_primesE       137536       52336      <NA>
3     _ZN6Givaro8AdicSize8qadic_64E       189888       31752      <NA>
4     _ZN6Givaro8AdicSize8n_max_64E       221696       31752      <NA>
5 _ZN6Givaro12BlocFreeList7TabFreeE      2439552        4096      <NA>
6            _ZN6GivaroL9SortedAllE      2443904        4096      <NA>
  AddressEnd
1     136384
2     189872
3     221640
4     253448
5    2443648
6    2448000
'data.frame':	18 obs. of  5 variables:
 $ Structure   : Factor w/ 18 levels "calloc#0","__GI___pthread_keys",..: 11 16 15 13 10 18 17 14 12 2 ...
 $ AddressStart:Class 'bigz'  raw [1:220] 12 00 00 00 ...
 $ AddressSize :Class 'bigz'  raw [1:220] 12 00 00 00 ...
 $ BackTrace   : Factor w/ 5 levels "moca.so:0x7f97cd6f6ce2:0x7f97cd6f697d/libc.so.6:0x7f97cbe48601:0x7f97cbe79bf6:0x7f97cbe4e830/libgomp.so.1:0x7f97cc5807b0:0x7f97"| __truncated__,..: NA NA NA NA NA NA NA NA NA NA ...
 $ AddressEnd  :Class 'bigz'  raw [1:220] 12 00 00 00 ...
                           Structure AddressStart AddressSize
1  _ZN6Givaro12BlocFreeList7TabSizeE       132288        4096
2       _ZN6Givaro8Primes167_primesE       137536       52336
3      _ZN6Givaro8AdicSize8qadic_64E       189888       31752
4      _ZN6Givaro8AdicSize8n_max_64E       221696       31752
5  _ZN6Givaro12BlocFreeList7TabFreeE      2439552        4096
6             _ZN6GivaroL9SortedAllE      2443904        4096
7                   _ZN6GivaroL3AllE      2448000        8192
8      _ZN6Givaro8AdicSize8qadic_53E       253504       11088
9      _ZN6Givaro8AdicSize8n_max_53E       264640       11088
10               __GI___pthread_keys      2196192       16384
11                    __pthread_keys      2196192       16384
12       _ZN6Givaro11IntPrimeDom2IPE      2412992       14068
13      _ZN6Givaro11IntPrimeDom3IP2E      2427072       12144
14                          calloc#0     37826560        4096
15                          malloc#2     37872848        4096
16                          malloc#3     37879216        4096
17                          malloc#4     37885584        4096
18                          malloc#1     37836368       32816
                                                                                                                                                                                                   BackTrace
1                                                                                                                                                                                                       <NA>
2                                                                                                                                                                                                       <NA>
3                                                                                                                                                                                                       <NA>
4                                                                                                                                                                                                       <NA>
5                                                                                                                                                                                                       <NA>
6                                                                                                                                                                                                       <NA>
7                                                                                                                                                                                                       <NA>
8                                                                                                                                                                                                       <NA>
9                                                                                                                                                                                                       <NA>
10                                                                                                                                                                                                      <NA>
11                                                                                                                                                                                                      <NA>
12                                                                                                                                                                                                      <NA>
13                                                                                                                                                                                                      <NA>
14                                          moca.so:0x7f97cd6f6ce2:0x7f97cd6f6a6c/libc.so.6:0x7f97cbde340c/libquadmath.so.0:0x7f97cb421432/ld-linux-x86-64.so.2:0x7f97cdd069fa:0x7f97cdd06ae3:0x7f97cdcf91ca
15         moca.so:0x7f97cd6f6ce2:0x7f97cd6f697d/libstdc++.so.6:0x7f97ccae72e8:0x7f97ccae7399/libgivaro.so.8:0x7f97cd2378ae:0x7f97cd22dc06/ld-linux-x86-64.so.2:0x7f97cdd069fa:0x7f97cdd06ae3:0x7f97cdcf91ca
16         moca.so:0x7f97cd6f6ce2:0x7f97cd6f697d/libstdc++.so.6:0x7f97ccae72e8:0x7f97ccae7399/libgivaro.so.8:0x7f97cd2378bc:0x7f97cd22dc06/ld-linux-x86-64.so.2:0x7f97cdd069fa:0x7f97cdd06ae3:0x7f97cdcf91ca
17         moca.so:0x7f97cd6f6ce2:0x7f97cd6f697d/libstdc++.so.6:0x7f97ccae72e8:0x7f97ccae7399/libgivaro.so.8:0x7f97cd2378ca:0x7f97cd22dc06/ld-linux-x86-64.so.2:0x7f97cdd069fa:0x7f97cdd06ae3:0x7f97cdcf91ca
18 moca.so:0x7f97cd6f6ce2:0x7f97cd6f697d/libc.so.6:0x7f97cbe48601:0x7f97cbe79bf6:0x7f97cbe4e830/libgomp.so.1:0x7f97cc5807b0:0x7f97cc575d2d/ld-linux-x86-64.so.2:0x7f97cdd069fa:0x7f97cdd06ae3:0x7f97cdcf91ca
   AddressEnd
1      136384
2      189872
3      221640
4      253448
5     2443648
6     2448000
7     2456192
8      264592
9      275728
10    2212576
11    2212576
12    2427060
13    2439216
14   37830656
15   37876944
16   37883312
17   37889680
18   37869184
[1] 60213
   user  system elapsed 
  0.820   0.004   1.684
Big Integer ('bigz') :
[1] 132288
Big Integer ('bigz') :
[1] 37869184
[1] 60213
#+end_example

#+begin_src R :results output :session :exports both
#system.time(l <- subset(k, k$Address >= minA & k$Address <= maxA));
system.time(l <- k[which(k$Address >= minA & k$Address <= maxA),]);
head(l)
str(l)
nrow(l)
#+end_src

#+RESULTS:
#+begin_example
   user  system elapsed 
  0.080   0.000   0.079
  Address Reads Writes Start   End Tid N Duration
1 4194368     1      0     1   232   0 1      231
2 4194928     1      0   234   236   2 1        2
3 4194928     1      0   236  8408   2 2     8172
4 4194928     1      0   236  8408   4 2     8172
5 4194928     1      0  8408 14840   4 1     6432
6 4195485     1      0 29490 29506   0 1       16
'data.frame':	63 obs. of  8 variables:
 $ Address :Class 'bigz'  raw [1:760] 3f 00 00 00 ...
 $ Reads   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes  : int  0 0 0 0 0 0 0 0 0 0 ...
 $ Start   : int  1 234 236 236 8408 29490 1 1 233 23419 ...
 $ End     : int  232 236 8408 8408 14840 29506 232 232 18208 29548 ...
 $ Tid     : int  0 2 2 4 4 0 0 0 1 4 ...
 $ N       : int  1 1 2 2 1 1 1 1 1 1 ...
 $ Duration: int  231 2 8172 8172 6432 16 231 231 17975 6129 ...
[1] 63
#+end_example


This is weird: only 63 accesses detected on the data structures over
60213 accesses, I guess we need to do more precise traces, I will try
to play on Moca settings to generate a more precise trace.

Note: For bt we had 2215107 accesses.

*** Second try 

Here is another fgemm trace (different parameters)

TODO: Add archive link and md5sum

#+begin_src sh :results output :exports both :session
cd Moca-benchmark-fgemm-2016-04-19_15-58-16
# Already done on grid5000 (requires a huge amount of memory)
#~/Work/Moca/src/utils/create_event_producer.sh 4096 Moca-full-trace.csv
head Moca-framesoc.csv
sort -n -t',' -k2 structs.csv | \
awk -F , 'BEGIN{p="";cpt=1} {if(p==$1){n=$1"-"cpt;cpt++}\
else{cpt=1;n=$1};p=$1;print n","$2","$3","$4}'  > structs-uniq.csv
head  structs-uniq.csv
#+end_src

#+RESULTS:
#+begin_example
@Virt,@Phy,Nreads,Nwrites,CPUMask,Start,End,TaskId,Shared
0000000000400040,000062000b3531f0,1,0,000001011,1,234,0,1
0000000000400270,000062000b3531f0,1,0,000010011,243,6709,4,1
0000000000400270,000062000b3531f0,1,0,000010011,6709,8784,4,2
0000000000400270,000062000b3531f0,1,0,000100011,6709,8784,1,2
0000000000400270,000062000b3531f0,1,0,000010011,8784,35287,4,1
000000000040055d,000062000b3531f0,1,0,000000011,3826621,3828417,0,1
00000000004006f5,000062000b3531f0,1,0,000010011,3836236,3837432,0,1
0000000000405435,000062000b23f2b0,1,0,000000111,1,234,0,1
0000000000411960,000062000b23bb20,1,0,000001011,1,234,0,1
name,addr,size,backtrace
_ZN6Givaro12BlocFreeList7TabSizeE,132288,4096,NA
_ZN6Givaro8Primes167_primesE,137536,52336,NA
_ZN6Givaro8AdicSize8qadic_64E,189888,31752,NA
_ZN6Givaro8AdicSize8n_max_64E,221696,31752,NA
_ZN6Givaro12BlocFreeList7TabFreeE,2439552,4096,NA
_ZN6GivaroL9SortedAllE,2443904,4096,NA
_ZN6GivaroL3AllE,2448000,8192,NA
_ZN6Givaro8AdicSize8qadic_53E,253504,11088,NA
_ZN6Givaro8AdicSize8n_max_53E,264640,11088,NA
#+end_example

#+begin_src R :results output :session :exports both
ptm <- proc.time()
library(gmp)


system.time(k <- read.csv("Moca-benchmark-fgemm-2016-04-19_15-58-16/Moca-framesoc.csv", header=T));
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

# Use bigz to parse
k$Address <- as.bigz(paste("0x", k$Address, sep=""))
k$Phy <- NULL;
k$CPU <- NULL;
k$Duration <- k$End - k$Start
head(k);
str(k)

# Add structure info
structs <- read.csv("Moca-benchmark-fgemm-2016-04-19_15-58-16/structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize", "BackTrace");
structs$AddressStart <- as.bigz(structs$AddressStart)
structs$AddressSize <- as.bigz(structs$AddressSize)
structs$AddressEnd <- structs$AddressStart + structs$AddressSize
head(structs)
# Filter interesting data structure as soon as possible
# The following line is specific to matrix, adapt it for other analysis
# structs <- structs[!grepl("thread",structs$Structure),]
str(structs)
show(structs)

# Retrieve struct infos
nrow(k)
# These lines are specific to matrix, adapt it for other analysis
minA <- structs[1,2]
maxA <- structs[nrow(structs),5]
proc.time() - ptm
show(minA)
show(maxA)
nrow(k)
#+end_src

#+RESULTS:
#+begin_example
   user  system elapsed 
 202.58    6.32  212.15
            X.Virt            X.Phy Nreads Nwrites CPUMask   Start     End
1 0000000000400040 000062000b3531f0      1       0    1011       1     234
2 0000000000400270 000062000b3531f0      1       0   10011     243    6709
3 0000000000400270 000062000b3531f0      1       0   10011    6709    8784
4 0000000000400270 000062000b3531f0      1       0  100011    6709    8784
5 0000000000400270 000062000b3531f0      1       0   10011    8784   35287
6 000000000040055d 000062000b3531f0      1       0      11 3826621 3828417
  TaskId Shared
1      0      1
2      4      1
3      4      2
4      1      2
5      4      1
6      0      1
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
  Address Reads Writes   Start     End Tid N Duration
1 4194368     1      0       1     234   0 1      233
2 4194928     1      0     243    6709   4 1     6466
3 4194928     1      0    6709    8784   4 2     2075
4 4194928     1      0    6709    8784   1 2     2075
5 4194928     1      0    8784   35287   4 1    26503
6 4195677     1      0 3826621 3828417   0 1     1796
'data.frame':	52651863 obs. of  8 variables:
 $ Address :Class 'bigz'  raw [1:842428708] 57 67 23 03 ...
 $ Reads   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes  : int  0 0 0 0 0 0 0 0 0 0 ...
 $ Start   : int  1 243 6709 6709 8784 3826621 3836236 1 1 8788 ...
 $ End     : int  234 6709 8784 8784 35287 3828417 3837432 234 234 8805 ...
 $ Tid     : int  0 4 4 1 4 0 0 0 0 0 ...
 $ N       : int  1 1 2 2 1 1 1 1 1 1 ...
 $ Duration: int  233 6466 2075 2075 26503 1796 1196 233 233 17 ...
                          Structure AddressStart AddressSize BackTrace
1 _ZN6Givaro12BlocFreeList7TabSizeE       132288        4096      <NA>
2      _ZN6Givaro8Primes167_primesE       137536       52336      <NA>
3     _ZN6Givaro8AdicSize8qadic_64E       189888       31752      <NA>
4     _ZN6Givaro8AdicSize8n_max_64E       221696       31752      <NA>
5 _ZN6Givaro12BlocFreeList7TabFreeE      2439552        4096      <NA>
6            _ZN6GivaroL9SortedAllE      2443904        4096      <NA>
  AddressEnd
1     136384
2     189872
3     221640
4     253448
5    2443648
6    2448000
'data.frame':	18 obs. of  5 variables:
 $ Structure   : Factor w/ 18 levels "calloc#0","__GI___pthread_keys",..: 11 16 15 13 10 18 17 14 12 2 ...
 $ AddressStart:Class 'bigz'  raw [1:220] 12 00 00 00 ...
 $ AddressSize :Class 'bigz'  raw [1:220] 12 00 00 00 ...
 $ BackTrace   : Factor w/ 5 levels "moca.so:0x7f25ed61ace2:0x7f25ed61a97d/libc.so.6:0x7f25ebd6c601:0x7f25ebd9dbf6:0x7f25ebd72830/libgomp.so.1:0x7f25ec4a47b0:0x7f25"| __truncated__,..: NA NA NA NA NA NA NA NA NA NA ...
 $ AddressEnd  :Class 'bigz'  raw [1:220] 12 00 00 00 ...
                           Structure AddressStart AddressSize
1  _ZN6Givaro12BlocFreeList7TabSizeE       132288        4096
2       _ZN6Givaro8Primes167_primesE       137536       52336
3      _ZN6Givaro8AdicSize8qadic_64E       189888       31752
4      _ZN6Givaro8AdicSize8n_max_64E       221696       31752
5  _ZN6Givaro12BlocFreeList7TabFreeE      2439552        4096
6             _ZN6GivaroL9SortedAllE      2443904        4096
7                   _ZN6GivaroL3AllE      2448000        8192
8      _ZN6Givaro8AdicSize8qadic_53E       253504       11088
9      _ZN6Givaro8AdicSize8n_max_53E       264640       11088
10               __GI___pthread_keys      2196192       16384
11                    __pthread_keys      2196192       16384
12       _ZN6Givaro11IntPrimeDom2IPE      2412992       14068
13      _ZN6Givaro11IntPrimeDom3IP2E      2427072       12144
14                          calloc#0     24879104        4096
15                          malloc#2     24925392        4096
16                          malloc#3     24931760        4096
17                          malloc#4     24938128        4096
18                          malloc#1     24888912       32816
                                                                                                                                                                                                   BackTrace
1                                                                                                                                                                                                       <NA>
2                                                                                                                                                                                                       <NA>
3                                                                                                                                                                                                       <NA>
4                                                                                                                                                                                                       <NA>
5                                                                                                                                                                                                       <NA>
6                                                                                                                                                                                                       <NA>
7                                                                                                                                                                                                       <NA>
8                                                                                                                                                                                                       <NA>
9                                                                                                                                                                                                       <NA>
10                                                                                                                                                                                                      <NA>
11                                                                                                                                                                                                      <NA>
12                                                                                                                                                                                                      <NA>
13                                                                                                                                                                                                      <NA>
14                                          moca.so:0x7f25ed61ace2:0x7f25ed61aa6c/libc.so.6:0x7f25ebd0740c/libquadmath.so.0:0x7f25eb345432/ld-linux-x86-64.so.2:0x7f25edc2a9fa:0x7f25edc2aae3:0x7f25edc1d1ca
15         moca.so:0x7f25ed61ace2:0x7f25ed61a97d/libstdc++.so.6:0x7f25eca0b2e8:0x7f25eca0b399/libgivaro.so.8:0x7f25ed15b8ae:0x7f25ed151c06/ld-linux-x86-64.so.2:0x7f25edc2a9fa:0x7f25edc2aae3:0x7f25edc1d1ca
16         moca.so:0x7f25ed61ace2:0x7f25ed61a97d/libstdc++.so.6:0x7f25eca0b2e8:0x7f25eca0b399/libgivaro.so.8:0x7f25ed15b8bc:0x7f25ed151c06/ld-linux-x86-64.so.2:0x7f25edc2a9fa:0x7f25edc2aae3:0x7f25edc1d1ca
17         moca.so:0x7f25ed61ace2:0x7f25ed61a97d/libstdc++.so.6:0x7f25eca0b2e8:0x7f25eca0b399/libgivaro.so.8:0x7f25ed15b8ca:0x7f25ed151c06/ld-linux-x86-64.so.2:0x7f25edc2a9fa:0x7f25edc2aae3:0x7f25edc1d1ca
18 moca.so:0x7f25ed61ace2:0x7f25ed61a97d/libc.so.6:0x7f25ebd6c601:0x7f25ebd9dbf6:0x7f25ebd72830/libgomp.so.1:0x7f25ec4a47b0:0x7f25ec499d2d/ld-linux-x86-64.so.2:0x7f25edc2a9fa:0x7f25edc2aae3:0x7f25edc1d1ca
   AddressEnd
1      136384
2      189872
3      221640
4      253448
5     2443648
6     2448000
7     2456192
8      264592
9      275728
10    2212576
11    2212576
12    2427060
13    2439216
14   24883200
15   24929488
16   24935856
17   24942224
18   24921728
[1] 52651863
   user  system elapsed 
 302.60   31.52  472.25
Big Integer ('bigz') :
[1] 132288
Big Integer ('bigz') :
[1] 24921728
[1] 52651863
#+end_example

It tooks me 8Gio of RAM and as much of swap but it seems to worked,
let see if we still have no accesses on the data structures:

#+begin_src R :results output :session :exports both
#system.time(l <- subset(k, k$Address >= minA & k$Address <= maxA));
system.time(l <- k[which(k$Address >= minA & k$Address <= maxA),]);
head(l)
str(l)
nrow(l)
#+end_src

#+RESULTS:
#+begin_example
   user  system elapsed 
 52.480   7.972  90.136
  Address Reads Writes   Start     End Tid N Duration
1 4194368     1      0       1     234   0 1      233
2 4194928     1      0     243    6709   4 1     6466
3 4194928     1      0    6709    8784   4 2     2075
4 4194928     1      0    6709    8784   1 2     2075
5 4194928     1      0    8784   35287   4 1    26503
6 4195677     1      0 3826621 3828417   0 1     1796
'data.frame':	78 obs. of  8 variables:
 $ Address :Class 'bigz'  raw [1:940] 4e 00 00 00 ...
 $ Reads   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes  : int  0 0 0 0 0 0 0 0 0 0 ...
 $ Start   : int  1 243 6709 6709 8784 3826621 3836236 1 1 8788 ...
 $ End     : int  234 6709 8784 8784 35287 3828417 3837432 234 234 8805 ...
 $ Tid     : int  0 4 4 1 4 0 0 0 0 0 ...
 $ N       : int  1 1 2 2 1 1 1 1 1 1 ...
 $ Duration: int  233 6466 2075 2075 26503 1796 1196 233 233 17 ...
[1] 78
#+end_example

Now it's getting really weird, we have almost 100 times more accesses
than on the first trace on only 18 more accesses inside the detected
data structures.
I guess there is an issue on the way addresses of structure from
external libraries are computed. 

** 2016-05-04 New try on Ziad's benchmarks                           :David:

So after looking at my code, I found that I ommit the offset of the
library on the start address of external libraries data structures.
So I fixed it on Moca (commit
29fce1cc0a0fa453215a9f5694d681a681fc8d8e), and I generated a new trace
for the fgemm kernel:

TODO: Add archive link and md5sum

#+begin_src sh :results output :exports both :session
cd Moca-benchmark-fgemm-2016-05-04_14-42-51
# Already done on grid5000 (requires a huge amount of memory)
#~/Work/Moca/src/utils/create_event_producer.sh 4096 Moca-full-trace.csv
head Moca-framesoc.csv
sort -n -t',' -k2 structs.csv | \
awk -F , 'BEGIN{p="";cpt=1} {if(p==$1){n=$1"-"cpt;cpt++}\
else{cpt=1;n=$1};p=$1;print n","$2","$3","$4}'  > structs-uniq.csv
head  structs-uniq.csv
#+end_src

#+RESULTS:
#+begin_example
@Virt,@Phy,Nreads,Nwrites,CPUMask,Start,End,TaskId,Shared
0000000000400040,0000620015929dc8,1,0,010000110,1,232,0,1
0000000000400270,0000620015929dc8,1,0,000000110,233,238,1,1
0000000000400270,0000620015929dc8,1,0,000000110,238,16551,1,2
0000000000400270,0000620015929dc8,1,0,001000110,238,16551,4,2
0000000000400270,0000620015929dc8,1,0,001000110,16551,27748,4,1
0000000000400270,0000620015929dc8,1,0,001000110,27748,27787,4,2
000000000040049d,0000620015929dc8,1,0,010000110,27748,27787,0,2
000000000040049d,0000620015929dc8,1,0,010000110,27787,3554939,0,1
00000000004006f5,0000620015929dc8,1,0,000100110,3555763,3556903,0,1
name,addr,size,backtrace
calloc#0,32555008,4096,moca.so:0x7f7f010c0d9b:0x7f7f010c0aac/libc.so.6:0x7f7eff7ad40c/libquadmath.so.0:0x7f7efedeb432/ld-linux-x86-64.so.2:0x7f7f016d09fa:0x7f7f016d0ae3:0x7f7f016c31ca
malloc#2,32601296,4096,moca.so:0x7f7f010c0d9b:0x7f7f010c09bd/libstdc++.so.6:0x7f7f004b12e8:0x7f7f004b1399/libgivaro.so.8:0x7f7f00c018ae:0x7f7f00bf7c06/ld-linux-x86-64.so.2:0x7f7f016d09fa:0x7f7f016d0ae3:0x7f7f016c31ca
malloc#3,32607664,4096,moca.so:0x7f7f010c0d9b:0x7f7f010c09bd/libstdc++.so.6:0x7f7f004b12e8:0x7f7f004b1399/libgivaro.so.8:0x7f7f00c018bc:0x7f7f00bf7c06/ld-linux-x86-64.so.2:0x7f7f016d09fa:0x7f7f016d0ae3:0x7f7f016c31ca
malloc#4,32614032,4096,moca.so:0x7f7f010c0d9b:0x7f7f010c09bd/libstdc++.so.6:0x7f7f004b12e8:0x7f7f004b1399/libgivaro.so.8:0x7f7f00c018ca:0x7f7f00bf7c06/ld-linux-x86-64.so.2:0x7f7f016d09fa:0x7f7f016d0ae3:0x7f7f016c31ca
malloc#1,32564816,32816,moca.so:0x7f7f010c0d9b:0x7f7f010c09bd/libc.so.6:0x7f7eff812601:0x7f7eff843bf6:0x7f7eff818830/libgomp.so.1:0x7f7efff4a7b0:0x7f7efff3fd2d/ld-linux-x86-64.so.2:0x7f7f016d09fa:0x7f7f016d0ae3:0x7f7f016c31ca
_ZN6Givaro12BlocFreeList7TabSizeE,939766976,4096,NA
_ZN6Givaro12BlocFreeList7TabFreeE,942074240,4096,NA
_ZN6GivaroL9SortedAllE,942078592,4096,NA
_ZN6GivaroL3AllE,942082688,8192,NA
#+end_example

#+begin_src R :results output :session :exports both
ptm <- proc.time()
library(gmp)


system.time(k <- read.csv("Moca-benchmark-fgemm-2016-05-04_14-42-51/Moca-framesoc.csv", header=T));
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

# Use bigz to parse
k$Address <- as.bigz(paste("0x", k$Address, sep=""))
k$Phy <- NULL;
k$CPU <- NULL;
k$Duration <- k$End - k$Start
head(k);
str(k)

# Add structure info
structs <- read.csv("Moca-benchmark-fgemm-2016-05-04_14-42-51/structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize", "BackTrace");
structs$AddressStart <- as.bigz(structs$AddressStart)
structs$AddressSize <- as.bigz(structs$AddressSize)
structs$AddressEnd <- structs$AddressStart + structs$AddressSize
head(structs)
# Filter interesting data structure as soon as possible
# The following line is specific to matrix, adapt it for other analysis
# structs <- structs[!grepl("thread",structs$Structure),]
str(structs)
show(structs)

# Retrieve struct infos
nrow(k)
# These lines are specific to matrix, adapt it for other analysis
minA <- structs[1,2]
maxA <- structs[nrow(structs),5]
proc.time() - ptm
show(minA)
show(maxA)
nrow(k)
#+end_src

#+RESULTS:
#+begin_example
   user  system elapsed 
110.736   2.416 113.569
            X.Virt            X.Phy Nreads Nwrites  CPUMask Start   End TaskId
1 0000000000400040 0000620015929dc8      1       0 10000110     1   232      0
2 0000000000400270 0000620015929dc8      1       0      110   233   238      1
3 0000000000400270 0000620015929dc8      1       0      110   238 16551      1
4 0000000000400270 0000620015929dc8      1       0  1000110   238 16551      4
5 0000000000400270 0000620015929dc8      1       0  1000110 16551 27748      4
6 0000000000400270 0000620015929dc8      1       0  1000110 27748 27787      4
  Shared
1      1
2      1
3      2
4      2
5      1
6      2
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
  Address Reads Writes Start   End Tid N Duration
1 4194368     1      0     1   232   0 1      231
2 4194928     1      0   233   238   1 1        5
3 4194928     1      0   238 16551   1 2    16313
4 4194928     1      0   238 16551   4 2    16313
5 4194928     1      0 16551 27748   4 1    11197
6 4194928     1      0 27748 27787   4 2       39
'data.frame':	31432622 obs. of  8 variables:
 $ Address :Class 'bigz'  raw [1:502921048] ae 9f df 01 ...
 $ Reads   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes  : int  0 0 0 0 0 0 0 0 0 0 ...
 $ Start   : int  1 233 238 238 16551 27748 27748 27787 3555763 1 ...
 $ End     : int  232 238 16551 16551 27748 27787 27787 3554939 3556903 232 ...
 $ Tid     : int  0 1 1 4 4 4 0 0 0 0 ...
 $ N       : int  1 1 2 2 1 2 2 1 1 1 ...
 $ Duration: int  231 5 16313 16313 11197 39 39 3527152 1140 231 ...
                          Structure AddressStart AddressSize
1                          calloc#0     32555008        4096
2                          malloc#2     32601296        4096
3                          malloc#3     32607664        4096
4                          malloc#4     32614032        4096
5                          malloc#1     32564816       32816
6 _ZN6Givaro12BlocFreeList7TabSizeE    939766976        4096
                                                                                                                                                                                                  BackTrace
1                                          moca.so:0x7f7f010c0d9b:0x7f7f010c0aac/libc.so.6:0x7f7eff7ad40c/libquadmath.so.0:0x7f7efedeb432/ld-linux-x86-64.so.2:0x7f7f016d09fa:0x7f7f016d0ae3:0x7f7f016c31ca
2         moca.so:0x7f7f010c0d9b:0x7f7f010c09bd/libstdc++.so.6:0x7f7f004b12e8:0x7f7f004b1399/libgivaro.so.8:0x7f7f00c018ae:0x7f7f00bf7c06/ld-linux-x86-64.so.2:0x7f7f016d09fa:0x7f7f016d0ae3:0x7f7f016c31ca
3         moca.so:0x7f7f010c0d9b:0x7f7f010c09bd/libstdc++.so.6:0x7f7f004b12e8:0x7f7f004b1399/libgivaro.so.8:0x7f7f00c018bc:0x7f7f00bf7c06/ld-linux-x86-64.so.2:0x7f7f016d09fa:0x7f7f016d0ae3:0x7f7f016c31ca
4         moca.so:0x7f7f010c0d9b:0x7f7f010c09bd/libstdc++.so.6:0x7f7f004b12e8:0x7f7f004b1399/libgivaro.so.8:0x7f7f00c018ca:0x7f7f00bf7c06/ld-linux-x86-64.so.2:0x7f7f016d09fa:0x7f7f016d0ae3:0x7f7f016c31ca
5 moca.so:0x7f7f010c0d9b:0x7f7f010c09bd/libc.so.6:0x7f7eff812601:0x7f7eff843bf6:0x7f7eff818830/libgomp.so.1:0x7f7efff4a7b0:0x7f7efff3fd2d/ld-linux-x86-64.so.2:0x7f7f016d09fa:0x7f7f016d0ae3:0x7f7f016c31ca
6                                                                                                                                                                                                      <NA>
  AddressEnd
1   32559104
2   32605392
3   32611760
4   32618128
5   32597632
6  939771072
'data.frame':	18 obs. of  5 variables:
 $ Structure   : Factor w/ 18 levels "calloc#0","__GI___pthread_keys",..: 1 4 5 6 3 11 10 18 17 2 ...
 $ AddressStart:Class 'bigz'  raw [1:220] 12 00 00 00 ...
 $ AddressSize :Class 'bigz'  raw [1:220] 12 00 00 00 ...
 $ BackTrace   : Factor w/ 5 levels "moca.so:0x7f7f010c0d9b:0x7f7f010c09bd/libc.so.6:0x7f7eff812601:0x7f7eff843bf6:0x7f7eff818830/libgomp.so.1:0x7f7efff4a7b0:0x7f7e"| __truncated__,..: 5 2 3 4 1 NA NA NA NA NA ...
 $ AddressEnd  :Class 'bigz'  raw [1:220] 12 00 00 00 ...
                           Structure AddressStart AddressSize
1                           calloc#0     32555008        4096
2                           malloc#2     32601296        4096
3                           malloc#3     32607664        4096
4                           malloc#4     32614032        4096
5                           malloc#1     32564816       32816
6  _ZN6Givaro12BlocFreeList7TabSizeE    939766976        4096
7  _ZN6Givaro12BlocFreeList7TabFreeE    942074240        4096
8             _ZN6GivaroL9SortedAllE    942078592        4096
9                   _ZN6GivaroL3AllE    942082688        8192
10               __GI___pthread_keys    924140256       16384
11                    __pthread_keys    924140256       16384
12      _ZN6Givaro8Primes167_primesE    939772224       52336
13     _ZN6Givaro8AdicSize8qadic_64E    939824576       31752
14     _ZN6Givaro8AdicSize8n_max_64E    939856384       31752
15     _ZN6Givaro8AdicSize8qadic_53E    939888192       11088
16     _ZN6Givaro8AdicSize8n_max_53E    939899328       11088
17       _ZN6Givaro11IntPrimeDom2IPE    942047680       14068
18      _ZN6Givaro11IntPrimeDom3IP2E    942061760       12144
                                                                                                                                                                                                   BackTrace
1                                           moca.so:0x7f7f010c0d9b:0x7f7f010c0aac/libc.so.6:0x7f7eff7ad40c/libquadmath.so.0:0x7f7efedeb432/ld-linux-x86-64.so.2:0x7f7f016d09fa:0x7f7f016d0ae3:0x7f7f016c31ca
2          moca.so:0x7f7f010c0d9b:0x7f7f010c09bd/libstdc++.so.6:0x7f7f004b12e8:0x7f7f004b1399/libgivaro.so.8:0x7f7f00c018ae:0x7f7f00bf7c06/ld-linux-x86-64.so.2:0x7f7f016d09fa:0x7f7f016d0ae3:0x7f7f016c31ca
3          moca.so:0x7f7f010c0d9b:0x7f7f010c09bd/libstdc++.so.6:0x7f7f004b12e8:0x7f7f004b1399/libgivaro.so.8:0x7f7f00c018bc:0x7f7f00bf7c06/ld-linux-x86-64.so.2:0x7f7f016d09fa:0x7f7f016d0ae3:0x7f7f016c31ca
4          moca.so:0x7f7f010c0d9b:0x7f7f010c09bd/libstdc++.so.6:0x7f7f004b12e8:0x7f7f004b1399/libgivaro.so.8:0x7f7f00c018ca:0x7f7f00bf7c06/ld-linux-x86-64.so.2:0x7f7f016d09fa:0x7f7f016d0ae3:0x7f7f016c31ca
5  moca.so:0x7f7f010c0d9b:0x7f7f010c09bd/libc.so.6:0x7f7eff812601:0x7f7eff843bf6:0x7f7eff818830/libgomp.so.1:0x7f7efff4a7b0:0x7f7efff3fd2d/ld-linux-x86-64.so.2:0x7f7f016d09fa:0x7f7f016d0ae3:0x7f7f016c31ca
6                                                                                                                                                                                                       <NA>
7                                                                                                                                                                                                       <NA>
8                                                                                                                                                                                                       <NA>
9                                                                                                                                                                                                       <NA>
10                                                                                                                                                                                                      <NA>
11                                                                                                                                                                                                      <NA>
12                                                                                                                                                                                                      <NA>
13                                                                                                                                                                                                      <NA>
14                                                                                                                                                                                                      <NA>
15                                                                                                                                                                                                      <NA>
16                                                                                                                                                                                                      <NA>
17                                                                                                                                                                                                      <NA>
18                                                                                                                                                                                                      <NA>
   AddressEnd
1    32559104
2    32605392
3    32611760
4    32618128
5    32597632
6   939771072
7   942078336
8   942082688
9   942090880
10  924156640
11  924156640
12  939824560
13  939856328
14  939888136
15  939899280
16  939910416
17  942061748
18  942073904
[1] 31432622
   user  system elapsed 
159.208   5.912 173.132
Big Integer ('bigz') :
[1] 32555008
Big Integer ('bigz') :
[1] 942073904
[1] 31432622
#+end_example

Same as yesterday: slow and heavy but it works ...

#+begin_src R :results output :session :exports both
#system.time(l <- subset(k, k$Address >= minA & k$Address <= maxA));
system.time(l <- k[which(k$Address >= minA & k$Address <= maxA),]);
#head(l)
str(l)
nrow(l)
#+end_src

#+RESULTS:
#+begin_example
   user  system elapsed 
 27.920   2.312  32.873
'data.frame':	0 obs. of  8 variables:
 $ Address :Class 'bigz'  raw [1:4] 00 00 00 00
 $ Reads   : int 
 $ Writes  : int 
 $ Start   : int 
 $ End     : int 
 $ Tid     : int 
 $ N       : int 
 $ Duration: int
[1] 0
#+end_example

Now it's getting really weird, we have almost 100 times more accesses
than on the first trace on only 18 more accesses inside the detected
data structures. So I guess this benchmark is mostly working on data
structures from external libraries ... 

** 2016-05-06 Yet another try on fgemm                               :David:

It seems that on the previous traces, the addresse space randomization
wasn't turned off thus none of the structure address was correct ...

TODO: Add archive link and md5sum

#+begin_src sh :results output :exports both :session
cd Moca-benchmark-fgemm-2016-05-06_18-00-50
# Already done on grid5000 (requires a huge amount of memory)
#~/Work/Moca/src/utils/create_event_producer.sh 4096 Moca-full-trace.csv
head Moca-framesoc.csv
sort -n -t',' -k2 structs.csv | \
awk -F , 'BEGIN{p="";cpt=1} {if(p==$1){n=$1"-"cpt;cpt++}\
else{cpt=1;n=$1};p=$1;print n","$2","$3","$4}'  > structs-uniq.csv
head  structs-uniq.csv
#+end_src

#+RESULTS:
#+begin_example
@Virt,@Phy,Nreads,Nwrites,CPUMask,Start,End,TaskId,Shared
0000000000400040,000062000b0d1560,1,0,000100000,1,236,0,1
0000000000400040,000062000b0d1560,1,0,000100000,236,238,0,2
0000000000400270,000062000b0d1560,1,0,000010110,236,238,2,2
0000000000400270,000062000b0d1560,1,0,000010110,238,239,2,1
0000000000400270,000062000b0d1560,1,0,000010110,239,239,2,2
0000000000400270,000062000b0d1560,1,0,000100000,239,239,0,2
0000000000400270,000062000b0d1560,1,0,000010110,239,8444,2,3
0000000000400270,000062000b0d1560,1,0,000100000,239,8444,0,3
0000000000400270,000062000b0d1560,1,0,000001110,239,8444,3,3
name,addr,size,backtrace
calloc#0,6549504,4096,moca.so:0x7ffff77dad9b:0x7ffff77daaac/libc.so.6:0x7ffff5ec740c/libquadmath.so.0:0x7ffff5505432/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
malloc#2,6595792,4096,moca.so:0x7ffff77dad9b:0x7ffff77da9bd/libstdc++.so.6:0x7ffff6bcb2e8:0x7ffff6bcb399/libgivaro.so.8:0x7ffff731b8ae:0x7ffff7311c06/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
malloc#3,6602160,4096,moca.so:0x7ffff77dad9b:0x7ffff77da9bd/libstdc++.so.6:0x7ffff6bcb2e8:0x7ffff6bcb399/libgivaro.so.8:0x7ffff731b8bc:0x7ffff7311c06/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
malloc#4,6608528,4096,moca.so:0x7ffff77dad9b:0x7ffff77da9bd/libstdc++.so.6:0x7ffff6bcb2e8:0x7ffff6bcb399/libgivaro.so.8:0x7ffff731b8ca:0x7ffff7311c06/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
malloc#1,6559312,32816,moca.so:0x7ffff77dad9b:0x7ffff77da9bd/libc.so.6:0x7ffff5f2c601:0x7ffff5f5dbf6:0x7ffff5f32830/libgomp.so.1:0x7ffff66647b0:0x7ffff6659d2d/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
_ZN6Givaro12BlocFreeList7TabSizeE,18446744073570309312,4096,NA
_ZN6Givaro12BlocFreeList7TabFreeE,18446744073572616576,4096,NA
_ZN6GivaroL9SortedAllE,18446744073572620928,4096,NA
_ZN6GivaroL3AllE,18446744073572625024,8192,NA
#+end_example

#+begin_src R :results output :session :exports both
ptm <- proc.time()
library(gmp)


system.time(k <- read.csv("Moca-benchmark-fgemm-2016-05-06_18-00-50/Moca-framesoc.csv", header=T));
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

# Use bigz to parse
k$Address <- as.bigz(paste("0x", k$Address, sep=""))
k$Phy <- NULL;
k$CPU <- NULL;
k$Duration <- k$End - k$Start
head(k);
str(k)

# Add structure info
structs <- read.csv("Moca-benchmark-fgemm-2016-05-06_18-00-50/structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize", "BackTrace");
structs$AddressStart <- as.bigz(structs$AddressStart)
structs$AddressSize <- as.bigz(structs$AddressSize)
structs$AddressEnd <- structs$AddressStart + structs$AddressSize
head(structs)
# Filter interesting data structure as soon as possible
# The following line is specific to matrix, adapt it for other analysis
# structs <- structs[!grepl("thread",structs$Structure),]
str(structs)
show(structs)

# Retrieve struct infos
nrow(k)
# These lines are specific to matrix, adapt it for other analysis
minA <- structs[1,2] # I'm only interested on the givaro structs
maxA <- structs[5,5];
proc.time() - ptm
show(minA)
show(maxA)
nrow(k)
#+end_src

#+RESULTS:
#+begin_example
   user  system elapsed 
147.060   4.828 157.618
            X.Virt            X.Phy Nreads Nwrites CPUMask Start End TaskId
1 0000000000400040 000062000b0d1560      1       0  100000     1 236      0
2 0000000000400040 000062000b0d1560      1       0  100000   236 238      0
3 0000000000400270 000062000b0d1560      1       0   10110   236 238      2
4 0000000000400270 000062000b0d1560      1       0   10110   238 239      2
5 0000000000400270 000062000b0d1560      1       0   10110   239 239      2
6 0000000000400270 000062000b0d1560      1       0  100000   239 239      0
  Shared
1      1
2      2
3      2
4      1
5      2
6      2
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
  Address Reads Writes Start End Tid N Duration
1 4194368     1      0     1 236   0 1      235
2 4194368     1      0   236 238   0 2        2
3 4194928     1      0   236 238   2 2        2
4 4194928     1      0   238 239   2 1        1
5 4194928     1      0   239 239   2 2        0
6 4194928     1      0   239 239   0 2        0
'data.frame':	39824448 obs. of  8 variables:
 $ Address :Class 'bigz'  raw [1:637189564] 40 ac 5f 02 ...
 $ Reads   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes  : int  0 0 0 0 0 0 0 0 0 0 ...
 $ Start   : int  1 236 236 238 239 239 239 239 239 8444 ...
 $ End     : int  236 238 238 239 239 239 8444 8444 8444 15658 ...
 $ Tid     : int  0 0 2 2 2 0 2 0 3 2 ...
 $ N       : int  1 2 2 1 2 2 3 3 3 2 ...
 $ Duration: int  235 2 2 1 0 0 8205 8205 8205 7214 ...
                          Structure         AddressStart AddressSize
1                          calloc#0              6549504        4096
2                          malloc#2              6595792        4096
3                          malloc#3              6602160        4096
4                          malloc#4              6608528        4096
5                          malloc#1              6559312       32816
6 _ZN6Givaro12BlocFreeList7TabSizeE 18446744073570310144        4096
                                                                                                                                                                                                  BackTrace
1                                          moca.so:0x7ffff77dad9b:0x7ffff77daaac/libc.so.6:0x7ffff5ec740c/libquadmath.so.0:0x7ffff5505432/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
2         moca.so:0x7ffff77dad9b:0x7ffff77da9bd/libstdc++.so.6:0x7ffff6bcb2e8:0x7ffff6bcb399/libgivaro.so.8:0x7ffff731b8ae:0x7ffff7311c06/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
3         moca.so:0x7ffff77dad9b:0x7ffff77da9bd/libstdc++.so.6:0x7ffff6bcb2e8:0x7ffff6bcb399/libgivaro.so.8:0x7ffff731b8bc:0x7ffff7311c06/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
4         moca.so:0x7ffff77dad9b:0x7ffff77da9bd/libstdc++.so.6:0x7ffff6bcb2e8:0x7ffff6bcb399/libgivaro.so.8:0x7ffff731b8ca:0x7ffff7311c06/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
5 moca.so:0x7ffff77dad9b:0x7ffff77da9bd/libc.so.6:0x7ffff5f2c601:0x7ffff5f5dbf6:0x7ffff5f32830/libgomp.so.1:0x7ffff66647b0:0x7ffff6659d2d/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
6                                                                                                                                                                                                      <NA>
            AddressEnd
1              6553600
2              6599888
3              6606256
4              6612624
5              6592128
6 18446744073570314240
'data.frame':	18 obs. of  5 variables:
 $ Structure   : Factor w/ 18 levels "calloc#0","__GI___pthread_keys",..: 1 4 5 6 3 11 10 18 17 2 ...
 $ AddressStart:Class 'bigz'  raw [1:272] 12 00 00 00 ...
 $ AddressSize :Class 'bigz'  raw [1:220] 12 00 00 00 ...
 $ BackTrace   : Factor w/ 5 levels "moca.so:0x7ffff77dad9b:0x7ffff77da9bd/libc.so.6:0x7ffff5f2c601:0x7ffff5f5dbf6:0x7ffff5f32830/libgomp.so.1:0x7ffff66647b0:0x7fff"| __truncated__,..: 5 2 3 4 1 NA NA NA NA NA ...
 $ AddressEnd  :Class 'bigz'  raw [1:272] 12 00 00 00 ...
                           Structure         AddressStart AddressSize
1                           calloc#0              6549504        4096
2                           malloc#2              6595792        4096
3                           malloc#3              6602160        4096
4                           malloc#4              6608528        4096
5                           malloc#1              6559312       32816
6  _ZN6Givaro12BlocFreeList7TabSizeE 18446744073570310144        4096
7  _ZN6Givaro12BlocFreeList7TabFreeE 18446744073572616192        4096
8             _ZN6GivaroL9SortedAllE 18446744073572620288        4096
9                   _ZN6GivaroL3AllE 18446744073572624384        8192
10               __GI___pthread_keys 18446744073554669568       16384
11                    __pthread_keys 18446744073554669568       16384
12      _ZN6Givaro8Primes167_primesE 18446744073570314240       52336
13     _ZN6Givaro8AdicSize8qadic_64E 18446744073570367488       31752
14     _ZN6Givaro8AdicSize8n_max_64E 18446744073570398208       31752
15     _ZN6Givaro8AdicSize8qadic_53E 18446744073570430976       11088
16     _ZN6Givaro8AdicSize8n_max_53E 18446744073570441216       11088
17       _ZN6Givaro11IntPrimeDom2IPE 18446744073572589568       14068
18      _ZN6Givaro11IntPrimeDom3IP2E 18446744073572603904       12144
                                                                                                                                                                                                   BackTrace
1                                           moca.so:0x7ffff77dad9b:0x7ffff77daaac/libc.so.6:0x7ffff5ec740c/libquadmath.so.0:0x7ffff5505432/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
2          moca.so:0x7ffff77dad9b:0x7ffff77da9bd/libstdc++.so.6:0x7ffff6bcb2e8:0x7ffff6bcb399/libgivaro.so.8:0x7ffff731b8ae:0x7ffff7311c06/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
3          moca.so:0x7ffff77dad9b:0x7ffff77da9bd/libstdc++.so.6:0x7ffff6bcb2e8:0x7ffff6bcb399/libgivaro.so.8:0x7ffff731b8bc:0x7ffff7311c06/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
4          moca.so:0x7ffff77dad9b:0x7ffff77da9bd/libstdc++.so.6:0x7ffff6bcb2e8:0x7ffff6bcb399/libgivaro.so.8:0x7ffff731b8ca:0x7ffff7311c06/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
5  moca.so:0x7ffff77dad9b:0x7ffff77da9bd/libc.so.6:0x7ffff5f2c601:0x7ffff5f5dbf6:0x7ffff5f32830/libgomp.so.1:0x7ffff66647b0:0x7ffff6659d2d/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
6                                                                                                                                                                                                       <NA>
7                                                                                                                                                                                                       <NA>
8                                                                                                                                                                                                       <NA>
9                                                                                                                                                                                                       <NA>
10                                                                                                                                                                                                      <NA>
11                                                                                                                                                                                                      <NA>
12                                                                                                                                                                                                      <NA>
13                                                                                                                                                                                                      <NA>
14                                                                                                                                                                                                      <NA>
15                                                                                                                                                                                                      <NA>
16                                                                                                                                                                                                      <NA>
17                                                                                                                                                                                                      <NA>
18                                                                                                                                                                                                      <NA>
             AddressEnd
1               6553600
2               6599888
3               6606256
4               6612624
5               6592128
6  18446744073570314240
7  18446744073572620288
8  18446744073572624384
9  18446744073572632576
10 18446744073554685952
11 18446744073554685952
12 18446744073570366576
13 18446744073570399240
14 18446744073570429960
15 18446744073570442064
16 18446744073570452304
17 18446744073572603636
18 18446744073572616048
[1] 39824448
   user  system elapsed 
 209.90   11.32  245.20
Big Integer ('bigz') :
[1] 6549504
Big Integer ('bigz') :
[1] 6592128
[1] 39824448
#+end_example

Same as yesterday: slow and heavy but it works ...

#+begin_src R :results output :session :exports both
#system.time(l <- subset(k, k$Address >= minA & k$Address <= maxA));
system.time(l <- k[which(k$Address >= minA & k$Address <= maxA),]);
#head(l)
str(l)
nrow(l)
#+end_src

#+RESULTS:
#+begin_example
   user  system elapsed 
  0.264   0.176   0.440 
Warning messages:
1: In Ops.factor(k$Address, minA) : ‘>=’ not meaningful for factors
2: In Ops.factor(k$Address, maxA) : ‘<=’ not meaningful for factors
'data.frame':	0 obs. of  8 variables:
 $ Address : Factor w/ 32288 levels "0000000000400040",..: 
 $ Reads   : int 
 $ Writes  : int 
 $ Start   : int 
 $ End     : int 
 $ Tid     : int 
 $ N       : int 
 $ Duration: int
[1] 0
#+end_example

Most accesses are between the malloc'ed structures and the others, I
guess something on the computation of dynamic library structures ...

* 2016-05-12 fflas-fgemm                                              :David:

There was some issue on the external library adresses computation due
to unsafe operations between integer and long integer ...

As usual the archive is on ligcloud:

https://ligcloud.imag.fr/public.php?service=files&t=01e8c0d900b6092ab7f8c6925e98db3a

#+begin_src sh :results output :exports both :session
md5sum fgemm.tgz
#+end_src

#+RESULTS:
: 7f7106d3aa4cdc43765682e5a6ab5f41  fgemm.tgz


#+begin_src sh :results output :exports both :session
cd Moca-benchmark-fgemm-2016-05-12_13-32-51
# Already done on grid5000 (requires a huge amount of memory)
#~/Work/Moca/src/utils/create_event_producer.sh 4096 Moca-full-trace.csv
head Moca-framesoc.csv
sort -n -t',' -k2 structs.csv | \
awk -F , 'BEGIN{p="";cpt=1} {if(p==$1){n=$1"-"cpt;cpt++}\
else{cpt=1;n=$1};p=$1;print n","$2","$3","$4}'  > structs-uniq.csv
head  structs-uniq.csv
#+end_src

#+RESULTS:
#+begin_example
@Virt,@Phy,Nreads,Nwrites,CPUMask,Start,End,TaskId,Shared
0000000000400040,000062000285ea70,1,0,000001011,1,231,0,1
0000000000400270,000062000285ea70,1,0,000000011,233,238,2,1
0000000000400270,000062000285ea70,1,0,000000011,238,8429,2,2
0000000000400270,000062000285ea70,1,0,001000011,238,8429,4,2
0000000000400270,000062000285ea70,1,0,000000011,8429,9716,2,3
0000000000400270,000062000285ea70,1,0,001000011,8429,9716,4,3
000000000040049d,000062000285ea70,1,0,000001011,8429,9716,0,3
0000000000400270,000062000285ea70,1,0,000000011,9716,26187,2,2
000000000040049d,000062000285ea70,1,0,000001011,9716,26187,0,2
name,addr,size,backtrace
calloc#0,6549504,4096,moca.so:0x7ffff77dad9d:0x7ffff77daaac/libc.so.6:0x7ffff5ec740c/libquadmath.so.0:0x7ffff5505432/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
malloc#2,6595792,4096,moca.so:0x7ffff77dad9d:0x7ffff77da9bd/libstdc++.so.6:0x7ffff6bcb2e8:0x7ffff6bcb399/libgivaro.so.8:0x7ffff731b8ae:0x7ffff7311c06/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
malloc#3,6602160,4096,moca.so:0x7ffff77dad9d:0x7ffff77da9bd/libstdc++.so.6:0x7ffff6bcb2e8:0x7ffff6bcb399/libgivaro.so.8:0x7ffff731b8bc:0x7ffff7311c06/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
malloc#4,6608528,4096,moca.so:0x7ffff77dad9d:0x7ffff77da9bd/libstdc++.so.6:0x7ffff6bcb2e8:0x7ffff6bcb399/libgivaro.so.8:0x7ffff731b8ca:0x7ffff7311c06/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
malloc#1,6559312,32816,moca.so:0x7ffff77dad9d:0x7ffff77da9bd/libc.so.6:0x7ffff5f2c601:0x7ffff5f5dbf6:0x7ffff5f32830/libgomp.so.1:0x7ffff66647b0:0x7ffff6659d2d/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
_ZN6Givaro12BlocFreeList7TabSizeE,140737349113024,4096,NA
_ZN6Givaro12BlocFreeList7TabFreeE,140737351420288,4096,NA
_ZN6GivaroL9SortedAllE,140737351424640,4096,NA
_ZN6GivaroL3AllE,140737351428736,8192,NA
#+end_example

#+begin_src R :results output :session :exports both
ptm <- proc.time()
library(gmp)


system.time(k <- read.csv("Moca-benchmark-fgemm-2016-05-12_13-32-51/Moca-framesoc.csv", header=T));
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

# Use bigz to parse
k$Address <- as.bigz(paste("0x", k$Address, sep=""))
k$Phy <- NULL;
k$CPU <- NULL;
k$Duration <- k$End - k$Start
head(k);
str(k)

# Add structure info
structs <- read.csv("Moca-benchmark-fgemm-2016-05-12_13-32-51/structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize", "BackTrace");
structs$AddressStart <- as.bigz(structs$AddressStart)
structs$AddressSize <- as.bigz(structs$AddressSize)
structs$AddressEnd <- structs$AddressStart + structs$AddressSize
head(structs)
# Filter interesting data structure as soon as possible
# The following line is specific to matrix, adapt it for other analysis
# structs <- structs[!grepl("thread",structs$Structure),]
str(structs)
show(structs)

# Retrieve struct infos
nrow(k)
# These lines are specific to matrix, adapt it for other analysis
minA <- structs[1,2]
maxA <- structs[nrow(structs),5];
proc.time() - ptm
show(minA)
show(maxA)
nrow(k)
#+end_src

#+RESULTS:
#+begin_example
   user  system elapsed 
 100.68    2.16  102.95
            X.Virt            X.Phy Nreads Nwrites CPUMask Start  End TaskId
1 0000000000400040 000062000285ea70      1       0    1011     1  231      0
2 0000000000400270 000062000285ea70      1       0      11   233  238      2
3 0000000000400270 000062000285ea70      1       0      11   238 8429      2
4 0000000000400270 000062000285ea70      1       0 1000011   238 8429      4
5 0000000000400270 000062000285ea70      1       0      11  8429 9716      2
6 0000000000400270 000062000285ea70      1       0 1000011  8429 9716      4
  Shared
1      1
2      1
3      2
4      2
5      3
6      3
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
  Address Reads Writes Start  End Tid N Duration
1 4194368     1      0     1  231   0 1      230
2 4194928     1      0   233  238   2 1        5
3 4194928     1      0   238 8429   2 2     8191
4 4194928     1      0   238 8429   4 2     8191
5 4194928     1      0  8429 9716   2 3     1287
6 4194928     1      0  8429 9716   4 3     1287
'data.frame':	26757413 obs. of  8 variables:
 $ Address :Class 'bigz'  raw [1:428117432] 25 49 98 01 ...
 $ Reads   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes  : int  0 0 0 0 0 0 0 0 0 0 ...
 $ Start   : int  1 233 238 238 8429 8429 8429 9716 9716 26187 ...
 $ End     : int  231 238 8429 8429 9716 9716 9716 26187 26187 26212 ...
 $ Tid     : int  0 2 2 4 2 4 0 2 0 0 ...
 $ N       : int  1 1 2 2 3 3 3 2 2 1 ...
 $ Duration: int  230 5 8191 8191 1287 1287 1287 16471 16471 25 ...
                          Structure    AddressStart AddressSize
1                          calloc#0         6549504        4096
2                          malloc#2         6595792        4096
3                          malloc#3         6602160        4096
4                          malloc#4         6608528        4096
5                          malloc#1         6559312       32816
6 _ZN6Givaro12BlocFreeList7TabSizeE 140737349113024        4096
                                                                                                                                                                                                  BackTrace
1                                          moca.so:0x7ffff77dad9d:0x7ffff77daaac/libc.so.6:0x7ffff5ec740c/libquadmath.so.0:0x7ffff5505432/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
2         moca.so:0x7ffff77dad9d:0x7ffff77da9bd/libstdc++.so.6:0x7ffff6bcb2e8:0x7ffff6bcb399/libgivaro.so.8:0x7ffff731b8ae:0x7ffff7311c06/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
3         moca.so:0x7ffff77dad9d:0x7ffff77da9bd/libstdc++.so.6:0x7ffff6bcb2e8:0x7ffff6bcb399/libgivaro.so.8:0x7ffff731b8bc:0x7ffff7311c06/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
4         moca.so:0x7ffff77dad9d:0x7ffff77da9bd/libstdc++.so.6:0x7ffff6bcb2e8:0x7ffff6bcb399/libgivaro.so.8:0x7ffff731b8ca:0x7ffff7311c06/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
5 moca.so:0x7ffff77dad9d:0x7ffff77da9bd/libc.so.6:0x7ffff5f2c601:0x7ffff5f5dbf6:0x7ffff5f32830/libgomp.so.1:0x7ffff66647b0:0x7ffff6659d2d/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
6                                                                                                                                                                                                      <NA>
       AddressEnd
1         6553600
2         6599888
3         6606256
4         6612624
5         6592128
6 140737349117120
'data.frame':	18 obs. of  5 variables:
 $ Structure   : Factor w/ 18 levels "__GI___pthread_keys",..: 14 16 17 18 15 6 5 13 12 1 ...
 $ AddressStart:Class 'bigz'  raw [1:272] 12 00 00 00 ...
 $ AddressSize :Class 'bigz'  raw [1:220] 12 00 00 00 ...
 $ BackTrace   : Factor w/ 5 levels "moca.so:0x7ffff77dad9d:0x7ffff77da9bd/libc.so.6:0x7ffff5f2c601:0x7ffff5f5dbf6:0x7ffff5f32830/libgomp.so.1:0x7ffff66647b0:0x7fff"| __truncated__,..: 5 2 3 4 1 NA NA NA NA NA ...
 $ AddressEnd  :Class 'bigz'  raw [1:272] 12 00 00 00 ...
                           Structure    AddressStart AddressSize
1                           calloc#0         6549504        4096
2                           malloc#2         6595792        4096
3                           malloc#3         6602160        4096
4                           malloc#4         6608528        4096
5                           malloc#1         6559312       32816
6  _ZN6Givaro12BlocFreeList7TabSizeE 140737349113024        4096
7  _ZN6Givaro12BlocFreeList7TabFreeE 140737351420288        4096
8             _ZN6GivaroL9SortedAllE 140737351424640        4096
9                   _ZN6GivaroL3AllE 140737351428736        8192
10               __GI___pthread_keys 140737333474016       16384
11                    __pthread_keys 140737333474016       16384
12      _ZN6Givaro8Primes167_primesE 140737349118272       52336
13     _ZN6Givaro8AdicSize8qadic_64E 140737349170624       31752
14     _ZN6Givaro8AdicSize8n_max_64E 140737349202432       31752
15     _ZN6Givaro8AdicSize8qadic_53E 140737349234240       11088
16     _ZN6Givaro8AdicSize8n_max_53E 140737349245376       11088
17       _ZN6Givaro11IntPrimeDom2IPE 140737351393728       14068
18      _ZN6Givaro11IntPrimeDom3IP2E 140737351407808       12144
                                                                                                                                                                                                   BackTrace
1                                           moca.so:0x7ffff77dad9d:0x7ffff77daaac/libc.so.6:0x7ffff5ec740c/libquadmath.so.0:0x7ffff5505432/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
2          moca.so:0x7ffff77dad9d:0x7ffff77da9bd/libstdc++.so.6:0x7ffff6bcb2e8:0x7ffff6bcb399/libgivaro.so.8:0x7ffff731b8ae:0x7ffff7311c06/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
3          moca.so:0x7ffff77dad9d:0x7ffff77da9bd/libstdc++.so.6:0x7ffff6bcb2e8:0x7ffff6bcb399/libgivaro.so.8:0x7ffff731b8bc:0x7ffff7311c06/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
4          moca.so:0x7ffff77dad9d:0x7ffff77da9bd/libstdc++.so.6:0x7ffff6bcb2e8:0x7ffff6bcb399/libgivaro.so.8:0x7ffff731b8ca:0x7ffff7311c06/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
5  moca.so:0x7ffff77dad9d:0x7ffff77da9bd/libc.so.6:0x7ffff5f2c601:0x7ffff5f5dbf6:0x7ffff5f32830/libgomp.so.1:0x7ffff66647b0:0x7ffff6659d2d/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
6                                                                                                                                                                                                       <NA>
7                                                                                                                                                                                                       <NA>
8                                                                                                                                                                                                       <NA>
9                                                                                                                                                                                                       <NA>
10                                                                                                                                                                                                      <NA>
11                                                                                                                                                                                                      <NA>
12                                                                                                                                                                                                      <NA>
13                                                                                                                                                                                                      <NA>
14                                                                                                                                                                                                      <NA>
15                                                                                                                                                                                                      <NA>
16                                                                                                                                                                                                      <NA>
17                                                                                                                                                                                                      <NA>
18                                                                                                                                                                                                      <NA>
        AddressEnd
1          6553600
2          6599888
3          6606256
4          6612624
5          6592128
6  140737349117120
7  140737351424384
8  140737351428736
9  140737351436928
10 140737333490400
11 140737333490400
12 140737349170608
13 140737349202376
14 140737349234184
15 140737349245328
16 140737349256464
17 140737351407796
18 140737351419952
[1] 26757413
   user  system elapsed 
142.800   4.424 149.528
Big Integer ('bigz') :
[1] 6549504
Big Integer ('bigz') :
[1] 140737351419952
[1] 26757413
#+end_example

Same as usual slow and heavy but it works ...

#+begin_src R :results output :session :exports both
#system.time(l <- subset(k, k$Address >= minA & k$Address <= maxA));
system.time(l <- k[which(k$Address >= minA & k$Address <= maxA),]);
#head(l)
str(l)
nrow(l)
#+end_src

#+RESULTS:
#+begin_example
   user  system elapsed 
 31.808   3.556  42.115
'data.frame':	26757213 obs. of  8 variables:
 $ Address :Class 'bigz'  raw [1:428114452] 5d 48 98 01 ...
 $ Reads   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes  : int  1 1 1 1 1 1 1 1 1 0 ...
 $ Start   : int  1 1 1 1 1 1 1 1 233 6306353 ...
 $ End     : int  231 231 231 231 231 231 231 231 26187 8540855 ...
 $ Tid     : int  0 0 0 0 0 0 0 0 2 0 ...
 $ N       : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Duration: int  230 230 230 230 230 230 230 230 25954 2234502 ...
[1] 26757213
#+end_example

So far so good, let's continue

#+begin_src R :results output :session :exports both
ptm <- proc.time()

# Compute accesses type

m <- l
system.time(m$aType <- ifelse(m$Write >0,"Write", "Read"));
system.time(m$sType <- ifelse(m$N > 1,"Shared","Private"));
system.time(m$Type <- paste(m$sType,m$aType,sep="_"));
m$sType <- NULL
m$aType <- NULL
head(m)

# Compute data structure name and offset
n <- m
structs$BackTrace <- NULL
head(structs)
getStructReverse <- function (vect){
  name <- 1
  start <- 2
  end <- 4
  return (ifelse(n$Address >= vect[start] & n$Address <= vect[end],
                paste(vect[name],as.bigz(n$Address) - as.bigz(vect[start]),sep="@"),""));
}
system.time(ans <- as.data.frame(apply(structs,1,getStructReverse)))
system.time(vect <- apply(ans,1,paste,collapse=""));
#str(vect)
system.time(vect <- strsplit(vect,"@"))
#str(vect)
system.time(n$Structure <- unlist(lapply(vect,"[",1)))
system.time(n$Offset <- as.integer(unlist(lapply(vect,"[",2))));
#str(n)
head(n)
nrow(n)

# Aggregate
system.time(o <- aggregate(n[,c('Reads','Writes', 'N')],n[,c('Structure','Offset', 'Type', 'Start', 'End')], function(d) sum(d)));
str(o)
head(o)

proc.time() - ptm
#+end_src

#+RESULTS:
#+begin_example
   user  system elapsed 
  5.760   0.012   5.777
   user  system elapsed 
  5.852   0.000   5.852
   user  system elapsed 
  4.456   0.004   4.468
   Address Reads Writes Start End Tid N Duration          Type
56 6549504     1      1     1 231   0 1      230 Private_Write
57 6553608     1      1     1 231   0 1      230 Private_Write
58 6563976     1      1     1 231   0 1      230 Private_Write
59 6573560     1      1     1 231   0 1      230 Private_Write
60 6574088     1      1     1 231   0 1      230 Private_Write
61 6579192     1      1     1 231   0 1      230 Private_Write
                          Structure    AddressStart AddressSize      AddressEnd
1                          calloc#0         6549504        4096         6553600
2                          malloc#2         6595792        4096         6599888
3                          malloc#3         6602160        4096         6606256
4                          malloc#4         6608528        4096         6612624
5                          malloc#1         6559312       32816         6592128
6 _ZN6Givaro12BlocFreeList7TabSizeE 140737349113024        4096 140737349117120
   user  system elapsed 
 735.29   71.86 1033.03
   user  system elapsed 
  364.4   158.0  1721.5
   user  system elapsed 
  2.288   0.020   2.308
   user  system elapsed 
  31.41    0.30   31.75
   user  system elapsed 
 14.836   0.288  15.179
   Address Reads Writes Start End Tid N Duration          Type Structure Offset
56 6549504     1      1     1 231   0 1      230 Private_Write  calloc#0      0
57 6553608     1      1     1 231   0 1      230 Private_Write      <NA>     NA
58 6563976     1      1     1 231   0 1      230 Private_Write  malloc#1   4664
59 6573560     1      1     1 231   0 1      230 Private_Write  malloc#1  14248
60 6574088     1      1     1 231   0 1      230 Private_Write  malloc#1  14776
61 6579192     1      1     1 231   0 1      230 Private_Write  malloc#1  19880
[1] 26757213
   user  system elapsed 
  0.836   0.220   1.997
'data.frame':	92 obs. of  8 variables:
 $ Structure: chr  "_ZN6Givaro8AdicSize8n_max_64E" "_ZN6Givaro8AdicSize8n_max_64E" "calloc#0" "malloc#1" ...
 $ Offset   : int  20744 20744 0 4664 7824 14248 14776 19880 21040 23992 ...
 $ Type     : chr  "Private_Read" "Private_Read" "Private_Write" "Private_Write" ...
 $ Start    : int  1 1 1 1 1 1 1 1 1 1 ...
 $ End      : int  1 231 231 231 231 231 231 231 231 231 ...
 $ Reads    : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes   : int  0 0 1 1 1 1 1 1 1 1 ...
 $ N        : int  1 1 1 1 1 1 1 1 1 1 ...
                      Structure Offset          Type Start End Reads Writes N
1 _ZN6Givaro8AdicSize8n_max_64E  20744  Private_Read     1   1     1      0 1
2 _ZN6Givaro8AdicSize8n_max_64E  20744  Private_Read     1 231     1      0 1
3                      calloc#0      0 Private_Write     1 231     1      1 1
4                      malloc#1   4664 Private_Write     1 231     1      1 1
5 _ZN6Givaro8AdicSize8n_max_53E   7824 Private_Write     1 231     1      1 1
6                      malloc#1  14248 Private_Write     1 231     1      1 1
   user  system elapsed 
 1198.3   241.6  2920.8
#+end_example

There are a lots of datastructure here, let's start by finding the
interesting ones in terms of sharing:

#+begin_src R :results output graphics :file img/struct_importance_share_fgemm.png :exports both :width 600 :height 400 :session
library(plyr)
q <- ddply(o,.(Structure),summarize,Share=sum(N),Nacc=sum(Reads+Writes))
library(ggplot2);
p <- ggplot(q,aes(x=Structure,y=Share, fill=Structure)) +
  geom_bar(stat="identity") +
  theme_bw() +
  theme(panel.grid.minor = element_line(colour = "black", linetype="dashed", size = 0.1),
    panel.grid.major = element_line(colour = "black", size = 0.1)) +
  scale_y_log10()
  #lab=("Data structure name") +
  #ylab=("Number of accesses") +
p
#+end_src

#+RESULTS:
[[file:img/struct_importance_share_fgemm.png]]


and in terms of number of accesses:

#+begin_src R :results output graphics :file img/struct_importance_nacc_fgemm.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(q,aes(x=Structure,y=Nacc, fill=Structure)) +
  geom_bar(stat="identity") +
  theme_bw() +
  theme(panel.grid.minor = element_line(colour = "black", linetype="dashed", size = 0.1),
    panel.grid.major = element_line(colour = "black", size = 0.1)) +
  scale_y_log10()
  #lab=("Data structure name") +
  #ylab=("Number of accesses") +
p
#+end_src

#+RESULTS:
[[file:img/struct_importance_nacc_fgemm.png]]

This is not a lot of accesses, I thinks there might be some issues during
the aggregation (R code) ...

#+begin_src R :results output graphics :file img/intensity_Rw_fgemm.png :exports both :width 600 :height 400 :session
r <- o[grep("(malloc#1|malloc#2|malloc#4|64E)",o$Structure),]
library(ggplot2);
p <- ggplot(r) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Offset,yend=Offset, color=Reads+Writes)) +
  facet_grid(Structure~Type, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_Rw_fgemm.png]]


So we don't see a lot of things here, I really think that there is
some issue with the aggregation phase ...
* 2016-05-23 Another try on fflas-fgemm                               :David:
** Issue in my R ?

I'm working on the same trace as on may 12th. Just trying to see if
the issue is indeed in my R code. I'm suspecting something on the
aggregate call.
As there is a huge gap between the malloc'ed addresses, I have added a
minA1 and minA2 to delimit the two parts.

#+begin_src R :results output :session :exports both
ptm <- proc.time()
library(gmp)


system.time(k <- read.csv("Moca-benchmark-fgemm-2016-05-12_13-32-51/Moca-framesoc.csv", header=T));
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

# Use bigz to parse
k$Address <- as.bigz(paste("0x", k$Address, sep=""))
k$Phy <- NULL;
k$CPU <- NULL;
k$Duration <- k$End - k$Start
head(k);
str(k)

# Add structure info
structs <- read.csv("Moca-benchmark-fgemm-2016-05-12_13-32-51/structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize", "BackTrace");
structs$AddressStart <- as.bigz(structs$AddressStart)
structs$AddressSize <- as.bigz(structs$AddressSize)
structs$AddressEnd <- structs$AddressStart + structs$AddressSize
head(structs)
# Filter interesting data structure as soon as possible
# The following line is specific to matrix, adapt it for other analysis
# structs <- structs[!grepl("thread",structs$Structure),]
str(structs)
show(structs)

# Retrieve struct infos
nrow(k)
# These lines are specific to matrix, adapt it for other analysis
minA1 <- structs[1,2]
maxA1 <- structs[5,5];
minA2 <- structs[6,2]
maxA2 <- structs[nrow(structs),5];
proc.time() - ptm
show(minA1)
show(maxA1)
show(minA2)
show(maxA2)
nrow(k)
#+end_src

#+RESULTS:
#+begin_example

Attaching package: ‘gmp’

The following objects are masked from ‘package:base’:

    %*%, apply, crossprod, matrix, tcrossprod
   user  system elapsed 
102.268   2.264 104.971
            X.Virt            X.Phy Nreads Nwrites CPUMask Start  End TaskId
1 0000000000400040 000062000285ea70      1       0    1011     1  231      0
2 0000000000400270 000062000285ea70      1       0      11   233  238      2
3 0000000000400270 000062000285ea70      1       0      11   238 8429      2
4 0000000000400270 000062000285ea70      1       0 1000011   238 8429      4
5 0000000000400270 000062000285ea70      1       0      11  8429 9716      2
6 0000000000400270 000062000285ea70      1       0 1000011  8429 9716      4
  Shared
1      1
2      1
3      2
4      2
5      3
6      3
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
  Address Reads Writes Start  End Tid N Duration
1 4194368     1      0     1  231   0 1      230
2 4194928     1      0   233  238   2 1        5
3 4194928     1      0   238 8429   2 2     8191
4 4194928     1      0   238 8429   4 2     8191
5 4194928     1      0  8429 9716   2 3     1287
6 4194928     1      0  8429 9716   4 3     1287
'data.frame':	26757413 obs. of  8 variables:
 $ Address :Class 'bigz'  raw [1:428117432] 25 49 98 01 ...
 $ Reads   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes  : int  0 0 0 0 0 0 0 0 0 0 ...
 $ Start   : int  1 233 238 238 8429 8429 8429 9716 9716 26187 ...
 $ End     : int  231 238 8429 8429 9716 9716 9716 26187 26187 26212 ...
 $ Tid     : int  0 2 2 4 2 4 0 2 0 0 ...
 $ N       : int  1 1 2 2 3 3 3 2 2 1 ...
 $ Duration: int  230 5 8191 8191 1287 1287 1287 16471 16471 25 ...
                          Structure    AddressStart AddressSize
1                          calloc#0         6549504        4096
2                          malloc#2         6595792        4096
3                          malloc#3         6602160        4096
4                          malloc#4         6608528        4096
5                          malloc#1         6559312       32816
6 _ZN6Givaro12BlocFreeList7TabSizeE 140737349113024        4096
                                                                                                                                                                                                  BackTrace
1                                          moca.so:0x7ffff77dad9d:0x7ffff77daaac/libc.so.6:0x7ffff5ec740c/libquadmath.so.0:0x7ffff5505432/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
2         moca.so:0x7ffff77dad9d:0x7ffff77da9bd/libstdc++.so.6:0x7ffff6bcb2e8:0x7ffff6bcb399/libgivaro.so.8:0x7ffff731b8ae:0x7ffff7311c06/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
3         moca.so:0x7ffff77dad9d:0x7ffff77da9bd/libstdc++.so.6:0x7ffff6bcb2e8:0x7ffff6bcb399/libgivaro.so.8:0x7ffff731b8bc:0x7ffff7311c06/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
4         moca.so:0x7ffff77dad9d:0x7ffff77da9bd/libstdc++.so.6:0x7ffff6bcb2e8:0x7ffff6bcb399/libgivaro.so.8:0x7ffff731b8ca:0x7ffff7311c06/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
5 moca.so:0x7ffff77dad9d:0x7ffff77da9bd/libc.so.6:0x7ffff5f2c601:0x7ffff5f5dbf6:0x7ffff5f32830/libgomp.so.1:0x7ffff66647b0:0x7ffff6659d2d/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
6                                                                                                                                                                                                      <NA>
       AddressEnd
1         6553600
2         6599888
3         6606256
4         6612624
5         6592128
6 140737349117120
'data.frame':	18 obs. of  5 variables:
 $ Structure   : Factor w/ 18 levels "__GI___pthread_keys",..: 14 16 17 18 15 6 5 13 12 1 ...
 $ AddressStart:Class 'bigz'  raw [1:272] 12 00 00 00 ...
 $ AddressSize :Class 'bigz'  raw [1:220] 12 00 00 00 ...
 $ BackTrace   : Factor w/ 5 levels "moca.so:0x7ffff77dad9d:0x7ffff77da9bd/libc.so.6:0x7ffff5f2c601:0x7ffff5f5dbf6:0x7ffff5f32830/libgomp.so.1:0x7ffff66647b0:0x7fff"| __truncated__,..: 5 2 3 4 1 NA NA NA NA NA ...
 $ AddressEnd  :Class 'bigz'  raw [1:272] 12 00 00 00 ...
                           Structure    AddressStart AddressSize
1                           calloc#0         6549504        4096
2                           malloc#2         6595792        4096
3                           malloc#3         6602160        4096
4                           malloc#4         6608528        4096
5                           malloc#1         6559312       32816
6  _ZN6Givaro12BlocFreeList7TabSizeE 140737349113024        4096
7  _ZN6Givaro12BlocFreeList7TabFreeE 140737351420288        4096
8             _ZN6GivaroL9SortedAllE 140737351424640        4096
9                   _ZN6GivaroL3AllE 140737351428736        8192
10               __GI___pthread_keys 140737333474016       16384
11                    __pthread_keys 140737333474016       16384
12      _ZN6Givaro8Primes167_primesE 140737349118272       52336
13     _ZN6Givaro8AdicSize8qadic_64E 140737349170624       31752
14     _ZN6Givaro8AdicSize8n_max_64E 140737349202432       31752
15     _ZN6Givaro8AdicSize8qadic_53E 140737349234240       11088
16     _ZN6Givaro8AdicSize8n_max_53E 140737349245376       11088
17       _ZN6Givaro11IntPrimeDom2IPE 140737351393728       14068
18      _ZN6Givaro11IntPrimeDom3IP2E 140737351407808       12144
                                                                                                                                                                                                   BackTrace
1                                           moca.so:0x7ffff77dad9d:0x7ffff77daaac/libc.so.6:0x7ffff5ec740c/libquadmath.so.0:0x7ffff5505432/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
2          moca.so:0x7ffff77dad9d:0x7ffff77da9bd/libstdc++.so.6:0x7ffff6bcb2e8:0x7ffff6bcb399/libgivaro.so.8:0x7ffff731b8ae:0x7ffff7311c06/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
3          moca.so:0x7ffff77dad9d:0x7ffff77da9bd/libstdc++.so.6:0x7ffff6bcb2e8:0x7ffff6bcb399/libgivaro.so.8:0x7ffff731b8bc:0x7ffff7311c06/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
4          moca.so:0x7ffff77dad9d:0x7ffff77da9bd/libstdc++.so.6:0x7ffff6bcb2e8:0x7ffff6bcb399/libgivaro.so.8:0x7ffff731b8ca:0x7ffff7311c06/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
5  moca.so:0x7ffff77dad9d:0x7ffff77da9bd/libc.so.6:0x7ffff5f2c601:0x7ffff5f5dbf6:0x7ffff5f32830/libgomp.so.1:0x7ffff66647b0:0x7ffff6659d2d/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
6                                                                                                                                                                                                       <NA>
7                                                                                                                                                                                                       <NA>
8                                                                                                                                                                                                       <NA>
9                                                                                                                                                                                                       <NA>
10                                                                                                                                                                                                      <NA>
11                                                                                                                                                                                                      <NA>
12                                                                                                                                                                                                      <NA>
13                                                                                                                                                                                                      <NA>
14                                                                                                                                                                                                      <NA>
15                                                                                                                                                                                                      <NA>
16                                                                                                                                                                                                      <NA>
17                                                                                                                                                                                                      <NA>
18                                                                                                                                                                                                      <NA>
        AddressEnd
1          6553600
2          6599888
3          6606256
4          6612624
5          6592128
6  140737349117120
7  140737351424384
8  140737351428736
9  140737351436928
10 140737333490400
11 140737333490400
12 140737349170608
13 140737349202376
14 140737349234184
15 140737349245328
16 140737349256464
17 140737351407796
18 140737351419952
[1] 26757413
   user  system elapsed 
141.792   6.028 150.519
Big Integer ('bigz') :
[1] 6549504
Big Integer ('bigz') :
[1] 6592128
Big Integer ('bigz') :
[1] 140737349113024
Big Integer ('bigz') :
[1] 140737351419952
[1] 26757413
#+end_example

#+begin_src R :results output :session :exports both
#system.time(l <- subset(k, k$Address >= minA & k$Address <= maxA));
system.time(l <- k[which(k$Address >= minA1 & k$Address <= maxA1 | k$Address >= minA2 & k$Address <= maxA2),]);
#head(l)
str(l)
nrow(l)
#+end_src

#+RESULTS:
#+begin_example
   user  system elapsed 
 35.880   1.812  37.701
'data.frame':	493 obs. of  8 variables:
 $ Address :Class 'bigz'  raw [1:7364] ed 01 00 00 ...
 $ Reads   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes  : int  1 1 1 1 1 1 1 1 1 0 ...
 $ Start   : int  1 1 1 1 1 1 1 1 233 6306353 ...
 $ End     : int  231 231 231 231 231 231 231 231 26187 8540855 ...
 $ Tid     : int  0 0 0 0 0 0 0 0 2 0 ...
 $ N       : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Duration: int  230 230 230 230 230 230 230 230 25954 2234502 ...
[1] 493
#+end_example

So all the accesses are indeed between the malloc and the static
structs, It think I should dig in there later.

For now lets do the same thing as the aggregate with ddply, just to
see if the code is ok:

#+begin_src R :results output :session :exports both
ptm <- proc.time()
library(plyr)

# Compute accesses type

m <- l
system.time(m$aType <- ifelse(m$Write >0,"Write", "Read"));
system.time(m$sType <- ifelse(m$N > 1,"Shared","Private"));
system.time(m$Type <- paste(m$sType,m$aType,sep="_"));
m$sType <- NULL
m$aType <- NULL
head(m)

# Compute data structure name and offset
n <- m
structs$BackTrace <- NULL
head(structs)
getStructReverse <- function (vect){
  name <- 1
  start <- 2
  end <- 4
  return (ifelse(n$Address >= vect[start] & n$Address <= vect[end],
                paste(vect[name],as.bigz(n$Address) - as.bigz(vect[start]),sep="@"),""));
}
system.time(ans <- as.data.frame(apply(structs,1,getStructReverse)))
system.time(vect <- apply(ans,1,paste,collapse=""));
#str(vect)
system.time(vect <- strsplit(vect,"@"))
#str(vect)
system.time(n$Structure <- unlist(lapply(vect,"[",1)))
system.time(n$Offset <- as.integer(unlist(lapply(vect,"[",2))));
#str(n)
head(n)
nrow(n)

# Aggregate
system.time(oo <- aggregate(n[,c('Reads','Writes', 'N')],n[,c('Structure','Offset', 'Type', 'Start', 'End')], function(d) sum(d)));
system.time(o <- ddply(n,c('Structure','Offset', 'Type', 'Start', 'End'),summarize,Reads=sum(Reads),Writes=sum(Writes),N=sum(N)));
str(o)
head(o)
str(oo)
head(oo)

proc.time() - ptm
#+end_src


#+RESULTS:
#+begin_example
   user  system elapsed 
  0.000   0.000   0.001
   user  system elapsed 
  0.000   0.000   0.001
   user  system elapsed 
      0       0       0
   Address Reads Writes Start End Tid N Duration          Type
56 6549504     1      1     1 231   0 1      230 Private_Write
57 6553608     1      1     1 231   0 1      230 Private_Write
58 6563976     1      1     1 231   0 1      230 Private_Write
59 6573560     1      1     1 231   0 1      230 Private_Write
60 6574088     1      1     1 231   0 1      230 Private_Write
61 6579192     1      1     1 231   0 1      230 Private_Write
                          Structure    AddressStart AddressSize      AddressEnd
1                          calloc#0         6549504        4096         6553600
2                          malloc#2         6595792        4096         6599888
3                          malloc#3         6602160        4096         6606256
4                          malloc#4         6608528        4096         6612624
5                          malloc#1         6559312       32816         6592128
6 _ZN6Givaro12BlocFreeList7TabSizeE 140737349113024        4096 140737349117120
   user  system elapsed 
  0.024   0.000   0.027
   user  system elapsed 
  0.004   0.000   0.005
   user  system elapsed 
  0.000   0.000   0.001
   user  system elapsed 
      0       0       0
   user  system elapsed 
      0       0       0
   Address Reads Writes Start End Tid N Duration          Type Structure Offset
56 6549504     1      1     1 231   0 1      230 Private_Write  calloc#0      0
57 6553608     1      1     1 231   0 1      230 Private_Write      <NA>     NA
58 6563976     1      1     1 231   0 1      230 Private_Write  malloc#1   4664
59 6573560     1      1     1 231   0 1      230 Private_Write  malloc#1  14248
60 6574088     1      1     1 231   0 1      230 Private_Write  malloc#1  14776
61 6579192     1      1     1 231   0 1      230 Private_Write  malloc#1  19880
[1] 493
   user  system elapsed 
  0.004   0.000   0.008
   user  system elapsed 
  0.152   0.000   0.153
'data.frame':	283 obs. of  8 variables:
 $ Structure: chr  "_ZN6Givaro8AdicSize8n_max_53E" "_ZN6Givaro8AdicSize8n_max_64E" "_ZN6Givaro8AdicSize8n_max_64E" "_ZN6Givaro8AdicSize8n_max_64E" ...
 $ Offset   : int  7824 20744 20744 20992 20992 20992 20992 20992 20992 20992 ...
 $ Type     : chr  "Private_Write" "Private_Read" "Private_Read" "Private_Read" ...
 $ Start    : int  1 1 1 233 26187 1694889 234 238 8427 8429 ...
 $ End      : int  231 1 231 234 26212 1709204 238 8427 8429 9716 ...
 $ Reads    : int  1 1 1 1 1 1 2 3 2 3 ...
 $ Writes   : int  1 0 0 0 0 0 0 0 0 0 ...
 $ N        : int  1 1 1 1 1 1 4 9 4 9 ...
                      Structure Offset          Type   Start     End Reads
1 _ZN6Givaro8AdicSize8n_max_53E   7824 Private_Write       1     231     1
2 _ZN6Givaro8AdicSize8n_max_64E  20744  Private_Read       1       1     1
3 _ZN6Givaro8AdicSize8n_max_64E  20744  Private_Read       1     231     1
4 _ZN6Givaro8AdicSize8n_max_64E  20992  Private_Read     233     234     1
5 _ZN6Givaro8AdicSize8n_max_64E  20992  Private_Read   26187   26212     1
6 _ZN6Givaro8AdicSize8n_max_64E  20992  Private_Read 1694889 1709204     1
  Writes N
1      1 1
2      0 1
3      0 1
4      0 1
5      0 1
6      0 1
'data.frame':	73 obs. of  8 variables:
 $ Structure: chr  "_ZN6Givaro8AdicSize8n_max_64E" "_ZN6Givaro8AdicSize8n_max_64E" "calloc#0" "malloc#1" ...
 $ Offset   : int  20744 20744 0 4664 7824 14248 14776 19880 21040 23992 ...
 $ Type     : chr  "Private_Read" "Private_Read" "Private_Write" "Private_Write" ...
 $ Start    : int  1 1 1 1 1 1 1 1 1 1 ...
 $ End      : int  1 231 231 231 231 231 231 231 231 231 ...
 $ Reads    : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes   : int  0 0 1 1 1 1 1 1 1 1 ...
 $ N        : int  1 1 1 1 1 1 1 1 1 1 ...
                      Structure Offset          Type Start End Reads Writes N
1 _ZN6Givaro8AdicSize8n_max_64E  20744  Private_Read     1   1     1      0 1
2 _ZN6Givaro8AdicSize8n_max_64E  20744  Private_Read     1 231     1      0 1
3                      calloc#0      0 Private_Write     1 231     1      1 1
4                      malloc#1   4664 Private_Write     1 231     1      1 1
5 _ZN6Givaro8AdicSize8n_max_53E   7824 Private_Write     1 231     1      1 1
6                      malloc#1  14248 Private_Write     1 231     1      1 1
   user  system elapsed 
  0.588   0.000   0.739
#+end_example

Lets reproduce the plots now

#+begin_src R :results output graphics :file img/struct_importance_share_fgemmO.png :exports both :width 600 :height 400 :session
library(plyr)
q <- ddply(o,.(Structure),summarize,Share=sum(N),Nacc=sum(Reads+Writes))
library(ggplot2);
p <- ggplot(q,aes(x=Structure,y=Share, fill=Structure)) +
  geom_bar(stat="identity") +
  theme_bw() +
  theme(panel.grid.minor = element_line(colour = "black", linetype="dashed", size = 0.1),
    panel.grid.major = element_line(colour = "black", size = 0.1)) +
  scale_y_log10()
  #lab=("Data structure name") +
  #ylab=("Number of accesses") +
p
#+end_src

#+RESULTS:
[[file:img/struct_importance_share_fgemmO.png]]

#+begin_src R :results output graphics :file img/struct_importance_share_fgemmOO.png :exports both :width 600 :height 400 :session
library(plyr)
qq <- ddply(oo,.(Structure),summarize,Share=sum(N),Nacc=sum(Reads+Writes))
library(ggplot2);
p <- ggplot(q,aes(x=Structure,y=Share, fill=Structure)) +
  geom_bar(stat="identity") +
  theme_bw() +
  theme(panel.grid.minor = element_line(colour = "black", linetype="dashed", size = 0.1),
    panel.grid.major = element_line(colour = "black", size = 0.1)) +
  scale_y_log10()
  #lab=("Data structure name") +
  #ylab=("Number of accesses") +
p
#+end_src

#+RESULTS:
[[file:img/struct_importance_share_fgemmOO.png]]

So the two data frames seems to be identical for sharing, let see the
number of accesses:

#+begin_src R :results output graphics :file img/struct_importance_nacc_fgemmO.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(q,aes(x=Structure,y=Nacc, fill=Structure)) +
  geom_bar(stat="identity") +
  theme_bw() +
  theme(panel.grid.minor = element_line(colour = "black", linetype="dashed", size = 0.1),
    panel.grid.major = element_line(colour = "black", size = 0.1)) +
  scale_y_log10()
  #lab=("Data structure name") +
  #ylab=("Number of accesses") +
p
#+end_src

#+RESULTS:
[[file:img/struct_importance_nacc_fgemmO.png]]

#+begin_src R :results output graphics :file img/struct_importance_nacc_fgemmOO.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(qq,aes(x=Structure,y=Nacc, fill=Structure)) +
  geom_bar(stat="identity") +
  theme_bw() +
  theme(panel.grid.minor = element_line(colour = "black", linetype="dashed", size = 0.1),
    panel.grid.major = element_line(colour = "black", size = 0.1)) +
  scale_y_log10()
  #lab=("Data structure name") +
  #ylab=("Number of accesses") +
p
#+end_src

#+RESULTS:
[[file:img/struct_importance_nacc_fgemmOO.png]]

Again identical, so I guess there are no issue with the aggregate, I'm
going to dig on the gap between the malloc'ed data structures and the
static ones.

** Exploring the gap 


By looking at the /proc/pid/map files, it seems that my static data
structure detection is fine, so most of the accesses appears to be on
the stacks and the stack detection inside Moca was not complete so I
added a small script to appen the stacks to the struct file. Let's
take a look to the previous trace with the stacks:


#+begin_src sh :results output :exports both :session
cd Moca-benchmark-fgemm-2016-05-12_13-32-51
# Already done on grid5000 (requires a huge amount of memory)
#~/Work/Moca/src/utils/create_event_producer.sh 4096 Moca-full-trace.csv
~/Work/Moca/src/utils/retrieve_stacks.sh stacks.log structs.csv
head Moca-framesoc.csv
sort -n -t',' -k2,2 structs.csv | \
awk -F , 'BEGIN{p="";cpt=1} {if(p==$1){n=$1"-"cpt;cpt++}\
else{cpt=1;n=$1};p=$1;print n","$2","$3","$4}'  > structs-uniq.csv
head  structs-uniq.csv
#+end_src

#+RESULTS:
#+begin_example
@Virt,@Phy,Nreads,Nwrites,CPUMask,Start,End,TaskId,Shared
0000000000400040,000062000285ea70,1,0,000001011,1,231,0,1
0000000000400270,000062000285ea70,1,0,000000011,233,238,2,1
0000000000400270,000062000285ea70,1,0,000000011,238,8429,2,2
0000000000400270,000062000285ea70,1,0,001000011,238,8429,4,2
0000000000400270,000062000285ea70,1,0,000000011,8429,9716,2,3
0000000000400270,000062000285ea70,1,0,001000011,8429,9716,4,3
000000000040049d,000062000285ea70,1,0,000001011,8429,9716,0,3
0000000000400270,000062000285ea70,1,0,000000011,9716,26187,2,2
000000000040049d,000062000285ea70,1,0,000001011,9716,26187,0,2
name,addr,size,backtrace
calloc#0,6549504,4096,moca.so:0x7ffff77dad9d:0x7ffff77daaac/libc.so.6:0x7ffff5ec740c/libquadmath.so.0:0x7ffff5505432/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
malloc#1,6559312,32816,moca.so:0x7ffff77dad9d:0x7ffff77da9bd/libc.so.6:0x7ffff5f2c601:0x7ffff5f5dbf6:0x7ffff5f32830/libgomp.so.1:0x7ffff66647b0:0x7ffff6659d2d/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
malloc#2,6595792,4096,moca.so:0x7ffff77dad9d:0x7ffff77da9bd/libstdc++.so.6:0x7ffff6bcb2e8:0x7ffff6bcb399/libgivaro.so.8:0x7ffff731b8ae:0x7ffff7311c06/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
malloc#3,6602160,4096,moca.so:0x7ffff77dad9d:0x7ffff77da9bd/libstdc++.so.6:0x7ffff6bcb2e8:0x7ffff6bcb399/libgivaro.so.8:0x7ffff731b8bc:0x7ffff7311c06/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
malloc#4,6608528,4096,moca.so:0x7ffff77dad9d:0x7ffff77da9bd/libstdc++.so.6:0x7ffff6bcb2e8:0x7ffff6bcb399/libgivaro.so.8:0x7ffff731b8ca:0x7ffff7311c06/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
stack,140734104526848,135168,NA
stack:1394,140737228918784,8388608,NA
stack:1393,140737237311488,8388608,NA
stack:1392,140737245704192,8388608,NA
#+end_example

Looks good, I had to change the -k2 to -k2,2 to make the sort works,
but now the stacks are here and at the right place. The stacks names
comes directly from the /proc/pid/maps file.

Here we will focus on the stacks as we already now that the rest is
not interesting

#+begin_src R :results output :session :exports both
ptm <- proc.time()
library(gmp)


system.time(k <- read.csv("Moca-benchmark-fgemm-2016-05-12_13-32-51/Moca-framesoc.csv", header=T));
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

# Use bigz to parse
k$Address <- as.bigz(paste("0x", k$Address, sep=""))
k$Phy <- NULL;
k$CPU <- NULL;
k$Duration <- k$End - k$Start
head(k);
str(k)

# Add structure info
structs <- read.csv("Moca-benchmark-fgemm-2016-05-12_13-32-51/structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize", "BackTrace");
structs$AddressStart <- as.bigz(structs$AddressStart)
structs$AddressSize <- as.bigz(structs$AddressSize)
structs$AddressEnd <- structs$AddressStart + structs$AddressSize
head(structs)
# Filter interesting data structure as soon as possible
# The following line is specific to matrix, adapt it for other analysis
 structs <- structs[grepl("stack",structs$Structure),]
str(structs)
show(structs)

# Retrieve struct infos
nrow(k)
# These lines are specific to matrix, adapt it for other analysis
minA <- structs[1,2]
maxA <- structs[nrow(structs),5];
proc.time() - ptm
show(minA)
show(maxA)
nrow(k)
#+end_src

#+RESULTS:
#+begin_example

Attaching package: ‘gmp’

The following objects are masked from ‘package:base’:

    %*%, apply, crossprod, matrix, tcrossprod
   user  system elapsed 
 102.44    1.94  104.44
            X.Virt            X.Phy Nreads Nwrites CPUMask Start  End TaskId
1 0000000000400040 000062000285ea70      1       0    1011     1  231      0
2 0000000000400270 000062000285ea70      1       0      11   233  238      2
3 0000000000400270 000062000285ea70      1       0      11   238 8429      2
4 0000000000400270 000062000285ea70      1       0 1000011   238 8429      4
5 0000000000400270 000062000285ea70      1       0      11  8429 9716      2
6 0000000000400270 000062000285ea70      1       0 1000011  8429 9716      4
  Shared
1      1
2      1
3      2
4      2
5      3
6      3
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
  Address Reads Writes Start  End Tid N Duration
1 4194368     1      0     1  231   0 1      230
2 4194928     1      0   233  238   2 1        5
3 4194928     1      0   238 8429   2 2     8191
4 4194928     1      0   238 8429   4 2     8191
5 4194928     1      0  8429 9716   2 3     1287
6 4194928     1      0  8429 9716   4 3     1287
'data.frame':	26757413 obs. of  8 variables:
 $ Address :Class 'bigz'  raw [1:428117432] 25 49 98 01 ...
 $ Reads   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes  : int  0 0 0 0 0 0 0 0 0 0 ...
 $ Start   : int  1 233 238 238 8429 8429 8429 9716 9716 26187 ...
 $ End     : int  231 238 8429 8429 9716 9716 9716 26187 26187 26212 ...
 $ Tid     : int  0 2 2 4 2 4 0 2 0 0 ...
 $ N       : int  1 1 2 2 3 3 3 2 2 1 ...
 $ Duration: int  230 5 8191 8191 1287 1287 1287 16471 16471 25 ...
  Structure    AddressStart AddressSize
1  calloc#0         6549504        4096
2  malloc#1         6559312       32816
3  malloc#2         6595792        4096
4  malloc#3         6602160        4096
5  malloc#4         6608528        4096
6     stack 140734104526848      135168
                                                                                                                                                                                                  BackTrace
1                                          moca.so:0x7ffff77dad9d:0x7ffff77daaac/libc.so.6:0x7ffff5ec740c/libquadmath.so.0:0x7ffff5505432/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
2 moca.so:0x7ffff77dad9d:0x7ffff77da9bd/libc.so.6:0x7ffff5f2c601:0x7ffff5f5dbf6:0x7ffff5f32830/libgomp.so.1:0x7ffff66647b0:0x7ffff6659d2d/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
3         moca.so:0x7ffff77dad9d:0x7ffff77da9bd/libstdc++.so.6:0x7ffff6bcb2e8:0x7ffff6bcb399/libgivaro.so.8:0x7ffff731b8ae:0x7ffff7311c06/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
4         moca.so:0x7ffff77dad9d:0x7ffff77da9bd/libstdc++.so.6:0x7ffff6bcb2e8:0x7ffff6bcb399/libgivaro.so.8:0x7ffff731b8bc:0x7ffff7311c06/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
5         moca.so:0x7ffff77dad9d:0x7ffff77da9bd/libstdc++.so.6:0x7ffff6bcb2e8:0x7ffff6bcb399/libgivaro.so.8:0x7ffff731b8ca:0x7ffff7311c06/ld-linux-x86-64.so.2:0x7ffff7dea9fa:0x7ffff7deaae3:0x7ffff7ddd1ca
6                                                                                                                                                                                                      <NA>
       AddressEnd
1         6553600
2         6592128
3         6599888
4         6606256
5         6612624
6 140734104662016
'data.frame':	10 obs. of  5 variables:
 $ Structure   : Factor w/ 27 levels "__GI___pthread_keys",..: 19 27 26 25 24 23 22 20 21 19
 $ AddressStart:Class 'bigz'  raw [1:164] 0a 00 00 00 ...
 $ AddressSize :Class 'bigz'  raw [1:124] 0a 00 00 00 ...
 $ BackTrace   : Factor w/ 5 levels "moca.so:0x7ffff77dad9d:0x7ffff77da9bd/libc.so.6:0x7ffff5f2c601:0x7ffff5f5dbf6:0x7ffff5f32830/libgomp.so.1:0x7ffff66647b0:0x7fff"| __truncated__,..: NA NA NA NA NA NA NA NA NA NA
 $ AddressEnd  :Class 'bigz'  raw [1:164] 0a 00 00 00 ...
      Structure    AddressStart AddressSize BackTrace      AddressEnd
6         stack 140734104526848      135168      <NA> 140734104662016
7    stack:1394 140737228918784     8388608      <NA> 140737237307392
8    stack:1393 140737237311488     8388608      <NA> 140737245700096
9    stack:1392 140737245704192     8388608      <NA> 140737254092800
10   stack:1391 140737254096896     8388608      <NA> 140737262485504
11   stack:1390 140737262489600     8388608      <NA> 140737270878208
12   stack:1389 140737270882304     8388608      <NA> 140737279270912
13   stack:1388 140737279275008    40394752      <NA> 140737319669760
14 stack:1388-1 140737279275008     8388608      <NA> 140737287663616
28        stack 140737488216064      135168      <NA> 140737488351232
[1] 26757413
   user  system elapsed 
  144.0     5.4   151.6
Big Integer ('bigz') :
[1] 140734104526848
Big Integer ('bigz') :
[1] 140737488351232
[1] 26757413
#+end_example

#+begin_src R :results output :session :exports both
#system.time(l <- subset(k, k$Address >= minA & k$Address <= maxA));
system.time(l <- k[which(k$Address >= minA & k$Address <= maxA),]);
#head(l)
str(l)
nrow(l)
#+end_src

#+RESULTS:
#+begin_example
   user  system elapsed 
  32.16    3.30   45.58
'data.frame':	26757095 obs. of  8 variables:
 $ Address :Class 'bigz'  raw [1:428113524] e7 47 98 01 ...
 $ Reads   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes  : int  1 1 0 0 1 1 1 0 1 0 ...
 $ Start   : int  1 1684270 3017959 3154044 4110290 8390 162392 467839 1701817 3887327 ...
 $ End     : int  231 1746951 3113963 3921806 6472707 35503 260463 497278 1822263 8530003 ...
 $ Tid     : int  0 3 0 3 3 6 5 6 6 6 ...
 $ N       : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Duration: int  230 62681 96004 767762 2362417 27113 98071 29439 120446 4642676 ...
[1] 26757095
#+end_example

So this time we have a decent number of accesses, let's hope that the
end of the parsing is not too slow  ...

#+begin_src R :results output :session :exports both
ptm <- proc.time()

# Compute accesses type

m <- l
system.time(m$aType <- ifelse(m$Write >0,"Write", "Read"));
system.time(m$sType <- ifelse(m$N > 1,"Shared","Private"));
system.time(m$Type <- paste(m$sType,m$aType,sep="_"));
m$sType <- NULL
m$aType <- NULL
head(m)

# Compute data structure name and offset
n <- m
structs$BackTrace <- NULL
head(structs)
getStructReverse <- function (vect){
  name <- 1
  start <- 2
  end <- 4
  return (ifelse(n$Address >= vect[start] & n$Address <= vect[end],
                paste(vect[name],as.bigz(n$Address) - as.bigz(vect[start]),sep="@"),""));
}
system.time(ans <- as.data.frame(apply(structs,1,getStructReverse)))
system.time(vect <- apply(ans,1,paste,collapse=""));
#str(vect)
system.time(vect <- strsplit(vect,"@"))
#str(vect)
system.time(n$Structure <- unlist(lapply(vect,"[",1)))
system.time(n$Offset <- as.integer(unlist(lapply(vect,"[",2))));
#str(n)
head(n)
nrow(n)

# Aggregate
system.time(o <- aggregate(n[,c('Reads','Writes', 'N')],n[,c('Structure','Offset', 'Type', 'Start', 'End')], function(d) sum(d)));
str(o)
head(o)

proc.time() - ptm
#+end_src

#+RESULTS:
#+begin_example
   user  system elapsed 
  5.752   0.000   5.757
   user  system elapsed 
  5.936   0.028   5.969
   user  system elapsed 
  4.676   0.000   4.682
            Address Reads Writes   Start     End Tid N Duration          Type
319 140734104651096     1      1       1     231   0 1      230 Private_Write
320 140736683048976     1      1 1684270 1746951   3 1    62681 Private_Write
321 140736683051824     1      0 3017959 3113963   0 1    96004  Private_Read
322 140736683052224     1      0 3154044 3921806   3 1   767762  Private_Read
323 140736683048992     1      1 4110290 6472707   3 1  2362417 Private_Write
324 140736750157840     1      1    8390   35503   6 1    27113 Private_Write
    Structure    AddressStart AddressSize      AddressEnd
6       stack 140734104526848      135168 140734104662016
7  stack:1394 140737228918784     8388608 140737237307392
8  stack:1393 140737237311488     8388608 140737245700096
9  stack:1392 140737245704192     8388608 140737254092800
10 stack:1391 140737254096896     8388608 140737262485504
11 stack:1390 140737262489600     8388608 140737270878208
   user  system elapsed 
 728.63   44.07  830.03
   user  system elapsed 
215.892   4.056 224.197
   user  system elapsed 
  2.348   0.008   2.358
   user  system elapsed 
 31.648   0.472  32.144
   user  system elapsed 
 16.964   0.284  17.270 
Warning message:
In system.time(n$Offset <- as.integer(unlist(lapply(vect, "[", 2)))) :
  NAs introduced by coercion
            Address Reads Writes   Start     End Tid N Duration          Type
319 140734104651096     1      1       1     231   0 1      230 Private_Write
320 140736683048976     1      1 1684270 1746951   3 1    62681 Private_Write
321 140736683051824     1      0 3017959 3113963   0 1    96004  Private_Read
322 140736683052224     1      0 3154044 3921806   3 1   767762  Private_Read
323 140736683048992     1      1 4110290 6472707   3 1  2362417 Private_Write
324 140736750157840     1      1    8390   35503   6 1    27113 Private_Write
    Structure Offset
319     stack 124248
320      <NA>     NA
321      <NA>     NA
322      <NA>     NA
323      <NA>     NA
324      <NA>     NA
[1] 26757095
   user  system elapsed 
  1.576   0.328   2.805
'data.frame':	18226 obs. of  8 variables:
 $ Structure: chr  "stack" "stack" "stack" "stack" ...
 $ Offset   : int  135114 124248 131016 134553 135114 8384312 8384312 8384312 8384312 8384312 ...
 $ Type     : chr  "Private_Write" "Private_Write" "Private_Write" "Private_Write" ...
 $ Start    : int  1 1 1 1 1 1 1 1 1 1 ...
 $ End      : int  1 231 231 231 231 231 231 231 231 231 ...
 $ Reads    : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ N        : int  1 1 1 1 1 1 1 1 1 1 ...
   Structure  Offset          Type Start End Reads Writes N
1      stack  135114 Private_Write     1   1     1      1 1
2      stack  124248 Private_Write     1 231     1      1 1
3      stack  131016 Private_Write     1 231     1      1 1
4      stack  134553 Private_Write     1 231     1      1 1
5      stack  135114 Private_Write     1 231     1      1 1
6 stack:1389 8384312 Private_Write     1 231     1      1 1
   user  system elapsed 
1046.94   56.95 1210.24
#+end_example

That was slow but it worked

Let see:

#+begin_src R :results output graphics :file img/struct_importance_share_fgemm_stack.png :exports both :width 600 :height 400 :session
library(plyr)
q <- ddply(o,.(Structure),summarize,Share=sum(N),Nacc=sum(Reads+Writes))
library(ggplot2);
p <- ggplot(q,aes(x=Structure,y=Share, fill=Structure)) +
  geom_bar(stat="identity") +
  theme_bw() +
  theme(panel.grid.minor = element_line(colour = "black", linetype="dashed", size = 0.1),
    panel.grid.major = element_line(colour = "black", size = 0.1)) +
  scale_y_log10()
  #lab=("Data structure name") +
  #ylab=("Number of accesses") +
p
#+end_src

#+RESULTS:
[[file:img/struct_importance_share_fgemm_stack.png]]


Wao this is quite unbalanced, it seems everyone is using the stack
1388 which is the main stack I guess !

What about the number of accesses:

#+begin_src R :results output graphics :file img/struct_importance_nacc_fgemm_stack.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(q,aes(x=Structure,y=Nacc, fill=Structure)) +
  geom_bar(stat="identity") +
  theme_bw() +
  theme(panel.grid.minor = element_line(colour = "black", linetype="dashed", size = 0.1),
    panel.grid.major = element_line(colour = "black", size = 0.1)) +
  scale_y_log10()
  #lab=("Data structure name") +
  #ylab=("Number of accesses") +
p
#+end_src

#+RESULTS:
[[file:img/struct_importance_nacc_fgemm_stack.png]]

This plot is quite similar to the previous, let see the distribution
on each stacks

#+begin_src R :results output graphics :file img/intensity_Rw_fgemm_stack.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(o) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Offset,yend=Offset, color=Reads+Writes)) +
  facet_grid(Structure~Type, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_Rw_fgemm_stack.png]]


There are more things here but as we saw earlier, most sharing hapens
in stack 1388, let zoom on it


#+begin_src R :results output graphics :file img/intensity_Rw_fgemm_stack_zoom.png :exports both :width 600 :height 400 :session
r <- o[grep("1388",o$Structure),]
library(ggplot2);
p <- ggplot(r) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Offset,yend=Offset, color=Reads+Writes)) +
  facet_grid(Structure~Type, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_Rw_fgemm_stack_zoom.png]]



Ok we start to see something here but it's quite late and I have to
go, so we'll continue here tomorrow

** Continuing on fflas traces

So from the previous pictures it seems that:
- Most of the accesses happens in the stacks.
- The stack usage is not balanced neither over the time nor between
  the threads.
- All stacks but one are used privately.
- The shared stack is only shared on read mode at the end of the execution.
  
Remaining questions:
1. By how many threads is shared the stack 1388 ?
2. Why do we see such different patterns for instance between the
  threads ?
3. I this repartition deterministic ?
  
   
To answer the first let's re run the analysis and plot the number of
threads using the stack 1388:


#+begin_src R :results output graphics :file img/intensity_Share_fgemm_stack_zoom.png :exports both :width 600 :height 400 :session
r <- o[grep("1388",o$Structure),]
library(ggplot2);
p <- ggplot(r) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Offset,yend=Offset, color=as.factor(N))) +
  facet_grid(Structure~Type, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_Share_fgemm_stack_zoom.png]]


The sharing happens between 4 to 6 threads which is not neglectible
and might be slow on NUMA machines.

I am wondering if this is an issue on every fflas-lapack benchmarks or
only on the fgemm kernel. Before going into the code, I will redo this
analysis on some other benchmarks.
