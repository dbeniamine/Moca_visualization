#+TITLE: Beniamine's LabBook
#+AUTHOR: Beniamine
#+LATEX_HEADER: \usepackage[margin=2cm,a4paper]{geometry}
#+STARTUP: overview indent
#+TAGS: Lucas(L) David(D) noexport(n) deprecated(d)
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+SEQ_TODO: TODO(t!) STARTED(s!) WAITING(w!) | DONE(d!) CANCELLED(c!) DEFERRED(f!)

* 2016-02-17 Memory access along time (from MOCA)

David's traces have only variables. We should look to them as states.

So convert accordingly:

#+begin_src bash :results output :session :exports both
grep ^Variable Moca_matrix_bloc_20160217_Virt.pjdump | 
   awk -F, '{print "State,"$2",access,"$4","$5","$6",0,"$3}' > states_Virt.csv
grep ^Variable Moca_matrix_bloc_20160217_Phy.pjdump | 
   awk -F, '{print "State,"$2",access,"$4","$5","$6",0,"$3}' > states_Phy.csv
#+END_SRC

#+RESULTS:

Great, now let's load them into R.

#+begin_src R :results output :session :exports both
read_paje_trace <- function(file) {
  df <- read.csv(file, header=FALSE, strip.white=TRUE)
  names(df) <- c("Nature","ResourceId","Type","Start","End","Duration", "Depth", "Value")
  df$Origin=file
  m <- min(df$Start)
  df$Start <- df$Start - m
  df$End <- df$Start+df$Duration
  df$Origin <- NULL
  df$Nature <- NULL
  df$Depth <- NULL
  df
}
df_Virt <- read_paje_trace("states_Virt.csv");
df_Phy <- read_paje_trace("states_Phy.csv");
#+end_src

#+RESULTS:

#+begin_src R :results output :session :exports both
nrow(df_Virt);
nrow(df_Phy);
#+end_src

#+RESULTS:
: [1] 4478461
: [1] 4472513

The largest dataframes I have ever seen.

Let's play with care.

#+begin_src R :results output graphics :file (org-babel-temp-file "figure" ".png") :exports both :width 600 :height 400 :session
library(ggplot2);
df <- df_Virt;
df <- df[df$ResourceId == 140737310789152, ];
p <- ggplot(df) +
  theme_bw() +
  geom_segment(size=15, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId), color="black") +
  geom_segment(size=13, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value)) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[file:/tmp/babel-9357QOL/figure9357w0Z.png]]


Strange. Let's see how many *Shared_read* there are.

#+begin_src R :results output :session :exports both
nrow(df[df$Value == "Private_Read" & df$Start < 200000 & df$Start > 150000,]);
nrow(df[df$Value == "Shared_Read" & df$Start < 180000 & df$Start > 210000,]);
df[df$Start > 180000 & df$Start < 210000,]
#+end_src

#+RESULTS:
: [1] 0
: [1] 0
:          ResourceId   Type  Start    End Duration       Value
: 289172 1.407373e+14 access 189573 221868    32295 Shared_Read
: 289173 1.407373e+14 access 189573 221868    32295 Shared_Read
: 289174 1.407373e+14 access 189573 221868    32295 Shared_Read
: 289175 1.407373e+14 access 189573 221868    32295 Shared_Read

Lot's of them for this particular address. Let's zoom in.

#+begin_src R :results output graphics :file img/virt_first_try_2.png :exports both :width 600 :height 400 :session
library(ggplot2);
df <- df_Virt;
df <- df;
p <- ggplot(df) +
  theme_bw() +
  geom_segment(size=13, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value), alpha=.4) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[file:img/first_try_2.png]]



#+begin_src R :results output graphics :file img/phy_first_try_1.png :exports both :width 600 :height 400 :session
library(ggplot2);
df <- df_Phy;
df <- df;
p <- ggplot(df) +
  theme_bw() +
  geom_segment(size=13, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value), alpha=.4) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[file:img/phy_first_try_1.png]]


* 2016-02-17 Calculating intensity

_First Attempt_

I'll try with bash.

#+begin_src bash :results output :session :exports both
cat states_Virt.csv  | grep Shared_Read > states_Virt_shared_read.csv
cat states_Virt_shared_read.csv | cut -d, -f2 | sort | uniq > add_Virt
cat states_Virt_shared_read.csv  | cut -d, -f4-6 | sort | uniq  > timeslices

cat states_Virt_shared_read.csv  | cut -d, -f2,4,5,8 > states_Virt_shared_read_essential.csv
cat states_Virt_shared_read_essential.csv  | sort | uniq  > states_Virt_shared_read_essential_unique.csv
while read line ; do echo -n "$line,"; cat states_Virt_shared_read_essential.csv | grep "$line" | wc -l; done < states_Virt_shared_read_essential_unique.csv > states_Virt_shared_read_essential_unique_with_intensity.csv
#+end_src

Done. Just check the file:
+ =states_Virt_shared_read_essential_unique_with_intensity.csv=
You can load with R and play with it.

_Second Attempt_

Actually, I believe I can do it faster and cleaner with R.

#+begin_src R :results output :session :exports both
library(plyr);
k <- read.csv("states_Virt_shared_read.csv", header=FALSE);
options("scipen"=100, "digits"=4);
head(k);
#+end_src

#+RESULTS:
:      V1              V2     V3 V4   V5   V6 V7          V8
: 1 State 140737351871824 access  1 4396 4395  0 Shared_Read
: 2 State 140737351871976 access  1 4396 4395  0 Shared_Read
: 3 State 140737347542408 access  1 4396 4395  0 Shared_Read
: 4 State 140737347542640 access  1 4396 4395  0 Shared_Read
: 5 State 140737488351205 access  1 4396 4395  0 Shared_Read
: 6 State 140737488350713 access  1 4396 4395  0 Shared_Read

#+begin_src R :results output :session :exports both
sapply(k, class);
#+end_src

#+RESULTS:
:        V1        V2        V3        V4        V5        V6        V7        V8 
:  "factor" "numeric"  "factor" "integer" "integer" "integer" "integer"  "factor"

#+begin_src R :results output :session :exports both
names(k) <- c("Nature", "Address", "Type", "Start", "End", "Duration", "Imbric", "Value");
k$Nature <- NULL;
k$Type <- NULL;
k$Imbric <- NULL;
head(k);
#+end_src

#+RESULTS:
:           Address Start  End Duration       Value
: 1 140737351871824     1 4396     4395 Shared_Read
: 2 140737351871976     1 4396     4395 Shared_Read
: 3 140737347542408     1 4396     4395 Shared_Read
: 4 140737347542640     1 4396     4395 Shared_Read
: 5 140737488351205     1 4396     4395 Shared_Read
: 6 140737488350713     1 4396     4395 Shared_Read

#+begin_src R :results output :session :exports both
sapply(k, class);
#+end_src

#+RESULTS:
:   Address     Start       End  Duration     Value 
: "numeric" "integer" "integer" "integer"  "factor"

Do the magic. This command takes time.

#+begin_src R :results output :session :exports both
library(plyr);
g <- ddply(k, .(Address, Start, End, Duration, Value), summarize, N=length(Value));
head(g);
#+end_src

#+RESULTS:
:        Address Start  End Duration       Value N
: 1 1.407374e+14     1 4396     4395 Shared_Read 1
: 2 1.407374e+14     1 4396     4395 Shared_Read 1
: 3 1.407373e+14     1 4396     4395 Shared_Read 1
: 4 1.407373e+14     1 4396     4395 Shared_Read 1
: 5 1.407375e+14     1 4396     4395 Shared_Read 1
: 6 1.407375e+14     1 4396     4395 Shared_Read 1

#+begin_src R :results output :session :exports both
head(g);
sapply(g, class);
#+end_src

#+RESULTS:
:           Address Start  End Duration       Value N
: 1 140737351871824     1 4396     4395 Shared_Read 1
: 2 140737351871976     1 4396     4395 Shared_Read 1
: 3 140737347542408     1 4396     4395 Shared_Read 1
: 4 140737347542640     1 4396     4395 Shared_Read 1
: 5 140737488351205     1 4396     4395 Shared_Read 1
: 6 140737488350713     1 4396     4395 Shared_Read 1
:   Address     Start       End  Duration     Value         N 
: "numeric" "integer" "integer" "integer"  "factor" "integer"

#+begin_src R :results output :session :exports both
summary(g$N);
#+end_src

#+RESULTS:
:    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
:   1.000   2.000   3.000   3.421   5.000   8.000

#+begin_src R :results output :session :exports both
#head(g[g$Address == 140737308215152,]);
head(g[g$Address == 140737312395264,]);
median(g[g$Address > 7000000,]$Address);
#tail(g);
#+end_src

#+RESULTS:
:               Address  Start    End Duration       Value N
: 17014 140737312395264  28278  67005    38727 Shared_Read 3
: 22805 140737312395264  54041  77448    23407 Shared_Read 2
: 30183 140737312395264  67009 126332    59323 Shared_Read 3
: 33031 140737312395264  77453  90227    12774 Shared_Read 2
: 36721 140737312395264  90243 137116    46873 Shared_Read 2
: 50336 140737312395264 126336 171611    45275 Shared_Read 5
: [1] 140737314631680

#+begin_src R :results output graphics :file img/intensity_1_up.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(g[g$Address > 6304416,]) +
  theme_bw() +
  geom_segment(size=7, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_wrap(~Value, ncol=1);# + ylim(139000000000000, NA);
p
#+end_src

#+RESULTS:
[[file:img/intensity_1_up.png]]

I just can't find out the best Y scale. Let's create a histogram of
these addresses.

#+begin_src R :results output :session :exports both
h <- g[g$Address > 7304416,];
h$Address = h$Address - 140737000000000;
head(h);
#+end_src

#+RESULTS:
:     Address Start  End Duration       Value N
: 1 351871824     1 4396     4395 Shared_Read 1
: 2 351871976     1 4396     4395 Shared_Read 1
: 3 347542408     1 4396     4395 Shared_Read 1
: 4 347542640     1 4396     4395 Shared_Read 1
: 5 488351205     1 4396     4395 Shared_Read 1
: 6 488350713     1 4396     4395 Shared_Read 1

#+begin_src R :results output graphics :file img/address_histogram.png :exports both :width 600 :height 400 :session
ggplot(h, aes(Address)) + xlim(300000000, 330000000) + geom_histogram();
#+end_src

#+RESULTS:
[[file:img/address_histogram.png]]

Okay, let's try again.

#+begin_src R :results output graphics :file img/intensity_2.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(h) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_wrap(~Value, ncol=1);# + ylim(300000000, 330000000)
p
#+end_src

#+RESULTS:
[[file:img/intensity_2.png]]


Not that good, need further filtering:

#+begin_src R :results output :session :exports both
summary(h$Address);
#+end_src

#+RESULTS:
:      Min.   1st Qu.    Median      Mean   3rd Qu.      Max. 
: 271000000 310000000 315000000 315000000 319000000 488000000

Let's get only addresses from the 1st to the 3rd Qu.

#+begin_src R :results output graphics :file img/intensity_3.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(h) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_wrap(~Value, ncol=1) + ylim(310000000, 319000000)
p
#+end_src

#+RESULTS:
[[file:img/intensity_3.png]]

Finally. Let's reduce size.

#+begin_src R :results output graphics :file img/intensity_4.png :exports both :width 600 :height 800 :session
library(ggplot2);
p <- ggplot(h) +
  theme_bw() +
  geom_segment(size=0.2, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_wrap(~Value, ncol=1) + ylim(310000000, 319000000)
p
#+end_src

#+RESULTS:
[[file:img/intensity_4.png]]


#+begin_src R :results output graphics :file img/intensity_5.png :exports both :width 600 :height 2000 :session
library(ggplot2);
p <- ggplot(h) +
  theme_bw() +
  geom_segment(size=0.2, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_wrap(~Value, ncol=1) + ylim(310000000, 319000000)
p
#+end_src

#+RESULTS:
[[file:img/intensity_5.png]]

#+begin_src R :results output graphics :file img/intensity_6.png :exports both :width 600 :height 2000 :session
library(ggplot2);
p <- ggplot(h) +
  theme_bw() +
  geom_segment(size=0.5, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_wrap(~Value, ncol=1) + ylim(310000000, 311000000)
p
#+end_src

#+RESULTS:
[[file:img/intensity_6.png]]

** Old Stuff                                                    :deprecated:

Let's make rows unique, since now we have the intensity.

#+begin_src R :results output :session :exports both
h <- unique(g);
#+end_src

#+RESULTS:

#+begin_src R :results output :session :exports both
head(h);
#+end_src

#+RESULTS:
:        Address Start  End Duration       Value N
: 1 1.407374e+14     1 4396     4395 Shared_Read 1
: 2 1.407374e+14     1 4396     4395 Shared_Read 1
: 3 1.407373e+14     1 4396     4395 Shared_Read 1
: 4 1.407373e+14     1 4396     4395 Shared_Read 1
: 5 1.407375e+14     1 4396     4395 Shared_Read 1
: 6 1.407375e+14     1 4396     4395 Shared_Read 1

#+begin_src R :results output graphics :file (org-babel-temp-file "figure" ".png") :exports both :width 600 :height 400 :session
ggplot(h, aes(x=Start, y=N)) + geom_point();
#+end_src

#+RESULTS:
[[file:/tmp/babel-9357QOL/figure9357x8U.png]]

* 2016-02-23 New traces

I got a new tarbal from David, here's its MD5 signature.

#+begin_src sh :results output :session :exports both
md5sum ../Moca-matrix.tgz
#+end_src

#+RESULTS:
: 7a81360ff13bcdd0cb3dc23e5b006805  ../Moca-matrix.tgz

Extracting the data in the =v2= directory.

#+begin_src sh :results output :session :exports both
mkdir -p v2; cd v2; tar xfz ../../Moca-matrix.tgz; mv Moca-matrix-bloc/* .; rm -rf Moca-matrix-bloc;
#+end_src

#+RESULTS:

List contents:

#+begin_src sh :results output :session :exports both
pwd
ls -hl v2
#+end_src

#+RESULTS:
: /home/schnorr/TRACES/david/Moca-matrix-bloc
: total 1.1G
: -rw-r--r-- 1 schnorr schnorr  126 Feb 17 10:54 matrix.stackmap.csv
: -rw-r--r-- 1 schnorr schnorr  331 Feb 17 10:54 matrix.structs.csv
: -rw-r--r-- 1 schnorr schnorr 317M Feb 18 13:31 Moca-framesoc.csv
: -rw-r--r-- 1 schnorr schnorr  94M Feb 17 10:54 Moca-full-trace.csv
: -rw-r--r-- 1 schnorr schnorr 351M Feb 18 14:01 Moca_matrix_bloc_20160218Virt.pjdump
: -rw-r--r-- 1 schnorr schnorr 301M Feb 18 14:31 states

Great, now we are ready to start again.

* 2016-02-23 Playing with new traces

It looks like I only get virtual mem addresses this time. Okay.

#+begin_src sh :results output :session :exports both
cd v2
grep ^Variable Moca_matrix_bloc_20160218Virt.pjdump | 
   awk -F, '{print "State,"$2",access,"$4","$5","$6",0,"$3}' > states_Virt.csv
#+end_src

#+RESULTS:

I have noticed that some durations are negative. See:

#+begin_src sh :results output :session :exports both
cd v2
cat states_Virt.csv | grep "-" | head
#+end_src

#+RESULTS:
#+begin_example
State,140737305567232,access,17863,17762,-101,0,Shared_Read
State,140737305567232,access,17863,17762,-101,0,Shared_Read
State,140737305569152,access,17863,17762,-101,0,Shared_Read
State,140737305599152,access,17863,17762,-101,0,Shared_Read
State,140737305599152,access,17863,17762,-101,0,Shared_Read
State,140737305595904,access,17863,17762,-101,0,Shared_Read
State,140737305611152,access,17863,17762,-101,0,Shared_Read
State,140737305608192,access,17863,17762,-101,0,Shared_Read
State,140737305623152,access,17863,17762,-101,0,Shared_Read
State,140737305623152,access,17863,17762,-101,0,Shared_Read
#+end_example

_Summary_:
- Negative durations (probably an error)

* 2016-02-23 Removing durations with negative values                  :Lucas:

Okay, let's proceed anyway, removing the problem.

#+begin_src sh :results output :session :exports both
cd v2
cat states_Virt.csv | grep -v "-" > states_Virt_without_neg_durations.csv
#+end_src

#+RESULTS:

Great, now let's load it.

#+begin_src R :results output :session :exports both
read_paje_trace <- function(file) {
  df <- read.csv(file, header=FALSE, strip.white=TRUE)
  names(df) <- c("Nature","ResourceId","Type","Start","End","Duration", "Depth", "Value")
  df$Origin=file
  m <- min(df$Start)
  df$Start <- df$Start - m
  df$End <- df$Start+df$Duration
  df$Origin <- NULL
  df$Nature <- NULL
  df$Depth <- NULL
  df
}
df_Virt <- read_paje_trace("v2/states_Virt_without_neg_durations.csv");
#+end_src

#+RESULTS:

#+begin_src R :results output :session :exports both
df <- df_Virt;
df$Type <- NULL;
head(df);
#+end_src

#+RESULTS:
:   ResourceId Start  End Duration         Value
: 1    4656816     0 4395     4395  Private_Read
: 2    6303348     0 4395     4395  Private_Read
: 3    6303348     0 4395     4395 Private_Write
: 4    6303752     0 4395     4395  Private_Read
: 5    6303752     0 4395     4395 Private_Write
: 6    7330440     0 4395     4395  Private_Read

#+begin_src R :results output graphics :file img/Moca_matrix_bloc_20160218Virt_overview.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(df) +
  theme_bw() +
  geom_segment(size=13, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value), alpha=.4) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[./img/Moca_matrix_bloc_20160218Virt_overview.png]]

Let's remove =Shared_Write= and =Private_Write=.

#+begin_src R :results output graphics :file img/Moca_matrix_bloc_20160218Virt_filter_1.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(df[df$Value != "Private_Write" & df$Value != "Shared_Write",]) +
  theme_bw() +
  geom_segment(size=13, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value), alpha=.4) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[file:img/Moca_matrix_bloc_20160218Virt_filter_1.png]]

Let's zoom in to the beginning, reduce segment size:

#+begin_src R :results output graphics :file img/Moca_matrix_bloc_20160218Virt_filter_2.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(df[df$Value != "Private_Write" & df$Value != "Shared_Write",]) +
  theme_bw() +
  geom_segment(size=1, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value), alpha=.4) +
  facet_wrap(~Value, ncol=1) + xlim(0, 90243);
p
#+end_src

#+RESULTS:
[[file:img/Moca_matrix_bloc_20160218Virt_filter_2.png]]

That's strange the middle with nothing. The problem is this:

#+begin_src sh :results output :session :exports both
cat v2/states_Virt_without_neg_durations.csv | cut -d, -f2 | head -n30 | cat -n
#+end_src

#+RESULTS:
#+begin_example
     1	4656816
     2	6303348
     3	6303348
     4	6303752
     5	6303752
     6	7330440
     7	7330440
     8	7341840
     9	7341840
    10	8700368
    11	8700368
    12	8737104
    13	8737104
    14	8784688
    15	8784688
    16	8787648
    17	8787648
    18	8790320
    19	8790320
    20	140152691697344
    21	140152691777685
    22	140152691881456
    23	140152691913632
    24	140152692128528
    25	140152692183424
    26	140152692227168
    27	140152692306624
    28	140152692447204
    29	140152692585408
    30	140152692856576
#+end_example

The first 19 events have very low addresses. All other addresses are
much larger. That's why we have those blank spaces in the plot. We
should remove these low addresses. Sorting these events numerically
indicates that I should look only to addresses between 
140152691697344 and 
140737488351205.

#+begin_src R :results output :session :exports both
sapply(df, class);
#+end_src

#+RESULTS:
: ResourceId      Start        End   Duration      Value 
:  "numeric"  "integer"  "integer"  "integer"   "factor"

Great, we can filter easily.

#+begin_src R :results output graphics :file img/Moca_matrix_bloc_20160218Virt_filter_3.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(
  df[df$Value != "Private_Write" &
  df$Value != "Shared_Write" &
  df$ResourceId >= 140152691697344 &
  df$ResourceId <= 140737488351205,]) +
  theme_bw() +
  geom_segment(size=1, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value), alpha=.4) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[file:img/Moca_matrix_bloc_20160218Virt_filter_3.png]]

That didn't work. Let's create a histogram:


#+begin_src R :results output :session :exports both

#+end_src


#+begin_src R :results output graphics :file img/Moca_matrix_bloc_20160218Virt_ResourceId_histogram.png :exports both :width 600 :height 400 :session
ggplot(df, aes(ResourceId)) + geom_histogram() + theme_bw();
#+end_src

#+RESULTS:
[[file:img/Moca_matrix_bloc_20160218Virt_ResourceId_histogram.png]]

Okay, let's zoom in:


#+begin_src R :results output graphics :file img/Moca_matrix_bloc_20160218Virt_ResourceId_histogram_1.png :exports both :width 600 :height 400 :session
ggplot(df, aes(ResourceId)) + geom_histogram() + theme_bw() + xlim(1.4073e+14,NA);
#+end_src

#+RESULTS:
[[file:img/Moca_matrix_bloc_20160218Virt_ResourceId_histogram_1.png]]

Okay, limits should be =xlim(1.4073e+14,NA)=.

#+begin_src R :results output graphics :file img/Moca_matrix_bloc_20160218Virt_filter_4.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(
  df[df$Value != "Private_Write" &
  df$Value != "Shared_Write" &
  df$ResourceId >= 1.4073e+14,]) +
  theme_bw() +
  geom_segment(size=1, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value), alpha=.4) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[file:img/Moca_matrix_bloc_20160218Virt_filter_4.png]]


Now we are finally going somewhere. ResourceId filtering is essential.

Let's go on, limiting the upper bound.

#+begin_src R :results output graphics :file img/Moca_matrix_bloc_20160218Virt_filter_5.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(
  df[df$Value != "Private_Write" &
  df$Value != "Shared_Write" &
  df$ResourceId >= 1.4073e+14 &
  df$ResourceId <= 1.407374e+14,]) +
  theme_bw() +
  geom_segment(size=1, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value), alpha=.4) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[file:img/Moca_matrix_bloc_20160218Virt_filter_5.png]]

Great. I stop here for now.

The problem for me is to correctly define the Address bounds for the
visualization. Since MOCA dumps really every single memory address
accessed (no matter where), and we don't know which part we should
look for, the prototype should allow an easy search methodology in the
address space (pretty much following what I have done above, but
automatically). Then, and only then, plot things.


Some recomendations:
- filter by memory address in MOCA (if intrusion is acceptable)
- create a script to easily filter by memory address interval
  - automatic address interval selection should be possible

Future analysis methodology:
- I am using alpha values to draw segments, but I shouldn't.
  - Intensity should correlate with number of concurrent mem access.
  - So, a preprocessing of the trace do the magic
    - Take a look at [[*2016-02-17 Calculating intensity][2016-02-17 Calculating intensity]] to see how to
  - Then plot as usual after all this filtering stuff mentioned above

* 2016-02-24 Answers for questions of previous section                :David:
- The filtering on the address space can be done using the structs.csv and stackmaps.csv
that provides addresses, name and size of the various data structures
and stacks. 
In Ocelotl, I usually filter out all the addresses that are not in a
data structure at import time. Still it can be interesting to do it
during the preprocessing phase.
Sadly I realized yesterday that Pin (the tool that I am using to
record data structure addresses) was providing bad addresses, thus the
filter won't work this the trace version two.
This issue is not yet completly fixed but there is a trace with
manually fixed data structure addresses and with the address space
already reduced to data structures:
 https://ligcloud.imag.fr/public.php?service=files&t=13b4b28b657943bdf7c4d31d6a7a18ba
- The idea of Moca is to provide a trace as precise as possible, we don't know a priori what
we are looking for, thus I'd rather avoid filtering during tracing.
- The preprocessing can also be done when we detect sharing, currently when I dectect that
two threads are sharing a page, I create to different accesses. I
could create only one access to the page with a value of two. Still
with this reprensentation, we only now the address of the shared page
and loose the precise addresses of each accesses.

* 2016-02-25 New trace / Redo analysis / Try to be faster in filtering :Lucas:

I have been provided with a new trace.

#+begin_src sh :results output :session :exports both
md5sum matrix.tgz
#+end_src

#+RESULTS:
: 098f7ee5632a20cf82290737e89c3ad2  matrix.tgz

#+begin_src sh :results output :session :exports both
tar xfz matrix.tgz
#+end_src

#+RESULTS:

#+begin_src sh :results output :session :exports both
ls -1 Moca-matrix-bloc-fixaddr/
#+end_src

#+RESULTS:
: matrix.stackmap.csv
: matrix.structs.csv
: Moca-framesoc.csv
: Moca_matrix_bloc_fixaddr_20160222_144532_CET_Physical_6.pjdump
: Moca_matrix_bloc_fixaddr_20160223_172342_CET_Physical_6.pjdump
: Moca_matrix_bloc_fixaddr_20160223_172342_CET_Virtual_7.pjdump

David told me the file =matrix.structs.csv= has information about the
memory addresses of main data structures, the ones I should be looking
for. Here's the contents:

#+begin_src sh :results output :session :exports both
cat Moca-matrix-bloc-fixaddr/matrix.structs.csv
#+end_src

#+RESULTS:
: name,start,sz
: __GI___pthread_keys,2196192,16384
: __pthread_keys,2196192,16384
: UnnamedStruct#0,6303760,5280
: UnnamedStruct#1,6303888,32816
: UnnamedStruct#2,6303888,32816
: /tmp/matrix/matrix_naif.c:122,140737323565072,18000000
: /tmp/matrix/matrix_naif.c:123,140737305563152,18000000
: /tmp/matrix/matrix_naif.c:123,140737287561232,18000000

Great, let's focus our analysis below in addresses starting at
- 140737305563152 up to 140737305563152+18000000

First, convert to =states=, using bash.

#+begin_src sh :results output :session :exports both
UNIQFILE=Moca_matrix_bloc_fixaddr_20160223_172342_CET_Virtual_7
cat Moca-matrix-bloc-fixaddr/${UNIQFILE}.pjdump | grep ^Variable |
   awk -F, '{print "State,"$2",access,"$4","$5","$6",0,"$3}' > ${UNIQFILE}-states.csv
#+end_src

#+RESULTS:

Now, calculate intensity as in:
- [[*2016-02-17 Calculating intensity][2016-02-17 Calculating intensity]]

#+begin_src R :results output :session :exports both
k <- read.csv("Moca_matrix_bloc_fixaddr_20160223_172342_CET_Virtual_7-states.csv", header=FALSE);
options("scipen"=100, "digits"=4);
head(k);
#+end_src

#+RESULTS:
:      V1      V2     V3 V4   V5   V6 V7            V8
: 1 State 4656816 access  1 4399 4398  0  Private_Read
: 2 State 6303500 access  1 4399 4398  0  Private_Read
: 3 State 6303500 access  1 4399 4398  0 Private_Write
: 4 State 6303752 access  1 4399 4398  0  Private_Read
: 5 State 6303752 access  1 4399 4398  0 Private_Write
: 6 State 7330440 access  1 4399 4398  0  Private_Read

#+begin_src R :results output :session :exports both
sapply(k, class);
#+end_src

#+RESULTS:
:        V1        V2        V3        V4        V5        V6        V7        V8 
:  "factor" "numeric"  "factor" "integer" "integer" "integer" "integer"  "factor"

#+begin_src R :results output :session :exports both
names(k) <- c("Nature", "Address", "Type", "Start", "End", "Duration", "Imbric", "Value");
k$Niature <- NULL;
k$Type <- NULL;
k$Imbric <- NULL;
head(k);
#+end_src

#+RESULTS:
:   Address Start  End Duration         Value
: 1 4656816     1 4399     4398  Private_Read
: 2 6303500     1 4399     4398  Private_Read
: 3 6303500     1 4399     4398 Private_Write
: 4 6303752     1 4399     4398  Private_Read
: 5 6303752     1 4399     4398 Private_Write
: 6 7330440     1 4399     4398  Private_Read

#+begin_src R :results output :session :exports both
sapply(k, class);
#+end_src

#+RESULTS:
:   Address     Start       End  Duration     Value 
: "numeric" "integer" "integer" "integer"  "factor"

Do the magic. This command takes time.

#+begin_src R :results output :session :exports both
library(plyr);
g <- ddply(k, .(Address, Start, End, Duration, Value), summarize, N=length(Value));
head(g);
#+end_src

*Attention*: I aborted the command above since I was waiting for too long.

Let's try again with dplyr.

#+begin_src R :results output :session :exports both
library(dplyr);
#+end_src

#+RESULTS:
#+begin_example

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union
#+end_example

See this introduction to _dplyr_ (specially tthe section on chaining):
https://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html

Okay, let's write new code:

#+begin_src R :results output :session :exports both
g <- k %>%
       group_by(Address, Start, End, Duration, Value) %>%
       summarize(N = length(Value));
#+end_src

#+RESULTS:

It was fast (I think around a minute in my machine).

#+begin_src R :results output :session :exports both
nrow(g);
head(g);
#+end_src

#+RESULTS:
#+begin_example
[1] 3368394
Source: local data frame [6 x 6]
Groups: Address, Start, End, Duration

  Address   Start     End Duration         Value N
1 4194928 1700510 1729918    29408  Private_Read 1
2 4197248   14887   17767     2880  Private_Read 1
3 4656816       1    4399     4398  Private_Read 1
4 6303496   14887   17767     2880  Private_Read 1
5 6303500       1    4399     4398  Private_Read 1
6 6303500       1    4399     4398 Private_Write 1
#+end_example

Filter out the space address:
- 140737305563152 up to 140737305563152+18000000

#+begin_src R :results output :session :exports both
head(g[g$Address >= 140737305563152 & g$Address <= 140737305563152+18000000,]);
#+end_src

#+RESULTS:
#+begin_example
Source: local data frame [6 x 6]
Groups: Address, Start, End, Duration

          Address Start   End Duration         Value N
1 140737305563152  4400  9932     5532  Private_Read 1
2 140737305563152  4400  9932     5532 Private_Write 1
3 140737305563152 17734 17757       23  Private_Read 1
4 140737305563152 17757 20391     2634   Shared_Read 2
5 140737305563152 20391 27232     6841  Private_Read 1
6 140737305563152 27232 32008     4776   Shared_Read 2
#+end_example

It worked, but it was a little slow. Let's also use =dplyr=.

#+begin_src R :results output :session :exports both
h <- g %>% filter(Address >= 140737305563152 & Address <= 140737305563152+18000000);
#+end_src

#+RESULTS:

My feeling is that it was slower.

#+begin_src R :results output :session :exports both
head(h);
#+end_src

#+RESULTS:
#+begin_example
Source: local data frame [6 x 6]
Groups: Address, Start, End, Duration

          Address Start   End Duration         Value N
1 140737305563152  4400  9932     5532  Private_Read 1
2 140737305563152  4400  9932     5532 Private_Write 1
3 140737305563152 17734 17757       23  Private_Read 1
4 140737305563152 17757 20391     2634   Shared_Read 2
5 140737305563152 20391 27232     6841  Private_Read 1
6 140737305563152 27232 32008     4776   Shared_Read 2
#+end_example

Let's plot the intensity of =h= anyway:


#+begin_src R :results output graphics :file img/intensity_fixaddr_v1.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(h) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[file:img/intensity_fixaddr_v1.png]]

That's precise.

* 2016-02-25 Merge access information with data structure information :Lucas:

Let's look to another data structure, ow, much better, let's change
our data frame to contain such information.

#+begin_src R :results output :session :exports both
head(g);
#+end_src

#+RESULTS:
#+begin_example
Source: local data frame [6 x 6]
Groups: Address, Start, End, Duration

  Address   Start     End Duration         Value N
1 4194928 1700510 1729918    29408  Private_Read 1
2 4197248   14887   17767     2880  Private_Read 1
3 4656816       1    4399     4398  Private_Read 1
4 6303496   14887   17767     2880  Private_Read 1
5 6303500       1    4399     4398  Private_Read 1
6 6303500       1    4399     4398 Private_Write 1
#+end_example

#+begin_src R :results output :session :exports both
structs <- read.csv("Moca-matrix-bloc-fixaddr/matrix.structs.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressEnd = structs$AddressStart + structs$AddressSize;

#+end_src

#+RESULTS:
:                       Structure    AddressStart AddressSize      AddressEnd
: 1           __GI___pthread_keys         2196192       16384         2212576
: 2                __pthread_keys         2196192       16384         2212576
: 3               UnnamedStruct#0         6303760        5280         6309040
: 4               UnnamedStruct#1         6303888       32816         6336704
: 5               UnnamedStruct#2         6303888       32816         6336704
: 6 /tmp/matrix/matrix_naif.c:122 140737323565072    18000000 140737341565072
: 7 /tmp/matrix/matrix_naif.c:123 140737305563152    18000000 140737323563152
: 8 /tmp/matrix/matrix_naif.c:123 140737287561232    18000000 140737305561232

I'll have to use =sqldf= I think.

#+begin_src R :results output :session :exports both
library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);
#+end_src

#+RESULTS:
#+begin_example
Loading required package: gsubfn
Loading required package: proto
Loading required package: RSQLite
Loading required package: DBI
 Loading required package: tcltk
  Address Start    End Duration        Value N       Structure
1 6304392  4400   9932     5532 Private_Read 1 UnnamedStruct#0
2 6304392  4400   9932     5532 Private_Read 1 UnnamedStruct#1
3 6304392  4400   9932     5532 Private_Read 1 UnnamedStruct#2
4 6304416 87595 101980    14385  Shared_Read 1 UnnamedStruct#0
5 6304416 87595 101980    14385  Shared_Read 1 UnnamedStruct#1
6 6304416 87595 101980    14385  Shared_Read 1 UnnamedStruct#2
#+end_example

Ow, that was fast.

Let's plot:

#+begin_src R :results output graphics :file img/intensity_fixaddr_with_structure_v1.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_wrap(~Value, ncol=1) + facet_wrap(~Structure,ncol=1) +
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_fixaddr_with_structure_v1.png]]

The Y axis should be independent. I should also use =facet_grid= to
different by access type. Ow, I just realized I made two =facet_wrap=.


#+begin_src R :results output graphics :file img/intensity_fixaddr_with_structure_v2.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_grid(Structure~Value, scales="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_fixaddr_with_structure_v2.png]]

That's great.

Using color as factor.

#+begin_src R :results output graphics :file img/intensity_fixaddr_with_structure_v3.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scales="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_fixaddr_with_structure_v3.png]]


Strange. It is either one or two accesses only.

Is that normal for this application?

* 2016-02-25 Answer to questions of previous section                  :David:

The last image start to be quite interesting but there are several
issues:

** DONE Issue with visualization from file:img/intensity_fixaddr_with_structure_v2.png  [3/3]
- State "DONE"       from "STARTED"    [2016-02-26 Fri 13:40]
- State "STARTED"    from "TODO"       [2016-02-25 Thu 15:42]

*** DONE Number of writes
- State "DONE"       from "WAITING"    [2016-02-25 Thu 15:41]
- State "WAITING"    from "STARTED"    [2016-02-25 Thu 15:41]
- State "STARTED"    from "TODO"       [2016-02-25 Thu 15:41]
The visulisation contans only reads. Around a fourth of the accesses
should be writes. Where does this come from ?

Ok let see where does it comes from first, check that I'm working on
the same files than Lucas:

#+begin_src sh :results output :session :exports both
md5sum matrix.tgz
#+end_src

#+RESULTS:
: 098f7ee5632a20cf82290737e89c3ad2  matrix.tgz

seems to be the good ones, let's take a look

#+begin_src sh :results output :session :exports both
tar xvzf matrix.tgz
#+end_src

#+RESULTS:
: Moca-matrix-bloc-fixaddr/
: Moca-matrix-bloc-fixaddr/Moca_matrix_bloc_fixaddr_20160223_172342_CET_Virtual_7.pjdump
: Moca-matrix-bloc-fixaddr/Moca-framesoc.csv
: Moca-matrix-bloc-fixaddr/Moca_matrix_bloc_fixaddr_20160223_172342_CET_Physical_6.pjdump
: Moca-matrix-bloc-fixaddr/matrix.structs.csv
: Moca-matrix-bloc-fixaddr/matrix.stackmap.csv
: Moca-matrix-bloc-fixaddr/Moca_matrix_bloc_fixaddr_20160222_144532_CET_Physical_6.pjdump

Let's take a look at the main file

#+begin_src sh :results output :exports both
head Moca-matrix-bloc-fixaddr/Moca-framesoc.csv
#+end_src

#+RESULTS:
#+begin_example
@Virt,@Phy,Nreads,Nwrites,CPUMask,Start,End,TaskId,Shared
0000000000400040,000062000b0d4f90,1,0,000100110,1,4399,0,0
0000000000400b80,000062000b0d4f90,1,0,000000111,14887,17767,0,0
0000000000400270,0000000000400270,1,0,000001011,1700510,1729918,3,0
0000000000405435,0000000000405435,1,0,000000110,1,4399,0,0
000000000041d800,000000000041d800,1,0,000000110,1,4399,0,0
0000000000420fa0,0000000000420fa0,1,0,000000110,1,4399,0,0
00000000004341e1,00000000004341e1,1,0,000000110,1,4399,0,0
000000000044677a,000000000044677a,1,0,000000110,1,4399,0,0
000000000045dca0,000000000045dca0,1,0,000000110,1,4399,0,0
#+end_example

So the number of writes is the field number 4, lets count the number
of reads and writes in this file.

#+begin_src sh :results output :exports both
awk -F , 'BEGIN{r=0;w=0} {if($3>0){r++};if($4>0){w++}} END{print r" reads and "w" writes"}' Moca-matrix-bloc-fixaddr/Moca-framesoc.csv
#+end_src

#+RESULTS:
: 5479661 reads and 18285 writes

Ok the difference is way more than a factor 2 or 3 ...
I've recovered the original trace file (not processed) that is not in
the archive. it has the same headers as framesoc file without the last
field, thus the previous command should work on it.

#+begin_src sh :results output :exports both
awk -F , 'BEGIN{r=0;w=0} {if($3>0){r++};if($4>0){w++}} END{print r" reads and "w" writes"}' Moca-matrix-bloc-fixaddr/Moca-full-trace.csv
#+end_src

#+RESULTS:
: 1194354 reads and 17629 writes

#+begin_src sh :results output :exports both
echo 1194354 / 17629 | bc -l 
echo 5479661 / 1194354 | bc -l
echo 18285 / 17629 | bc -l 
#+end_src

#+RESULTS:
: 67.74939020931419819615
: 4.58797056819000061958
: 1.03721141301264961143

So in the raw trace we have already 67.8 more reads than write, event
if we admit that most accessses are reads and each writes also
triggers a read, it's a lot more than what I expected, I guess that I
should work on the way Moca decide if an access is a read or a write.

Still it is also weird that the post processing multiply by 4.6 the
number of reads while it almost doesn't change the number of
writes. I guess it comes from the fact that the number of accesses is
increased only when a shared is detected and according to the last
visualisation every write are private (and actually correspond to the
initialisation).

For now we will consider that this issue comes from Moca collection system.

*** DONE Duplicate data structure name
- State "DONE"       from "TODO"       [2016-02-26 Fri 11:20]
There are two entries in the structs.csv file with the same name, thus
they are merged in the visu

First make the name of data structures unique

#+begin_src sh :results output :exports both
awk -F , 'BEGIN{p="";cpt=1} {if(p==$1){n=$1"-"cpt;cpt++}\
else{cpt=1;n=$1};p=$1;print n","$2","$3}' \
Moca-matrix-bloc-fixaddr/matrix.structs.csv > Moca-matrix-bloc-fixaddr/matrix.structs-uniq.csv
cat  Moca-matrix-bloc-fixaddr/matrix.structs-uniq.csv
#+end_src

#+RESULTS:
: name,start,sz
: __GI___pthread_keys,2196192,16384
: __pthread_keys,2196192,16384
: UnnamedStruct#0,6303760,5280
: UnnamedStruct#1,6303888,32816
: UnnamedStruct#2,6303888,32816
: /tmp/matrix/matrix_naif.c:122,140737323565072,18000000
: /tmp/matrix/matrix_naif.c:123,140737305563152,18000000
: /tmp/matrix/matrix_naif.c:123-1,140737287561232,18000000

Better, now let's redo the analysis from [[*2016-02-25 New trace / Redo analysis / Try to be faster in filtering][2016-02-25 New trace / Redo analysis / Try to be faster in filtering]]  

#+begin_src sh :results output :session :exports both
UNIQFILE=Moca_matrix_bloc_fixaddr_20160223_172342_CET_Virtual_7
cat Moca-matrix-bloc-fixaddr/${UNIQFILE}.pjdump | grep ^Variable |
   awk -F, '{print "State,"$2",access,"$4","$5","$6",0,"$3}' > ${UNIQFILE}-states.csv
head ${UNIQFILE}-states.csv
#+end_src

#+RESULTS:
#+begin_example
State,4656816,access,1,4399,4398,0,Private_Read
State,6303500,access,1,4399,4398,0,Private_Read
State,6303500,access,1,4399,4398,0,Private_Write
State,6303752,access,1,4399,4398,0,Private_Read
State,6303752,access,1,4399,4398,0,Private_Write
State,7330440,access,1,4399,4398,0,Private_Read
State,7330440,access,1,4399,4398,0,Private_Write
State,7341840,access,1,4399,4398,0,Private_Read
State,7341840,access,1,4399,4398,0,Private_Write
State,7370576,access,1,4399,4398,0,Private_Read
#+end_example

Now, calculate intensity as in:
- [[*2016-02-17 Calculating intensity][2016-02-17 Calculating intensity]]

#+begin_src R :results output :session :exports both
k <- read.csv("Moca_matrix_bloc_fixaddr_20160223_172342_CET_Virtual_7-states.csv", header=FALSE);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Nature", "Address", "Type", "Start", "End", "Duration", "Imbric", "Value");
k$Niature <- NULL;
k$Type <- NULL;
k$Imbric <- NULL;
head(k);

sapply(k, class);

library(dplyr);

g <- k %>%
       group_by(Address, Start, End, Duration, Value) %>%
       summarize(N = length(Value));


nrow(g);
head(g);
h <- g %>% filter(Address >= 140737305563152 & Address <= 140737305563152+18000000);
head(h)
#+end_src

#+RESULTS:
#+begin_example
     V1      V2     V3 V4   V5   V6 V7            V8
1 State 4656816 access  1 4399 4398  0  Private_Read
2 State 6303500 access  1 4399 4398  0  Private_Read
3 State 6303500 access  1 4399 4398  0 Private_Write
4 State 6303752 access  1 4399 4398  0  Private_Read
5 State 6303752 access  1 4399 4398  0 Private_Write
6 State 7330440 access  1 4399 4398  0  Private_Read
       V1        V2        V3        V4        V5        V6        V7        V8 
 "factor" "numeric"  "factor" "integer" "integer" "integer" "integer"  "factor"
  Nature Address Start  End Duration         Value
1  State 4656816     1 4399     4398  Private_Read
2  State 6303500     1 4399     4398  Private_Read
3  State 6303500     1 4399     4398 Private_Write
4  State 6303752     1 4399     4398  Private_Read
5  State 6303752     1 4399     4398 Private_Write
6  State 7330440     1 4399     4398  Private_Read
   Nature   Address     Start       End  Duration     Value 
 "factor" "numeric" "integer" "integer" "integer"  "factor"
[1] 3368394
Source: local data frame [6 x 6]
Groups: Address, Start, End, Duration [5]

  Address   Start     End Duration         Value     N
    (dbl)   (int)   (int)    (int)        (fctr) (int)
1 4194928 1700510 1729918    29408  Private_Read     1
2 4197248   14887   17767     2880  Private_Read     1
3 4656816       1    4399     4398  Private_Read     1
4 6303496   14887   17767     2880  Private_Read     1
5 6303500       1    4399     4398  Private_Read     1
6 6303500       1    4399     4398 Private_Write     1
Source: local data frame [6 x 6]
Groups: Address, Start, End, Duration [5]

          Address Start   End Duration         Value     N
            (dbl) (int) (int)    (int)        (fctr) (int)
1 140737305563152  4400  9932     5532  Private_Read     1
2 140737305563152  4400  9932     5532 Private_Write     1
3 140737305563152 17734 17757       23  Private_Read     1
4 140737305563152 17757 20391     2634   Shared_Read     2
5 140737305563152 20391 27232     6841  Private_Read     1
6 140737305563152 27232 32008     4776   Shared_Read     2
#+end_example


Finally redo the plot v3 from [[*2016-02-25 Merge access information with data structure information][2016-02-25 Merge access information with data structure information]] 

#+begin_src R :results output graphics :file img/intensity_fixaddr_with_structure_v4.png :exports both :width 600 :height 400 :session
structs <- read.csv("Moca-matrix-bloc-fixaddr/matrix.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressEnd = structs$AddressStart + structs$AddressSize;

library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);


library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scales="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_fixaddr_with_structure_v4.png]]

Now this fix the non unique structure name issue.

*** DONE Importance of data structures
- State "DONE"       from "TODO"       [2016-02-26 Fri 13:40]
It seems that the last three data structures are not as
important as the first, but it is not clear, maybe plotting the
number of reads/write per structure would help determining if we can
ignore them.

Let's try to plot the number of accesses to each data structure:

#+begin_src R :results output :session :exports both
head(m)
library(plyr)
n <- ddply(m,c("Structure"),summarize,Nacc=sum(N));
head(n)
#+end_src

#+RESULTS:
#+begin_example
  Address Start    End Duration        Value N       Structure
1 6304392  4400   9932     5532 Private_Read 1 UnnamedStruct#0
2 6304392  4400   9932     5532 Private_Read 1 UnnamedStruct#1
3 6304392  4400   9932     5532 Private_Read 1 UnnamedStruct#2
4 6304416 87595 101980    14385  Shared_Read 1 UnnamedStruct#0
5 6304416 87595 101980    14385  Shared_Read 1 UnnamedStruct#1
6 6304416 87595 101980    14385  Shared_Read 1 UnnamedStruct#2
Error: length(rows) == 1 is not TRUE
                        Structure    Nacc
1   /tmp/matrix/matrix_naif.c:122   17508
2   /tmp/matrix/matrix_naif.c:123 5453604
3 /tmp/matrix/matrix_naif.c:123-1   24981
4                 UnnamedStruct#0    1214
5                 UnnamedStruct#1    1214
6                 UnnamedStruct#2    1214
#+end_example

ok let's plot it
#+begin_src R :results output graphics :file img/struct_importance_fixaddr_v1.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(n,aes(x=Structure,y=Nacc, fill=Structure)) +
  theme_bw() +
  geom_bar(stat="identity")
p
#+end_src

#+RESULTS:
[[file:img/struct_importance_fixaddr_v1.png]]

We can't see anything, let's try in log scale

#+begin_src R :results output graphics :file img/struct_importance_fixaddr_v2.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(n,aes(x=Structure,y=Nacc, fill=Structure)) +
  geom_bar(stat="identity") +
  theme_bw() +
  theme(panel.grid.minor = element_line(colour = "black", linetype="dashed", size = 0.1),
    panel.grid.major = element_line(colour = "black", size = 0.1)) +
  scale_y_log10()
  #lab=("Data structure name") +
  #ylab=("Number of accesses") +
p
#+end_src

#+RESULTS:
[[file:img/struct_importance_fixaddr.png]]


Better, so the unamed structures are indeed less accessed (about half
an order) but I don't think it's enough to neglect them.


** Conclusions

The visualisation is starting to be intersting, from those small test
we have seen several "weird" things:
- The number of access is always 1 or 2: I guess it comes from Moca
  tracing method usually there should be only 1 page fault (thus one
  access) per chunk having more than one access should be rare as it
  means a very specific order of accesses between two threads. Instead
  of plotting the intensity of accesses, we should probably plot the
  intensity in terms of number of threads.
- The detection of writes in Moca seems bad, I'll try to fix that

* 2016-02-29 Try on new traces                                        :David:

Moca's code to detect if an access is a read or a write seems correct,
the difference comes from the sampling, so we will try to look at some
other traces and compare them.

** Matrix modulo

The first trace we were studing is a naive matrix multiplication by
blocs, the next trace is an even more naive algorithm were threads
works on close piece of data.

The new trace is available on ligcloud:

We do the same analysis as here [[*Duplicate data structure name][Duplicate data structure name]]

#+begin_src sh :results output :exports both
DIR=Moca-matrix-modulo-2016-02-29_11-14-03
awk -F , 'BEGIN{p="";cpt=1} {if(p==$1){n=$1"-"cpt;cpt++}\
else{cpt=1;n=$1};p=$1;print n","$2","$3}' \
$DIR/matrix.structs.csv > $DIR/matrix.structs-uniq.csv
cat  $DIR/matrix.structs-uniq.csv
#+end_src

#+RESULTS:
: -1,,
: __GI___pthread_keys,2196192,16384
: __pthread_keys,2196192,16384
: UnnamedStruct#0,6303760,5280
: UnnamedStruct#1,6303888,32816
: UnnamedStruct#2,6303888,32816
: /home/david/Work/Bench/matrix/matrix_naif.c:140,140737313341456,8000000
: /home/david/Work/Bench/matrix/matrix_naif.c:123,140737321345040,8000000
: /home/david/Work/Bench/matrix/matrix_naif.c:122,140737329348624,8000000

Better, now let's redo the analysis from [[*2016-02-25 New trace / Redo analysis / Try to be faster in filtering][2016-02-25 New trace / Redo analysis / Try to be faster in filtering]]  

#+begin_src sh :results output :session :exports both
DIR=Moca-matrix-modulo-2016-02-29_11-14-03
UNIQFILE=$DIR/Moca_matrix_modulo_2016_02_29_11_14_03_20160229_112157_CET_Virtual_4
cat ${UNIQFILE}.pjdump | grep ^Variable |
   awk -F, '{print "State,"$2",access,"$4","$5","$6",0,"$3}' > ${UNIQFILE}-states.csv
head ${UNIQFILE}-states.csv
#+end_src

#+RESULTS:
#+begin_example
State,6303348,access,1,3492,3491,0,Private_Read
State,6303348,access,1,3492,3491,0,Private_Write
State,6303752,access,1,3492,3491,0,Private_Read
State,6303752,access,1,3492,3491,0,Private_Write
State,7330216,access,1,3492,3491,0,Private_Read
State,7330216,access,1,3492,3491,0,Private_Write
State,7332280,access,1,3492,3491,0,Private_Read
State,7332280,access,1,3492,3491,0,Private_Write
State,7339250,access,1,3492,3491,0,Private_Read
State,7339250,access,1,3492,3491,0,Private_Write
#+end_example

Now, calculate intensity as in:
- [[*2016-02-17 Calculating intensity][2016-02-17 Calculating intensity]]

#+begin_src R :results output :session :exports both
k <- read.csv("Moca-matrix-modulo-2016-02-29_11-14-03/Moca_matrix_modulo_2016_02_29_11_14_03_20160229_112157_CET_Virtual_4-states.csv", header=FALSE);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Nature", "Address", "Type", "Start", "End", "Duration", "Imbric", "Value");
k$Niature <- NULL;
k$Type <- NULL;
k$Imbric <- NULL;
head(k);

sapply(k, class);

library(dplyr);

g <- k %>%
       group_by(Address, Start, End, Duration, Value) %>%
       summarize(N = length(Value));


nrow(g);
head(g);
#h <- g %>% filter(Address >= 140737313341456 & Address <= 140737313341456+24000000);
#head(h)
#+end_src

#+RESULTS:
#+begin_example
     V1      V2     V3 V4   V5   V6 V7            V8
1 State 6303348 access  1 3492 3491  0  Private_Read
2 State 6303348 access  1 3492 3491  0 Private_Write
3 State 6303752 access  1 3492 3491  0  Private_Read
4 State 6303752 access  1 3492 3491  0 Private_Write
5 State 7330216 access  1 3492 3491  0  Private_Read
6 State 7330216 access  1 3492 3491  0 Private_Write
       V1        V2        V3        V4        V5        V6        V7        V8 
 "factor" "numeric"  "factor" "integer" "integer" "integer" "integer"  "factor"
  Nature Address Start  End Duration         Value
1  State 6303348     1 3492     3491  Private_Read
2  State 6303348     1 3492     3491 Private_Write
3  State 6303752     1 3492     3491  Private_Read
4  State 6303752     1 3492     3491 Private_Write
5  State 7330216     1 3492     3491  Private_Read
6  State 7330216     1 3492     3491 Private_Write
   Nature   Address     Start       End  Duration     Value 
 "factor" "numeric" "integer" "integer" "integer"  "factor"
[1] 1224679
Source: local data frame [6 x 6]
Groups: Address, Start, End, Duration [6]

  Address  Start    End Duration        Value     N
    (dbl)  (int)  (int)    (int)       (fctr) (int)
1 4194928  94264  94505      241 Private_Read     1
2 4194928  94505 108267    13762  Shared_Read     2
3 4194928 108267 108267        0 Private_Read     1
4 4196888   5923   7920     1997 Private_Read     1
5 4197408   7927  24611    16684 Private_Read     1
6 6303232   5923   7920     1997 Private_Read     1
#+end_example


Finally redo the plot v3 from [[*2016-02-25 Merge access information with data structure information][2016-02-25 Merge access information with data structure information]] 

#+begin_src R :results output graphics :file img/intensity_modulo_with_structure_v4.png :exports both :width 600 :height 400 :session
structs <- read.csv("Moca-matrix-modulo-2016-02-29_11-14-03/matrix.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressEnd = structs$AddressStart + structs$AddressSize;

library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);


library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scales="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_modulo_with_structure_v4.png]]


Let's compare this visualisation to
[[file:img/intensity_fixaddr_with_structure_v4.png][file:~/Work/labbook-lucas/img/intensity_fixaddr_with_structure_v4.png]] :
- The intensity goes up to 12 sometimes while it was never more than 2
  in matrix-bloc. This happens because the different thread work on
  very close addresses.
- As expected, the number of detected write have significantly
  increased, I think we can consider that the previous trace was clean
  and this is not a BUG in Moca.
- We can see a lot of shared write on the third data structure which
  is clearly bad in terms of cache.
- We can't see any patterns in the middle structure an the patterns in
  the other structure seems way less linear.
- It is still hard to know which thread is doing what. We really should try
  to visualize the intensity in terms of number of thread involved.


** DONE New visualisation: number of threads                         :David:
- State "DONE"       from "TODO"       [2016-02-29 Mon 18:54]
- State "TODO"       from              [2016-02-29 Mon 14:08]
  
Here is a link to an archive containing the trace I am  working on:
https://ligcloud.imag.fr/public.php?service=files&t=1d3fdcfed0bda3e1cdd30d6ff0093d7e

#+begin_src sh :results output :exports both
md5sum matrix-modulo.tgz
#+end_src

#+RESULTS:
: 82e5aa80788c8c8c5c1a021e45dea44e  matrix-modulo.tgz

#+begin_src sh :results output :exports both
DIR=Moca-matrix-modulo-2016-02-29_11-14-03
head $DIR/Moca_matrix_modulo_2016_02_29_11_14_03_20160229_112157_CET_Virtual_4-states.csv
#+end_src

#+RESULTS:
#+begin_example
State,6303348,access,1,3492,3491,0,Private_Read
State,6303348,access,1,3492,3491,0,Private_Write
State,6303752,access,1,3492,3491,0,Private_Read
State,6303752,access,1,3492,3491,0,Private_Write
State,7330216,access,1,3492,3491,0,Private_Read
State,7330216,access,1,3492,3491,0,Private_Write
State,7332280,access,1,3492,3491,0,Private_Read
State,7332280,access,1,3492,3491,0,Private_Write
State,7339250,access,1,3492,3491,0,Private_Read
State,7339250,access,1,3492,3491,0,Private_Write
#+end_example

The thread information is not in the pjdump file, and the pipeline
from the original trace to this file is very long (trace ->
preprocessing -> framesoc -> pjdump -> states.csv). We should modify
the csv generated by the preprocessing phase and work on this.

#+begin_src sh :results output :exports both
head Moca-matrix-modulo-2016-02-29_11-14-03/Moca-framesoc.csv
#+end_src

#+RESULTS:
#+begin_example
@Virt,@Phy,Nreads,Nwrites,CPUMask,Start,End,TaskId,Shared
0000000000400040,00006200028a0630,1,0,000010110,1,3492,0,0
0000000000400a18,00006200028a0630,1,0,000010110,5923,7920,0,0
0000000000400c20,00006200028a0630,1,0,000100110,7927,24611,2,0
0000000000400270,0000000000400270,1,0,010000110,94264,94505,2,0
0000000000400270,0000000000400270,1,0,010000110,94505,108267,2,1
0000000000400270,0000000000400270,1,0,001000110,94505,108267,3,1
0000000000400270,0000000000400270,1,0,001000110,108267,108267,3,0
0000000000405435,0000000000405435,1,0,010000110,1,3492,0,0
000000000041d800,000000000041d800,1,0,010000110,1,3492,0,0
#+end_example

At this level shared is always 0 or 1, we could instead put the number
of threads sharing the data. It's only a one line change in the post
processing script, let's try it:

#+begin_src sh :results output :exports both
cd  Moca-matrix-modulo-2016-02-29_11-14-03
~/Work/Moca/src/utils/create_event_producer.sh 4096 Moca-full-trace.csv
head Moca-framesoc.csv
#+end_src

#+RESULTS:
#+begin_example
Generating producer files
Generating framesoc trace file
Generating Virtual producers file
Generating Physical producers file
Virtual-producers.log Done
Physical-producers.log Done
Reading from Moca-full-trace.csv
102894 accesses on 6000 pages parsed from Moca-full-trace.csv
done in 00 h 00 min 12.765 sec
@Virt,@Phy,Nreads,Nwrites,CPUMask,Start,End,TaskId,Shared
0000000000400040,00006200028a0630,1,0,000010110,1,3492,0,1
0000000000400a18,00006200028a0630,1,0,000010110,5923,7920,0,1
0000000000400c20,00006200028a0630,1,0,000100110,7927,24611,2,1
0000000000400270,0000000000400270,1,0,010000110,94264,94505,2,1
0000000000400270,0000000000400270,1,0,010000110,94505,108267,2,2
0000000000400270,0000000000400270,1,0,001000110,94505,108267,3,2
0000000000400270,0000000000400270,1,0,001000110,108267,108267,3,1
0000000000405435,0000000000405435,1,0,010000110,1,3492,0,1
000000000041d800,000000000041d800,1,0,010000110,1,3492,0,1
#+end_example


#+begin_src R :results output :session :exports both
computeType <- function(df){
  shared <-9
  write <- 4
  if(df[shared] >= 2){
    mytype <- "Shared"
  }else{
    mytype <- "Private"
  }
  if(df[write] >= 1){
     mytype <- paste(mytype,"Write" , sep="_")
  }else{
     mytype <- paste(mytype,"Read" , sep="_")
  }
  return(mytype)
}

k <- read.csv("Moca-matrix-modulo-2016-02-29_11-14-03/Moca-framesoc.csv", header=T);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

k$Value <- apply(k,1,computeType)
k$Address <- sprintf("%f", as.numeric(paste("0x", k$Address, sep="")))
k$Phy <- NULL;
k$CPU <- NULL;
k$Tid <- NULL;
k$Reads <- NULL ;
k$Writes <- NULL ;
k$Duration <- k$End - k$Start
head(k);
#+end_src

#+RESULTS:
#+begin_example
            X.Virt            X.Phy Nreads Nwrites  CPUMask Start    End TaskId
1 0000000000400040 00006200028a0630      1       0    10110     1   3492      0
2 0000000000400a18 00006200028a0630      1       0    10110  5923   7920      0
3 0000000000400c20 00006200028a0630      1       0   100110  7927  24611      2
4 0000000000400270 0000000000400270      1       0 10000110 94264  94505      2
5 0000000000400270 0000000000400270      1       0 10000110 94505 108267      2
6 0000000000400270 0000000000400270      1       0  1000110 94505 108267      3
  Shared
1      1
2      1
3      1
4      1
5      2
6      2
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
         Address Start    End N        Value Duration
1 4194368.000000     1   3492 1 Private_Read     3491
2 4196888.000000  5923   7920 1 Private_Read     1997
3 4197408.000000  7927  24611 1 Private_Read    16684
4 4194928.000000 94264  94505 1 Private_Read      241
5 4194928.000000 94505 108267 2  Shared_Read    13762
6 4194928.000000 94505 108267 2  Shared_Read    13762
#+end_example


Ok I think that the data frame now looks like what we add with the
pjdump files, let's try to visualize that:

#+begin_src R :results output :session :exports both
g <- k
structs <- read.csv("Moca-matrix-modulo-2016-02-29_11-14-03/matrix.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressEnd = structs$AddressStart + structs$AddressSize;

library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);
#+end_src

#+RESULTS:
:          Address Start   End Duration        Value N       Structure
: 1 6304392.000000  5923  7920     1997 Private_Read 1 UnnamedStruct#0
: 2 6304392.000000  5923  7920     1997 Private_Read 1 UnnamedStruct#1
: 3 6304392.000000  5923  7920     1997 Private_Read 1 UnnamedStruct#2
: 4 6304472.000000  7921 10085     2164 Private_Read 1 UnnamedStruct#0
: 5 6304472.000000  7921 10085     2164 Private_Read 1 UnnamedStruct#1
: 6 6304472.000000  7921 10085     2164 Private_Read 1 UnnamedStruct#2

#+begin_src R :results output graphics :file img/intensity_modulo_threads.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scales="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_modulo_threads.png]]


This is starting to be very interesting, we can see here that the
middle data structure is shared by all thread, which might be bad on
NUMA machines, while the others seems two be shared mostly by two
threads, which should be a bit better.

- What is happening with the addresses in the big data structures ?

Can we do the same thing for the bloc version, see if it looks better:

#+begin_src sh :results output :exports both
cd  Moca-matrix-bloc-fixaddr/
~/Work/Moca/src/utils/create_event_producer.sh 4096 Moca-full-trace.csv
head Moca-framesoc.csv
#+end_src

#+RESULTS:
#+begin_example
Generating producer files
Generating framesoc trace file
Generating Virtual producers file
Generating Physical producers file
Virtual-producers.log Done
Physical-producers.log Done
done in 00 h 00 min 00.062 sec
@Virt,@Phy,Nreads,Nwrites,CPUMask,Start,End,TaskId,Shared
0000000000400040,000062000b0d4f90,1,0,000100110,1,4399,0,0
0000000000400b80,000062000b0d4f90,1,0,000000111,14887,17767,0,0
0000000000400270,0000000000400270,1,0,000001011,1700510,1729918,3,0
0000000000405435,0000000000405435,1,0,000000110,1,4399,0,0
000000000041d800,000000000041d800,1,0,000000110,1,4399,0,0
0000000000420fa0,0000000000420fa0,1,0,000000110,1,4399,0,0
00000000004341e1,00000000004341e1,1,0,000000110,1,4399,0,0
000000000044677a,000000000044677a,1,0,000000110,1,4399,0,0
000000000045dca0,000000000045dca0,1,0,000000110,1,4399,0,0
#+end_example

#+begin_src R :results output :session :exports both
computeType <- function(df){
  shared <-9
  write <- 4
  if(df[shared] >= 2){
    mytype <- "Shared"
  }else{
    mytype <- "Private"
  }
  if(df[write] >= 1){
     mytype <- paste(mytype,"Write" , sep="_")
  }else{
     mytype <- paste(mytype,"Read" , sep="_")
  }
  return(mytype)
}

k <- read.csv("Moca-matrix-bloc-fixaddr/Moca-framesoc.csv", header=T);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

k$Value <- apply(k,1,computeType)
k$Address <- sprintf("%f", as.numeric(paste("0x", k$Address, sep="")))
k$Phy <- NULL;
k$CPU <- NULL;
k$Tid <- NULL;
k$Reads <- NULL ;
k$Writes <- NULL ;
k$Duration <- k$End - k$Start
head(k);

g <- k
structs <- read.csv("Moca-matrix-bloc-fixaddr/matrix.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressEnd = structs$AddressStart + structs$AddressSize;

library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);
#+end_src

#+RESULTS:
#+begin_example
            X.Virt            X.Phy Nreads Nwrites CPUMask   Start     End
1 0000000000400040 000062000b0d4f90      1       0  100110       1    4399
2 0000000000400b80 000062000b0d4f90      1       0     111   14887   17767
3 0000000000400270 0000000000400270      1       0    1011 1700510 1729918
4 0000000000405435 0000000000405435      1       0     110       1    4399
5 000000000041d800 000000000041d800      1       0     110       1    4399
6 0000000000420fa0 0000000000420fa0      1       0     110       1    4399
  TaskId Shared
1      0      1
2      0      1
3      3      1
4      0      1
5      0      1
6      0      1
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
         Address   Start     End N        Value Duration
1 4194368.000000       1    4399 1 Private_Read     4398
2 4197248.000000   14887   17767 1 Private_Read     2880
3 4194928.000000 1700510 1729918 1 Private_Read    29408
4 4215861.000000       1    4399 1 Private_Read     4398
5 4315136.000000       1    4399 1 Private_Read     4398
6 4329376.000000       1    4399 1 Private_Read     4398
         Address Start   End Duration        Value N       Structure
1 6304392.000000  4400  9932     5532 Private_Read 1 UnnamedStruct#0
2 6304392.000000  4400  9932     5532 Private_Read 1 UnnamedStruct#1
3 6304392.000000  4400  9932     5532 Private_Read 1 UnnamedStruct#2
4 6304536.000000 14887 17757     2870 Private_Read 1 UnnamedStruct#0
5 6304536.000000 14887 17757     2870 Private_Read 1 UnnamedStruct#1
6 6304536.000000 14887 17757     2870 Private_Read 1 UnnamedStruct#2
#+end_example

#+begin_src R :results output graphics :file img/intensity_bloc_threads.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scales="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_bloc_threads.png]]


The interesting thing todo here is to compare the bloc version (above)
to the very naive one:
[[file:img/intensity_modulo_threads.png][file:~/Work/labbook-lucas/img/intensity_modulo_threads.png]]

We see several difference in the visualisation:
- The patterns are way more linear in the bloc version which seems
  better in regards of the cache issues
- Sharing is less intensive for the bloc version, especially in terms
  of writes: we manage to go up to 3 threads writing the same page in
  the naive version.
- For both version the 2^nd structure is accessed in an ugly way being
  completely shared, I guess it won't be inefficient for NUMA
  machines.

So I guess we have a visualisation from which we can start to see
things, the next step is to look at some other application and try to
do some improvements. We also should fix the number of addresses
issue.
