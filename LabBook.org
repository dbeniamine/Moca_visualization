#+TITLE: Beniamine's LabBook
#+AUTHOR: Beniamine
#+LATEX_HEADER: \usepackage[margin=2cm,a4paper]{geometry}
#+STARTUP: overview indent
#+TAGS: Lucas(L) David(D) noexport(n) deprecated(d)
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+SEQ_TODO: TODO(t!) STARTED(s!) WAITING(w!) | DONE(d!) CANCELLED(c!) DEFERRED(f!)

* 2016-02-17 Memory access along time (from MOCA)

David's traces have only variables. We should look to them as states.

So convert accordingly:

#+begin_src bash :results output :session :exports both
grep ^Variable Moca_matrix_bloc_20160217_Virt.pjdump | 
   awk -F, '{print "State,"$2",access,"$4","$5","$6",0,"$3}' > states_Virt.csv
grep ^Variable Moca_matrix_bloc_20160217_Phy.pjdump | 
   awk -F, '{print "State,"$2",access,"$4","$5","$6",0,"$3}' > states_Phy.csv
#+END_SRC

#+RESULTS:

Great, now let's load them into R.

#+begin_src R :results output :session :exports both
read_paje_trace <- function(file) {
  df <- read.csv(file, header=FALSE, strip.white=TRUE)
  names(df) <- c("Nature","ResourceId","Type","Start","End","Duration", "Depth", "Value")
  df$Origin=file
  m <- min(df$Start)
  df$Start <- df$Start - m
  df$End <- df$Start+df$Duration
  df$Origin <- NULL
  df$Nature <- NULL
  df$Depth <- NULL
  df
}
df_Virt <- read_paje_trace("states_Virt.csv");
df_Phy <- read_paje_trace("states_Phy.csv");
#+end_src

#+RESULTS:

#+begin_src R :results output :session :exports both
nrow(df_Virt);
nrow(df_Phy);
#+end_src

#+RESULTS:
: [1] 4478461
: [1] 4472513

The largest dataframes I have ever seen.

Let's play with care.

#+begin_src R :results output graphics :file (org-babel-temp-file "figure" ".png") :exports both :width 600 :height 400 :session
library(ggplot2);
df <- df_Virt;
df <- df[df$ResourceId == 140737310789152, ];
p <- ggplot(df) +
  theme_bw() +
  geom_segment(size=15, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId), color="black") +
  geom_segment(size=13, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value)) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[file:/tmp/babel-9357QOL/figure9357w0Z.png]]


Strange. Let's see how many *Shared_read* there are.

#+begin_src R :results output :session :exports both
nrow(df[df$Value == "Private_Read" & df$Start < 200000 & df$Start > 150000,]);
nrow(df[df$Value == "Shared_Read" & df$Start < 180000 & df$Start > 210000,]);
df[df$Start > 180000 & df$Start < 210000,]
#+end_src

#+RESULTS:
: [1] 0
: [1] 0
:          ResourceId   Type  Start    End Duration       Value
: 289172 1.407373e+14 access 189573 221868    32295 Shared_Read
: 289173 1.407373e+14 access 189573 221868    32295 Shared_Read
: 289174 1.407373e+14 access 189573 221868    32295 Shared_Read
: 289175 1.407373e+14 access 189573 221868    32295 Shared_Read

Lot's of them for this particular address. Let's zoom in.

#+begin_src R :results output graphics :file img/virt_first_try_2.png :exports both :width 600 :height 400 :session
library(ggplot2);
df <- df_Virt;
df <- df;
p <- ggplot(df) +
  theme_bw() +
  geom_segment(size=13, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value), alpha=.4) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[file:img/first_try_2.png]]



#+begin_src R :results output graphics :file img/phy_first_try_1.png :exports both :width 600 :height 400 :session
library(ggplot2);
df <- df_Phy;
df <- df;
p <- ggplot(df) +
  theme_bw() +
  geom_segment(size=13, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value), alpha=.4) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[file:img/phy_first_try_1.png]]


* 2016-02-17 Calculating intensity

_First Attempt_

I'll try with bash.

#+begin_src bash :results output :session :exports both
cat states_Virt.csv  | grep Shared_Read > states_Virt_shared_read.csv
cat states_Virt_shared_read.csv | cut -d, -f2 | sort | uniq > add_Virt
cat states_Virt_shared_read.csv  | cut -d, -f4-6 | sort | uniq  > timeslices

cat states_Virt_shared_read.csv  | cut -d, -f2,4,5,8 > states_Virt_shared_read_essential.csv
cat states_Virt_shared_read_essential.csv  | sort | uniq  > states_Virt_shared_read_essential_unique.csv
while read line ; do echo -n "$line,"; cat states_Virt_shared_read_essential.csv | grep "$line" | wc -l; done < states_Virt_shared_read_essential_unique.csv > states_Virt_shared_read_essential_unique_with_intensity.csv
#+end_src

Done. Just check the file:
+ =states_Virt_shared_read_essential_unique_with_intensity.csv=
You can load with R and play with it.

_Second Attempt_

Actually, I believe I can do it faster and cleaner with R.

#+begin_src R :results output :session :exports both
library(plyr);
k <- read.csv("states_Virt_shared_read.csv", header=FALSE);
options("scipen"=100, "digits"=4);
head(k);
#+end_src

#+RESULTS:
:      V1              V2     V3 V4   V5   V6 V7          V8
: 1 State 140737351871824 access  1 4396 4395  0 Shared_Read
: 2 State 140737351871976 access  1 4396 4395  0 Shared_Read
: 3 State 140737347542408 access  1 4396 4395  0 Shared_Read
: 4 State 140737347542640 access  1 4396 4395  0 Shared_Read
: 5 State 140737488351205 access  1 4396 4395  0 Shared_Read
: 6 State 140737488350713 access  1 4396 4395  0 Shared_Read

#+begin_src R :results output :session :exports both
sapply(k, class);
#+end_src

#+RESULTS:
:        V1        V2        V3        V4        V5        V6        V7        V8 
:  "factor" "numeric"  "factor" "integer" "integer" "integer" "integer"  "factor"

#+begin_src R :results output :session :exports both
names(k) <- c("Nature", "Address", "Type", "Start", "End", "Duration", "Imbric", "Value");
k$Nature <- NULL;
k$Type <- NULL;
k$Imbric <- NULL;
head(k);
#+end_src

#+RESULTS:
:           Address Start  End Duration       Value
: 1 140737351871824     1 4396     4395 Shared_Read
: 2 140737351871976     1 4396     4395 Shared_Read
: 3 140737347542408     1 4396     4395 Shared_Read
: 4 140737347542640     1 4396     4395 Shared_Read
: 5 140737488351205     1 4396     4395 Shared_Read
: 6 140737488350713     1 4396     4395 Shared_Read

#+begin_src R :results output :session :exports both
sapply(k, class);
#+end_src

#+RESULTS:
:   Address     Start       End  Duration     Value 
: "numeric" "integer" "integer" "integer"  "factor"

Do the magic. This command takes time.

#+begin_src R :results output :session :exports both
library(plyr);
g <- ddply(k, .(Address, Start, End, Duration, Value), summarize, N=length(Value));
head(g);
#+end_src

#+RESULTS:
:        Address Start  End Duration       Value N
: 1 1.407374e+14     1 4396     4395 Shared_Read 1
: 2 1.407374e+14     1 4396     4395 Shared_Read 1
: 3 1.407373e+14     1 4396     4395 Shared_Read 1
: 4 1.407373e+14     1 4396     4395 Shared_Read 1
: 5 1.407375e+14     1 4396     4395 Shared_Read 1
: 6 1.407375e+14     1 4396     4395 Shared_Read 1

#+begin_src R :results output :session :exports both
head(g);
sapply(g, class);
#+end_src

#+RESULTS:
:           Address Start  End Duration       Value N
: 1 140737351871824     1 4396     4395 Shared_Read 1
: 2 140737351871976     1 4396     4395 Shared_Read 1
: 3 140737347542408     1 4396     4395 Shared_Read 1
: 4 140737347542640     1 4396     4395 Shared_Read 1
: 5 140737488351205     1 4396     4395 Shared_Read 1
: 6 140737488350713     1 4396     4395 Shared_Read 1
:   Address     Start       End  Duration     Value         N 
: "numeric" "integer" "integer" "integer"  "factor" "integer"

#+begin_src R :results output :session :exports both
summary(g$N);
#+end_src

#+RESULTS:
:    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
:   1.000   2.000   3.000   3.421   5.000   8.000

#+begin_src R :results output :session :exports both
#head(g[g$Address == 140737308215152,]);
head(g[g$Address == 140737312395264,]);
median(g[g$Address > 7000000,]$Address);
#tail(g);
#+end_src

#+RESULTS:
:               Address  Start    End Duration       Value N
: 17014 140737312395264  28278  67005    38727 Shared_Read 3
: 22805 140737312395264  54041  77448    23407 Shared_Read 2
: 30183 140737312395264  67009 126332    59323 Shared_Read 3
: 33031 140737312395264  77453  90227    12774 Shared_Read 2
: 36721 140737312395264  90243 137116    46873 Shared_Read 2
: 50336 140737312395264 126336 171611    45275 Shared_Read 5
: [1] 140737314631680

#+begin_src R :results output graphics :file img/intensity_1_up.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(g[g$Address > 6304416,]) +
  theme_bw() +
  geom_segment(size=7, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_wrap(~Value, ncol=1);# + ylim(139000000000000, NA);
p
#+end_src

#+RESULTS:
[[file:img/intensity_1_up.png]]

I just can't find out the best Y scale. Let's create a histogram of
these addresses.

#+begin_src R :results output :session :exports both
h <- g[g$Address > 7304416,];
h$Address = h$Address - 140737000000000;
head(h);
#+end_src

#+RESULTS:
:     Address Start  End Duration       Value N
: 1 351871824     1 4396     4395 Shared_Read 1
: 2 351871976     1 4396     4395 Shared_Read 1
: 3 347542408     1 4396     4395 Shared_Read 1
: 4 347542640     1 4396     4395 Shared_Read 1
: 5 488351205     1 4396     4395 Shared_Read 1
: 6 488350713     1 4396     4395 Shared_Read 1

#+begin_src R :results output graphics :file img/address_histogram.png :exports both :width 600 :height 400 :session
ggplot(h, aes(Address)) + xlim(300000000, 330000000) + geom_histogram();
#+end_src

#+RESULTS:
[[file:img/address_histogram.png]]

Okay, let's try again.

#+begin_src R :results output graphics :file img/intensity_2.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(h) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_wrap(~Value, ncol=1);# + ylim(300000000, 330000000)
p
#+end_src

#+RESULTS:
[[file:img/intensity_2.png]]


Not that good, need further filtering:

#+begin_src R :results output :session :exports both
summary(h$Address);
#+end_src

#+RESULTS:
:      Min.   1st Qu.    Median      Mean   3rd Qu.      Max. 
: 271000000 310000000 315000000 315000000 319000000 488000000

Let's get only addresses from the 1st to the 3rd Qu.

#+begin_src R :results output graphics :file img/intensity_3.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(h) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_wrap(~Value, ncol=1) + ylim(310000000, 319000000)
p
#+end_src

#+RESULTS:
[[file:img/intensity_3.png]]

Finally. Let's reduce size.

#+begin_src R :results output graphics :file img/intensity_4.png :exports both :width 600 :height 800 :session
library(ggplot2);
p <- ggplot(h) +
  theme_bw() +
  geom_segment(size=0.2, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_wrap(~Value, ncol=1) + ylim(310000000, 319000000)
p
#+end_src

#+RESULTS:
[[file:img/intensity_4.png]]


#+begin_src R :results output graphics :file img/intensity_5.png :exports both :width 600 :height 2000 :session
library(ggplot2);
p <- ggplot(h) +
  theme_bw() +
  geom_segment(size=0.2, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_wrap(~Value, ncol=1) + ylim(310000000, 319000000)
p
#+end_src

#+RESULTS:
[[file:img/intensity_5.png]]

#+begin_src R :results output graphics :file img/intensity_6.png :exports both :width 600 :height 2000 :session
library(ggplot2);
p <- ggplot(h) +
  theme_bw() +
  geom_segment(size=0.5, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_wrap(~Value, ncol=1) + ylim(310000000, 311000000)
p
#+end_src

#+RESULTS:
[[file:img/intensity_6.png]]

** Old Stuff                                                    :deprecated:

Let's make rows unique, since now we have the intensity.

#+begin_src R :results output :session :exports both
h <- unique(g);
#+end_src

#+RESULTS:

#+begin_src R :results output :session :exports both
head(h);
#+end_src

#+RESULTS:
:        Address Start  End Duration       Value N
: 1 1.407374e+14     1 4396     4395 Shared_Read 1
: 2 1.407374e+14     1 4396     4395 Shared_Read 1
: 3 1.407373e+14     1 4396     4395 Shared_Read 1
: 4 1.407373e+14     1 4396     4395 Shared_Read 1
: 5 1.407375e+14     1 4396     4395 Shared_Read 1
: 6 1.407375e+14     1 4396     4395 Shared_Read 1

#+begin_src R :results output graphics :file (org-babel-temp-file "figure" ".png") :exports both :width 600 :height 400 :session
ggplot(h, aes(x=Start, y=N)) + geom_point();
#+end_src

#+RESULTS:
[[file:/tmp/babel-9357QOL/figure9357x8U.png]]

* 2016-02-23 New traces

I got a new tarbal from David, here's its MD5 signature.

#+begin_src sh :results output :session :exports both
md5sum ../Moca-matrix.tgz
#+end_src

#+RESULTS:
: 7a81360ff13bcdd0cb3dc23e5b006805  ../Moca-matrix.tgz

Extracting the data in the =v2= directory.

#+begin_src sh :results output :session :exports both
mkdir -p v2; cd v2; tar xfz ../../Moca-matrix.tgz; mv Moca-matrix-bloc/* .; rm -rf Moca-matrix-bloc;
#+end_src

#+RESULTS:

List contents:

#+begin_src sh :results output :session :exports both
pwd
ls -hl v2
#+end_src

#+RESULTS:
: /home/schnorr/TRACES/david/Moca-matrix-bloc
: total 1.1G
: -rw-r--r-- 1 schnorr schnorr  126 Feb 17 10:54 matrix.stackmap.csv
: -rw-r--r-- 1 schnorr schnorr  331 Feb 17 10:54 matrix.structs.csv
: -rw-r--r-- 1 schnorr schnorr 317M Feb 18 13:31 Moca-framesoc.csv
: -rw-r--r-- 1 schnorr schnorr  94M Feb 17 10:54 Moca-full-trace.csv
: -rw-r--r-- 1 schnorr schnorr 351M Feb 18 14:01 Moca_matrix_bloc_20160218Virt.pjdump
: -rw-r--r-- 1 schnorr schnorr 301M Feb 18 14:31 states

Great, now we are ready to start again.

* 2016-02-23 Playing with new traces

It looks like I only get virtual mem addresses this time. Okay.

#+begin_src sh :results output :session :exports both
cd v2
grep ^Variable Moca_matrix_bloc_20160218Virt.pjdump | 
   awk -F, '{print "State,"$2",access,"$4","$5","$6",0,"$3}' > states_Virt.csv
#+end_src

#+RESULTS:

I have noticed that some durations are negative. See:

#+begin_src sh :results output :session :exports both
cd v2
cat states_Virt.csv | grep "-" | head
#+end_src

#+RESULTS:
#+begin_example
State,140737305567232,access,17863,17762,-101,0,Shared_Read
State,140737305567232,access,17863,17762,-101,0,Shared_Read
State,140737305569152,access,17863,17762,-101,0,Shared_Read
State,140737305599152,access,17863,17762,-101,0,Shared_Read
State,140737305599152,access,17863,17762,-101,0,Shared_Read
State,140737305595904,access,17863,17762,-101,0,Shared_Read
State,140737305611152,access,17863,17762,-101,0,Shared_Read
State,140737305608192,access,17863,17762,-101,0,Shared_Read
State,140737305623152,access,17863,17762,-101,0,Shared_Read
State,140737305623152,access,17863,17762,-101,0,Shared_Read
#+end_example

_Summary_:
- Negative durations (probably an error)

* 2016-02-23 Removing durations with negative values                  :Lucas:

Okay, let's proceed anyway, removing the problem.

#+begin_src sh :results output :session :exports both
cd v2
cat states_Virt.csv | grep -v "-" > states_Virt_without_neg_durations.csv
#+end_src

#+RESULTS:

Great, now let's load it.

#+begin_src R :results output :session :exports both
read_paje_trace <- function(file) {
  df <- read.csv(file, header=FALSE, strip.white=TRUE)
  names(df) <- c("Nature","ResourceId","Type","Start","End","Duration", "Depth", "Value")
  df$Origin=file
  m <- min(df$Start)
  df$Start <- df$Start - m
  df$End <- df$Start+df$Duration
  df$Origin <- NULL
  df$Nature <- NULL
  df$Depth <- NULL
  df
}
df_Virt <- read_paje_trace("v2/states_Virt_without_neg_durations.csv");
#+end_src

#+RESULTS:

#+begin_src R :results output :session :exports both
df <- df_Virt;
df$Type <- NULL;
head(df);
#+end_src

#+RESULTS:
:   ResourceId Start  End Duration         Value
: 1    4656816     0 4395     4395  Private_Read
: 2    6303348     0 4395     4395  Private_Read
: 3    6303348     0 4395     4395 Private_Write
: 4    6303752     0 4395     4395  Private_Read
: 5    6303752     0 4395     4395 Private_Write
: 6    7330440     0 4395     4395  Private_Read

#+begin_src R :results output graphics :file img/Moca_matrix_bloc_20160218Virt_overview.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(df) +
  theme_bw() +
  geom_segment(size=13, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value), alpha=.4) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[./img/Moca_matrix_bloc_20160218Virt_overview.png]]

Let's remove =Shared_Write= and =Private_Write=.

#+begin_src R :results output graphics :file img/Moca_matrix_bloc_20160218Virt_filter_1.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(df[df$Value != "Private_Write" & df$Value != "Shared_Write",]) +
  theme_bw() +
  geom_segment(size=13, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value), alpha=.4) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[file:img/Moca_matrix_bloc_20160218Virt_filter_1.png]]

Let's zoom in to the beginning, reduce segment size:

#+begin_src R :results output graphics :file img/Moca_matrix_bloc_20160218Virt_filter_2.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(df[df$Value != "Private_Write" & df$Value != "Shared_Write",]) +
  theme_bw() +
  geom_segment(size=1, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value), alpha=.4) +
  facet_wrap(~Value, ncol=1) + xlim(0, 90243);
p
#+end_src

#+RESULTS:
[[file:img/Moca_matrix_bloc_20160218Virt_filter_2.png]]

That's strange the middle with nothing. The problem is this:

#+begin_src sh :results output :session :exports both
cat v2/states_Virt_without_neg_durations.csv | cut -d, -f2 | head -n30 | cat -n
#+end_src

#+RESULTS:
#+begin_example
     1	4656816
     2	6303348
     3	6303348
     4	6303752
     5	6303752
     6	7330440
     7	7330440
     8	7341840
     9	7341840
    10	8700368
    11	8700368
    12	8737104
    13	8737104
    14	8784688
    15	8784688
    16	8787648
    17	8787648
    18	8790320
    19	8790320
    20	140152691697344
    21	140152691777685
    22	140152691881456
    23	140152691913632
    24	140152692128528
    25	140152692183424
    26	140152692227168
    27	140152692306624
    28	140152692447204
    29	140152692585408
    30	140152692856576
#+end_example

The first 19 events have very low addresses. All other addresses are
much larger. That's why we have those blank spaces in the plot. We
should remove these low addresses. Sorting these events numerically
indicates that I should look only to addresses between 
140152691697344 and 
140737488351205.

#+begin_src R :results output :session :exports both
sapply(df, class);
#+end_src

#+RESULTS:
: ResourceId      Start        End   Duration      Value 
:  "numeric"  "integer"  "integer"  "integer"   "factor"

Great, we can filter easily.

#+begin_src R :results output graphics :file img/Moca_matrix_bloc_20160218Virt_filter_3.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(
  df[df$Value != "Private_Write" &
  df$Value != "Shared_Write" &
  df$ResourceId >= 140152691697344 &
  df$ResourceId <= 140737488351205,]) +
  theme_bw() +
  geom_segment(size=1, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value), alpha=.4) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[file:img/Moca_matrix_bloc_20160218Virt_filter_3.png]]

That didn't work. Let's create a histogram:


#+begin_src R :results output :session :exports both

#+end_src


#+begin_src R :results output graphics :file img/Moca_matrix_bloc_20160218Virt_ResourceId_histogram.png :exports both :width 600 :height 400 :session
ggplot(df, aes(ResourceId)) + geom_histogram() + theme_bw();
#+end_src

#+RESULTS:
[[file:img/Moca_matrix_bloc_20160218Virt_ResourceId_histogram.png]]

Okay, let's zoom in:


#+begin_src R :results output graphics :file img/Moca_matrix_bloc_20160218Virt_ResourceId_histogram_1.png :exports both :width 600 :height 400 :session
ggplot(df, aes(ResourceId)) + geom_histogram() + theme_bw() + xlim(1.4073e+14,NA);
#+end_src

#+RESULTS:
[[file:img/Moca_matrix_bloc_20160218Virt_ResourceId_histogram_1.png]]

Okay, limits should be =xlim(1.4073e+14,NA)=.

#+begin_src R :results output graphics :file img/Moca_matrix_bloc_20160218Virt_filter_4.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(
  df[df$Value != "Private_Write" &
  df$Value != "Shared_Write" &
  df$ResourceId >= 1.4073e+14,]) +
  theme_bw() +
  geom_segment(size=1, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value), alpha=.4) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[file:img/Moca_matrix_bloc_20160218Virt_filter_4.png]]


Now we are finally going somewhere. ResourceId filtering is essential.

Let's go on, limiting the upper bound.

#+begin_src R :results output graphics :file img/Moca_matrix_bloc_20160218Virt_filter_5.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(
  df[df$Value != "Private_Write" &
  df$Value != "Shared_Write" &
  df$ResourceId >= 1.4073e+14 &
  df$ResourceId <= 1.407374e+14,]) +
  theme_bw() +
  geom_segment(size=1, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value), alpha=.4) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[file:img/Moca_matrix_bloc_20160218Virt_filter_5.png]]

Great. I stop here for now.

The problem for me is to correctly define the Address bounds for the
visualization. Since MOCA dumps really every single memory address
accessed (no matter where), and we don't know which part we should
look for, the prototype should allow an easy search methodology in the
address space (pretty much following what I have done above, but
automatically). Then, and only then, plot things.


Some recomendations:
- filter by memory address in MOCA (if intrusion is acceptable)
- create a script to easily filter by memory address interval
  - automatic address interval selection should be possible

Future analysis methodology:
- I am using alpha values to draw segments, but I shouldn't.
  - Intensity should correlate with number of concurrent mem access.
  - So, a preprocessing of the trace do the magic
    - Take a look at [[*2016-02-17 Calculating intensity][2016-02-17 Calculating intensity]] to see how to
  - Then plot as usual after all this filtering stuff mentioned above

* 2016-02-24 Answers for questions of previous section                :David:
- The filtering on the address space can be done using the structs.csv and stackmaps.csv
that provides addresses, name and size of the various data structures
and stacks. 
In Ocelotl, I usually filter out all the addresses that are not in a
data structure at import time. Still it can be interesting to do it
during the preprocessing phase.
Sadly I realized yesterday that Pin (the tool that I am using to
record data structure addresses) was providing bad addresses, thus the
filter won't work this the trace version two.
This issue is not yet completly fixed but there is a trace with
manually fixed data structure addresses and with the address space
already reduced to data structures:
 https://ligcloud.imag.fr/public.php?service=files&t=13b4b28b657943bdf7c4d31d6a7a18ba
- The idea of Moca is to provide a trace as precise as possible, we don't know a priori what
we are looking for, thus I'd rather avoid filtering during tracing.
- The preprocessing can also be done when we detect sharing, currently when I dectect that
two threads are sharing a page, I create to different accesses. I
could create only one access to the page with a value of two. Still
with this reprensentation, we only now the address of the shared page
and loose the precise addresses of each accesses.

* 2016-02-25 New trace / Redo analysis / Try to be faster in filtering :Lucas:

I have been provided with a new trace.

#+begin_src sh :results output :session :exports both
md5sum matrix.tgz
#+end_src

#+RESULTS:
: 098f7ee5632a20cf82290737e89c3ad2  matrix.tgz

#+begin_src sh :results output :session :exports both
tar xfz matrix.tgz
#+end_src

#+RESULTS:

#+begin_src sh :results output :session :exports both
ls -1 Moca-matrix-bloc-fixaddr/
#+end_src

#+RESULTS:
: matrix.stackmap.csv
: matrix.structs.csv
: Moca-framesoc.csv
: Moca_matrix_bloc_fixaddr_20160222_144532_CET_Physical_6.pjdump
: Moca_matrix_bloc_fixaddr_20160223_172342_CET_Physical_6.pjdump
: Moca_matrix_bloc_fixaddr_20160223_172342_CET_Virtual_7.pjdump

David told me the file =matrix.structs.csv= has information about the
memory addresses of main data structures, the ones I should be looking
for. Here's the contents:

#+begin_src sh :results output :session :exports both
cat Moca-matrix-bloc-fixaddr/matrix.structs.csv
#+end_src

#+RESULTS:
: name,start,sz
: __GI___pthread_keys,2196192,16384
: __pthread_keys,2196192,16384
: UnnamedStruct#0,6303760,5280
: UnnamedStruct#1,6303888,32816
: UnnamedStruct#2,6303888,32816
: /tmp/matrix/matrix_naif.c:122,140737323565072,18000000
: /tmp/matrix/matrix_naif.c:123,140737305563152,18000000
: /tmp/matrix/matrix_naif.c:123,140737287561232,18000000

Great, let's focus our analysis below in addresses starting at
- 140737305563152 up to 140737305563152+18000000

First, convert to =states=, using bash.

#+begin_src sh :results output :session :exports both
UNIQFILE=Moca_matrix_bloc_fixaddr_20160223_172342_CET_Virtual_7
cat Moca-matrix-bloc-fixaddr/${UNIQFILE}.pjdump | grep ^Variable |
   awk -F, '{print "State,"$2",access,"$4","$5","$6",0,"$3}' > ${UNIQFILE}-states.csv
#+end_src

#+RESULTS:

Now, calculate intensity as in:
- [[*2016-02-17 Calculating intensity][2016-02-17 Calculating intensity]]

#+begin_src R :results output :session :exports both
k <- read.csv("Moca_matrix_bloc_fixaddr_20160223_172342_CET_Virtual_7-states.csv", header=FALSE);
options("scipen"=100, "digits"=4);
head(k);
#+end_src

#+RESULTS:
:      V1      V2     V3 V4   V5   V6 V7            V8
: 1 State 4656816 access  1 4399 4398  0  Private_Read
: 2 State 6303500 access  1 4399 4398  0  Private_Read
: 3 State 6303500 access  1 4399 4398  0 Private_Write
: 4 State 6303752 access  1 4399 4398  0  Private_Read
: 5 State 6303752 access  1 4399 4398  0 Private_Write
: 6 State 7330440 access  1 4399 4398  0  Private_Read

#+begin_src R :results output :session :exports both
sapply(k, class);
#+end_src

#+RESULTS:
:        V1        V2        V3        V4        V5        V6        V7        V8 
:  "factor" "numeric"  "factor" "integer" "integer" "integer" "integer"  "factor"

#+begin_src R :results output :session :exports both
names(k) <- c("Nature", "Address", "Type", "Start", "End", "Duration", "Imbric", "Value");
k$Niature <- NULL;
k$Type <- NULL;
k$Imbric <- NULL;
head(k);
#+end_src

#+RESULTS:
:   Address Start  End Duration         Value
: 1 4656816     1 4399     4398  Private_Read
: 2 6303500     1 4399     4398  Private_Read
: 3 6303500     1 4399     4398 Private_Write
: 4 6303752     1 4399     4398  Private_Read
: 5 6303752     1 4399     4398 Private_Write
: 6 7330440     1 4399     4398  Private_Read

#+begin_src R :results output :session :exports both
sapply(k, class);
#+end_src

#+RESULTS:
:   Address     Start       End  Duration     Value 
: "numeric" "integer" "integer" "integer"  "factor"

Do the magic. This command takes time.

#+begin_src R :results output :session :exports both
library(plyr);
g <- ddply(k, .(Address, Start, End, Duration, Value), summarize, N=length(Value));
head(g);
#+end_src

*Attention*: I aborted the command above since I was waiting for too long.

Let's try again with dplyr.

#+begin_src R :results output :session :exports both
library(dplyr);
#+end_src

#+RESULTS:
#+begin_example

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union
#+end_example

See this introduction to _dplyr_ (specially tthe section on chaining):
https://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html

Okay, let's write new code:

#+begin_src R :results output :session :exports both
g <- k %>%
       group_by(Address, Start, End, Duration, Value) %>%
       summarize(N = length(Value));
#+end_src

#+RESULTS:

It was fast (I think around a minute in my machine).

#+begin_src R :results output :session :exports both
nrow(g);
head(g);
#+end_src

#+RESULTS:
#+begin_example
[1] 3368394
Source: local data frame [6 x 6]
Groups: Address, Start, End, Duration

  Address   Start     End Duration         Value N
1 4194928 1700510 1729918    29408  Private_Read 1
2 4197248   14887   17767     2880  Private_Read 1
3 4656816       1    4399     4398  Private_Read 1
4 6303496   14887   17767     2880  Private_Read 1
5 6303500       1    4399     4398  Private_Read 1
6 6303500       1    4399     4398 Private_Write 1
#+end_example

Filter out the space address:
- 140737305563152 up to 140737305563152+18000000

#+begin_src R :results output :session :exports both
head(g[g$Address >= 140737305563152 & g$Address <= 140737305563152+18000000,]);
#+end_src

#+RESULTS:
#+begin_example
Source: local data frame [6 x 6]
Groups: Address, Start, End, Duration

          Address Start   End Duration         Value N
1 140737305563152  4400  9932     5532  Private_Read 1
2 140737305563152  4400  9932     5532 Private_Write 1
3 140737305563152 17734 17757       23  Private_Read 1
4 140737305563152 17757 20391     2634   Shared_Read 2
5 140737305563152 20391 27232     6841  Private_Read 1
6 140737305563152 27232 32008     4776   Shared_Read 2
#+end_example

It worked, but it was a little slow. Let's also use =dplyr=.

#+begin_src R :results output :session :exports both
h <- g %>% filter(Address >= 140737305563152 & Address <= 140737305563152+18000000);
#+end_src

#+RESULTS:

My feeling is that it was slower.

#+begin_src R :results output :session :exports both
head(h);
#+end_src

#+RESULTS:
#+begin_example
Source: local data frame [6 x 6]
Groups: Address, Start, End, Duration

          Address Start   End Duration         Value N
1 140737305563152  4400  9932     5532  Private_Read 1
2 140737305563152  4400  9932     5532 Private_Write 1
3 140737305563152 17734 17757       23  Private_Read 1
4 140737305563152 17757 20391     2634   Shared_Read 2
5 140737305563152 20391 27232     6841  Private_Read 1
6 140737305563152 27232 32008     4776   Shared_Read 2
#+end_example

Let's plot the intensity of =h= anyway:


#+begin_src R :results output graphics :file img/intensity_fixaddr_v1.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(h) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[file:img/intensity_fixaddr_v1.png]]

That's precise.

* 2016-02-25 Merge access information with data structure information :Lucas:

Let's look to another data structure, ow, much better, let's change
our data frame to contain such information.

#+begin_src R :results output :session :exports both
head(g);
#+end_src

#+RESULTS:
#+begin_example
Source: local data frame [6 x 6]
Groups: Address, Start, End, Duration

  Address   Start     End Duration         Value N
1 4194928 1700510 1729918    29408  Private_Read 1
2 4197248   14887   17767     2880  Private_Read 1
3 4656816       1    4399     4398  Private_Read 1
4 6303496   14887   17767     2880  Private_Read 1
5 6303500       1    4399     4398  Private_Read 1
6 6303500       1    4399     4398 Private_Write 1
#+end_example

#+begin_src R :results output :session :exports both
structs <- read.csv("Moca-matrix-bloc-fixaddr/matrix.structs.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressEnd = structs$AddressStart + structs$AddressSize;

#+end_src

#+RESULTS:
:                       Structure    AddressStart AddressSize      AddressEnd
: 1           __GI___pthread_keys         2196192       16384         2212576
: 2                __pthread_keys         2196192       16384         2212576
: 3               UnnamedStruct#0         6303760        5280         6309040
: 4               UnnamedStruct#1         6303888       32816         6336704
: 5               UnnamedStruct#2         6303888       32816         6336704
: 6 /tmp/matrix/matrix_naif.c:122 140737323565072    18000000 140737341565072
: 7 /tmp/matrix/matrix_naif.c:123 140737305563152    18000000 140737323563152
: 8 /tmp/matrix/matrix_naif.c:123 140737287561232    18000000 140737305561232

I'll have to use =sqldf= I think.

#+begin_src R :results output :session :exports both
library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);
#+end_src

#+RESULTS:
#+begin_example
Loading required package: gsubfn
Loading required package: proto
Loading required package: RSQLite
Loading required package: DBI
 Loading required package: tcltk
  Address Start    End Duration        Value N       Structure
1 6304392  4400   9932     5532 Private_Read 1 UnnamedStruct#0
2 6304392  4400   9932     5532 Private_Read 1 UnnamedStruct#1
3 6304392  4400   9932     5532 Private_Read 1 UnnamedStruct#2
4 6304416 87595 101980    14385  Shared_Read 1 UnnamedStruct#0
5 6304416 87595 101980    14385  Shared_Read 1 UnnamedStruct#1
6 6304416 87595 101980    14385  Shared_Read 1 UnnamedStruct#2
#+end_example

Ow, that was fast.

Let's plot:

#+begin_src R :results output graphics :file img/intensity_fixaddr_with_structure_v1.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_wrap(~Value, ncol=1) + facet_wrap(~Structure,ncol=1) +
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_fixaddr_with_structure_v1.png]]

The Y axis should be independent. I should also use =facet_grid= to
different by access type. Ow, I just realized I made two =facet_wrap=.


#+begin_src R :results output graphics :file img/intensity_fixaddr_with_structure_v2.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_grid(Structure~Value, scales="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_fixaddr_with_structure_v2.png]]

That's great.

Using color as factor.

#+begin_src R :results output graphics :file img/intensity_fixaddr_with_structure_v3.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scales="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_fixaddr_with_structure_v3.png]]


Strange. It is either one or two accesses only.

Is that normal for this application?

* 2016-02-25 Answer to questions of previous section                  :David:

The last image start to be quite interesting but there are several
issues:

** DONE Issue with visualization from file:img/intensity_fixaddr_with_structure_v2.png  [3/3]
- State "DONE"       from "STARTED"    [2016-02-26 Fri 13:40]
- State "STARTED"    from "TODO"       [2016-02-25 Thu 15:42]

*** DONE Number of writes
- State "DONE"       from "WAITING"    [2016-02-25 Thu 15:41]
- State "WAITING"    from "STARTED"    [2016-02-25 Thu 15:41]
- State "STARTED"    from "TODO"       [2016-02-25 Thu 15:41]
The visulisation contans only reads. Around a fourth of the accesses
should be writes. Where does this come from ?

Ok let see where does it comes from first, check that I'm working on
the same files than Lucas:

#+begin_src sh :results output :session :exports both
md5sum matrix.tgz
#+end_src

#+RESULTS:
: 098f7ee5632a20cf82290737e89c3ad2  matrix.tgz

seems to be the good ones, let's take a look

#+begin_src sh :results output :session :exports both
tar xvzf matrix.tgz
#+end_src

#+RESULTS:
: Moca-matrix-bloc-fixaddr/
: Moca-matrix-bloc-fixaddr/Moca_matrix_bloc_fixaddr_20160223_172342_CET_Virtual_7.pjdump
: Moca-matrix-bloc-fixaddr/Moca-framesoc.csv
: Moca-matrix-bloc-fixaddr/Moca_matrix_bloc_fixaddr_20160223_172342_CET_Physical_6.pjdump
: Moca-matrix-bloc-fixaddr/matrix.structs.csv
: Moca-matrix-bloc-fixaddr/matrix.stackmap.csv
: Moca-matrix-bloc-fixaddr/Moca_matrix_bloc_fixaddr_20160222_144532_CET_Physical_6.pjdump

Let's take a look at the main file

#+begin_src sh :results output :exports both
head Moca-matrix-bloc-fixaddr/Moca-framesoc.csv
#+end_src

#+RESULTS:
#+begin_example
@Virt,@Phy,Nreads,Nwrites,CPUMask,Start,End,TaskId,Shared
0000000000400040,000062000b0d4f90,1,0,000100110,1,4399,0,0
0000000000400b80,000062000b0d4f90,1,0,000000111,14887,17767,0,0
0000000000400270,0000000000400270,1,0,000001011,1700510,1729918,3,0
0000000000405435,0000000000405435,1,0,000000110,1,4399,0,0
000000000041d800,000000000041d800,1,0,000000110,1,4399,0,0
0000000000420fa0,0000000000420fa0,1,0,000000110,1,4399,0,0
00000000004341e1,00000000004341e1,1,0,000000110,1,4399,0,0
000000000044677a,000000000044677a,1,0,000000110,1,4399,0,0
000000000045dca0,000000000045dca0,1,0,000000110,1,4399,0,0
#+end_example

So the number of writes is the field number 4, lets count the number
of reads and writes in this file.

#+begin_src sh :results output :exports both
awk -F , 'BEGIN{r=0;w=0} {if($3>0){r++};if($4>0){w++}} END{print r" reads and "w" writes"}' Moca-matrix-bloc-fixaddr/Moca-framesoc.csv
#+end_src

#+RESULTS:
: 5479661 reads and 18285 writes

Ok the difference is way more than a factor 2 or 3 ...
I've recovered the original trace file (not processed) that is not in
the archive. it has the same headers as framesoc file without the last
field, thus the previous command should work on it.

#+begin_src sh :results output :exports both
awk -F , 'BEGIN{r=0;w=0} {if($3>0){r++};if($4>0){w++}} END{print r" reads and "w" writes"}' Moca-matrix-bloc-fixaddr/Moca-full-trace.csv
#+end_src

#+RESULTS:
: 1194354 reads and 17629 writes

#+begin_src sh :results output :exports both
echo 1194354 / 17629 | bc -l 
echo 5479661 / 1194354 | bc -l
echo 18285 / 17629 | bc -l 
#+end_src

#+RESULTS:
: 67.74939020931419819615
: 4.58797056819000061958
: 1.03721141301264961143

So in the raw trace we have already 67.8 more reads than write, event
if we admit that most accessses are reads and each writes also
triggers a read, it's a lot more than what I expected, I guess that I
should work on the way Moca decide if an access is a read or a write.

Still it is also weird that the post processing multiply by 4.6 the
number of reads while it almost doesn't change the number of
writes. I guess it comes from the fact that the number of accesses is
increased only when a shared is detected and according to the last
visualisation every write are private (and actually correspond to the
initialisation).

For now we will consider that this issue comes from Moca collection system.

*** DONE Duplicate data structure name
- State "DONE"       from "TODO"       [2016-02-26 Fri 11:20]
There are two entries in the structs.csv file with the same name, thus
they are merged in the visu

First make the name of data structures unique

#+begin_src sh :results output :exports both
awk -F , 'BEGIN{p="";cpt=1} {if(p==$1){n=$1"-"cpt;cpt++}\
else{cpt=1;n=$1};p=$1;print n","$2","$3}' \
Moca-matrix-bloc-fixaddr/matrix.structs.csv > Moca-matrix-bloc-fixaddr/matrix.structs-uniq.csv
cat  Moca-matrix-bloc-fixaddr/matrix.structs-uniq.csv
#+end_src

#+RESULTS:
: name,start,sz
: __GI___pthread_keys,2196192,16384
: __pthread_keys,2196192,16384
: UnnamedStruct#0,6303760,5280
: UnnamedStruct#1,6303888,32816
: UnnamedStruct#2,6303888,32816
: /tmp/matrix/matrix_naif.c:122,140737323565072,18000000
: /tmp/matrix/matrix_naif.c:123,140737305563152,18000000
: /tmp/matrix/matrix_naif.c:123-1,140737287561232,18000000

Better, now let's redo the analysis from [[*2016-02-25 New trace / Redo analysis / Try to be faster in filtering][2016-02-25 New trace / Redo analysis / Try to be faster in filtering]]  

#+begin_src sh :results output :session :exports both
UNIQFILE=Moca_matrix_bloc_fixaddr_20160223_172342_CET_Virtual_7
cat Moca-matrix-bloc-fixaddr/${UNIQFILE}.pjdump | grep ^Variable |
   awk -F, '{print "State,"$2",access,"$4","$5","$6",0,"$3}' > ${UNIQFILE}-states.csv
head ${UNIQFILE}-states.csv
#+end_src

#+RESULTS:
#+begin_example
State,4656816,access,1,4399,4398,0,Private_Read
State,6303500,access,1,4399,4398,0,Private_Read
State,6303500,access,1,4399,4398,0,Private_Write
State,6303752,access,1,4399,4398,0,Private_Read
State,6303752,access,1,4399,4398,0,Private_Write
State,7330440,access,1,4399,4398,0,Private_Read
State,7330440,access,1,4399,4398,0,Private_Write
State,7341840,access,1,4399,4398,0,Private_Read
State,7341840,access,1,4399,4398,0,Private_Write
State,7370576,access,1,4399,4398,0,Private_Read
#+end_example

Now, calculate intensity as in:
- [[*2016-02-17 Calculating intensity][2016-02-17 Calculating intensity]]

#+begin_src R :results output :session :exports both
k <- read.csv("Moca_matrix_bloc_fixaddr_20160223_172342_CET_Virtual_7-states.csv", header=FALSE);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Nature", "Address", "Type", "Start", "End", "Duration", "Imbric", "Value");
k$Niature <- NULL;
k$Type <- NULL;
k$Imbric <- NULL;
head(k);

sapply(k, class);

library(dplyr);

g <- k %>%
       group_by(Address, Start, End, Duration, Value) %>%
       summarize(N = length(Value));


nrow(g);
head(g);
h <- g %>% filter(Address >= 140737305563152 & Address <= 140737305563152+18000000);
head(h)
#+end_src

#+RESULTS:
#+begin_example
     V1      V2     V3 V4   V5   V6 V7            V8
1 State 4656816 access  1 4399 4398  0  Private_Read
2 State 6303500 access  1 4399 4398  0  Private_Read
3 State 6303500 access  1 4399 4398  0 Private_Write
4 State 6303752 access  1 4399 4398  0  Private_Read
5 State 6303752 access  1 4399 4398  0 Private_Write
6 State 7330440 access  1 4399 4398  0  Private_Read
       V1        V2        V3        V4        V5        V6        V7        V8 
 "factor" "numeric"  "factor" "integer" "integer" "integer" "integer"  "factor"
  Nature Address Start  End Duration         Value
1  State 4656816     1 4399     4398  Private_Read
2  State 6303500     1 4399     4398  Private_Read
3  State 6303500     1 4399     4398 Private_Write
4  State 6303752     1 4399     4398  Private_Read
5  State 6303752     1 4399     4398 Private_Write
6  State 7330440     1 4399     4398  Private_Read
   Nature   Address     Start       End  Duration     Value 
 "factor" "numeric" "integer" "integer" "integer"  "factor"
[1] 3368394
Source: local data frame [6 x 6]
Groups: Address, Start, End, Duration [5]

  Address   Start     End Duration         Value     N
    (dbl)   (int)   (int)    (int)        (fctr) (int)
1 4194928 1700510 1729918    29408  Private_Read     1
2 4197248   14887   17767     2880  Private_Read     1
3 4656816       1    4399     4398  Private_Read     1
4 6303496   14887   17767     2880  Private_Read     1
5 6303500       1    4399     4398  Private_Read     1
6 6303500       1    4399     4398 Private_Write     1
Source: local data frame [6 x 6]
Groups: Address, Start, End, Duration [5]

          Address Start   End Duration         Value     N
            (dbl) (int) (int)    (int)        (fctr) (int)
1 140737305563152  4400  9932     5532  Private_Read     1
2 140737305563152  4400  9932     5532 Private_Write     1
3 140737305563152 17734 17757       23  Private_Read     1
4 140737305563152 17757 20391     2634   Shared_Read     2
5 140737305563152 20391 27232     6841  Private_Read     1
6 140737305563152 27232 32008     4776   Shared_Read     2
#+end_example


Finally redo the plot v3 from [[*2016-02-25 Merge access information with data structure information][2016-02-25 Merge access information with data structure information]] 

#+begin_src R :results output graphics :file img/intensity_fixaddr_with_structure_v4.png :exports both :width 600 :height 400 :session
structs <- read.csv("Moca-matrix-bloc-fixaddr/matrix.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressEnd = structs$AddressStart + structs$AddressSize;

library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);


library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scales="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_fixaddr_with_structure_v4.png]]

Now this fix the non unique structure name issue.

*** DONE Importance of data structures
- State "DONE"       from "TODO"       [2016-02-26 Fri 13:40]
It seems that the last three data structures are not as
important as the first, but it is not clear, maybe plotting the
number of reads/write per structure would help determining if we can
ignore them.

Let's try to plot the number of accesses to each data structure:

#+begin_src R :results output :session :exports both
head(m)
library(plyr)
n <- ddply(m,c("Structure"),summarize,Nacc=sum(N));
head(n)
#+end_src

#+RESULTS:
#+begin_example
  Address Start    End Duration        Value N       Structure
1 6304392  4400   9932     5532 Private_Read 1 UnnamedStruct#0
2 6304392  4400   9932     5532 Private_Read 1 UnnamedStruct#1
3 6304392  4400   9932     5532 Private_Read 1 UnnamedStruct#2
4 6304416 87595 101980    14385  Shared_Read 1 UnnamedStruct#0
5 6304416 87595 101980    14385  Shared_Read 1 UnnamedStruct#1
6 6304416 87595 101980    14385  Shared_Read 1 UnnamedStruct#2
Error: length(rows) == 1 is not TRUE
                        Structure    Nacc
1   /tmp/matrix/matrix_naif.c:122   17508
2   /tmp/matrix/matrix_naif.c:123 5453604
3 /tmp/matrix/matrix_naif.c:123-1   24981
4                 UnnamedStruct#0    1214
5                 UnnamedStruct#1    1214
6                 UnnamedStruct#2    1214
#+end_example

ok let's plot it
#+begin_src R :results output graphics :file img/struct_importance_fixaddr_v1.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(n,aes(x=Structure,y=Nacc, fill=Structure)) +
  theme_bw() +
  geom_bar(stat="identity")
p
#+end_src

#+RESULTS:
[[file:img/struct_importance_fixaddr_v1.png]]

We can't see anything, let's try in log scale

#+begin_src R :results output graphics :file img/struct_importance_fixaddr_v2.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(n,aes(x=Structure,y=Nacc, fill=Structure)) +
  geom_bar(stat="identity") +
  theme_bw() +
  theme(panel.grid.minor = element_line(colour = "black", linetype="dashed", size = 0.1),
    panel.grid.major = element_line(colour = "black", size = 0.1)) +
  scale_y_log10()
  #lab=("Data structure name") +
  #ylab=("Number of accesses") +
p
#+end_src

#+RESULTS:
[[file:img/struct_importance_fixaddr.png]]


Better, so the unamed structures are indeed less accessed (about half
an order) but I don't think it's enough to neglect them.


** Conclusions

The visualisation is starting to be intersting, from those small test
we have seen several "weird" things:
- The number of access is always 1 or 2: I guess it comes from Moca
  tracing method usually there should be only 1 page fault (thus one
  access) per chunk having more than one access should be rare as it
  means a very specific order of accesses between two threads. Instead
  of plotting the intensity of accesses, we should probably plot the
  intensity in terms of number of threads.
- The detection of writes in Moca seems bad, I'll try to fix that

* 2016-02-29 Try on new traces                                        :David:

Moca's code to detect if an access is a read or a write seems correct,
the difference comes from the sampling, so we will try to look at some
other traces and compare them.

** Matrix modulo

The first trace we were studing is a naive matrix multiplication by
blocs, the next trace is an even more naive algorithm were threads
works on close piece of data.

The new trace is available on ligcloud:

We do the same analysis as here [[*Duplicate data structure name][Duplicate data structure name]]

#+begin_src sh :results output :exports both
DIR=Moca-matrix-modulo-2016-02-29_11-14-03
awk -F , 'BEGIN{p="";cpt=1} {if(p==$1){n=$1"-"cpt;cpt++}\
else{cpt=1;n=$1};p=$1;print n","$2","$3}' \
$DIR/matrix.structs.csv > $DIR/matrix.structs-uniq.csv
cat  $DIR/matrix.structs-uniq.csv
#+end_src

#+RESULTS:
: -1,,
: __GI___pthread_keys,2196192,16384
: __pthread_keys,2196192,16384
: UnnamedStruct#0,6303760,5280
: UnnamedStruct#1,6303888,32816
: UnnamedStruct#2,6303888,32816
: /home/david/Work/Bench/matrix/matrix_naif.c:140,140737313341456,8000000
: /home/david/Work/Bench/matrix/matrix_naif.c:123,140737321345040,8000000
: /home/david/Work/Bench/matrix/matrix_naif.c:122,140737329348624,8000000

Better, now let's redo the analysis from [[*2016-02-25 New trace / Redo analysis / Try to be faster in filtering][2016-02-25 New trace / Redo analysis / Try to be faster in filtering]]  

#+begin_src sh :results output :session :exports both
DIR=Moca-matrix-modulo-2016-02-29_11-14-03
UNIQFILE=$DIR/Moca_matrix_modulo_2016_02_29_11_14_03_20160229_112157_CET_Virtual_4
cat ${UNIQFILE}.pjdump | grep ^Variable |
   awk -F, '{print "State,"$2",access,"$4","$5","$6",0,"$3}' > ${UNIQFILE}-states.csv
head ${UNIQFILE}-states.csv
#+end_src

#+RESULTS:
#+begin_example
State,6303348,access,1,3492,3491,0,Private_Read
State,6303348,access,1,3492,3491,0,Private_Write
State,6303752,access,1,3492,3491,0,Private_Read
State,6303752,access,1,3492,3491,0,Private_Write
State,7330216,access,1,3492,3491,0,Private_Read
State,7330216,access,1,3492,3491,0,Private_Write
State,7332280,access,1,3492,3491,0,Private_Read
State,7332280,access,1,3492,3491,0,Private_Write
State,7339250,access,1,3492,3491,0,Private_Read
State,7339250,access,1,3492,3491,0,Private_Write
#+end_example

Now, calculate intensity as in:
- [[*2016-02-17 Calculating intensity][2016-02-17 Calculating intensity]]

#+begin_src R :results output :session :exports both
k <- read.csv("Moca-matrix-modulo-2016-02-29_11-14-03/Moca_matrix_modulo_2016_02_29_11_14_03_20160229_112157_CET_Virtual_4-states.csv", header=FALSE);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Nature", "Address", "Type", "Start", "End", "Duration", "Imbric", "Value");
k$Niature <- NULL;
k$Type <- NULL;
k$Imbric <- NULL;
head(k);

sapply(k, class);

library(dplyr);

g <- k %>%
       group_by(Address, Start, End, Duration, Value) %>%
       summarize(N = length(Value));


nrow(g);
head(g);
#h <- g %>% filter(Address >= 140737313341456 & Address <= 140737313341456+24000000);
#head(h)
#+end_src

#+RESULTS:
#+begin_example
     V1      V2     V3 V4   V5   V6 V7            V8
1 State 6303348 access  1 3492 3491  0  Private_Read
2 State 6303348 access  1 3492 3491  0 Private_Write
3 State 6303752 access  1 3492 3491  0  Private_Read
4 State 6303752 access  1 3492 3491  0 Private_Write
5 State 7330216 access  1 3492 3491  0  Private_Read
6 State 7330216 access  1 3492 3491  0 Private_Write
       V1        V2        V3        V4        V5        V6        V7        V8 
 "factor" "numeric"  "factor" "integer" "integer" "integer" "integer"  "factor"
  Nature Address Start  End Duration         Value
1  State 6303348     1 3492     3491  Private_Read
2  State 6303348     1 3492     3491 Private_Write
3  State 6303752     1 3492     3491  Private_Read
4  State 6303752     1 3492     3491 Private_Write
5  State 7330216     1 3492     3491  Private_Read
6  State 7330216     1 3492     3491 Private_Write
   Nature   Address     Start       End  Duration     Value 
 "factor" "numeric" "integer" "integer" "integer"  "factor"
[1] 1224679
Source: local data frame [6 x 6]
Groups: Address, Start, End, Duration [6]

  Address  Start    End Duration        Value     N
    (dbl)  (int)  (int)    (int)       (fctr) (int)
1 4194928  94264  94505      241 Private_Read     1
2 4194928  94505 108267    13762  Shared_Read     2
3 4194928 108267 108267        0 Private_Read     1
4 4196888   5923   7920     1997 Private_Read     1
5 4197408   7927  24611    16684 Private_Read     1
6 6303232   5923   7920     1997 Private_Read     1
#+end_example


Finally redo the plot v3 from [[*2016-02-25 Merge access information with data structure information][2016-02-25 Merge access information with data structure information]] 

#+begin_src R :results output graphics :file img/intensity_modulo_with_structure_v4.png :exports both :width 600 :height 400 :session
structs <- read.csv("Moca-matrix-modulo-2016-02-29_11-14-03/matrix.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressEnd = structs$AddressStart + structs$AddressSize;

library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);


library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scales="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_modulo_with_structure_v4.png]]


Let's compare this visualisation to
[[file:img/intensity_fixaddr_with_structure_v4.png][file:~/Work/labbook-lucas/img/intensity_fixaddr_with_structure_v4.png]] :
- The intensity goes up to 12 sometimes while it was never more than 2
  in matrix-bloc. This happens because the different thread work on
  very close addresses.
- As expected, the number of detected write have significantly
  increased, I think we can consider that the previous trace was clean
  and this is not a BUG in Moca.
- We can see a lot of shared write on the third data structure which
  is clearly bad in terms of cache.
- We can't see any patterns in the middle structure an the patterns in
  the other structure seems way less linear.
- It is still hard to know which thread is doing what. We really should try
  to visualize the intensity in terms of number of thread involved.


** DONE New visualisation: number of threads                         :David:
- State "DONE"       from "TODO"       [2016-02-29 Mon 18:54]
- State "TODO"       from              [2016-02-29 Mon 14:08]
  
Here is a link to an archive containing the trace I am  working on:
https://ligcloud.imag.fr/public.php?service=files&t=1d3fdcfed0bda3e1cdd30d6ff0093d7e

#+begin_src sh :results output :exports both
md5sum matrix-modulo.tgz
#+end_src

#+RESULTS:
: 82e5aa80788c8c8c5c1a021e45dea44e  matrix-modulo.tgz

#+begin_src sh :results output :exports both
DIR=Moca-matrix-modulo-2016-02-29_11-14-03
head $DIR/Moca_matrix_modulo_2016_02_29_11_14_03_20160229_112157_CET_Virtual_4-states.csv
#+end_src

#+RESULTS:
#+begin_example
State,6303348,access,1,3492,3491,0,Private_Read
State,6303348,access,1,3492,3491,0,Private_Write
State,6303752,access,1,3492,3491,0,Private_Read
State,6303752,access,1,3492,3491,0,Private_Write
State,7330216,access,1,3492,3491,0,Private_Read
State,7330216,access,1,3492,3491,0,Private_Write
State,7332280,access,1,3492,3491,0,Private_Read
State,7332280,access,1,3492,3491,0,Private_Write
State,7339250,access,1,3492,3491,0,Private_Read
State,7339250,access,1,3492,3491,0,Private_Write
#+end_example

The thread information is not in the pjdump file, and the pipeline
from the original trace to this file is very long (trace ->
preprocessing -> framesoc -> pjdump -> states.csv). We should modify
the csv generated by the preprocessing phase and work on this.

#+begin_src sh :results output :exports both
head Moca-matrix-modulo-2016-02-29_11-14-03/Moca-framesoc.csv
#+end_src

#+RESULTS:
#+begin_example
@Virt,@Phy,Nreads,Nwrites,CPUMask,Start,End,TaskId,Shared
0000000000400040,00006200028a0630,1,0,000010110,1,3492,0,0
0000000000400a18,00006200028a0630,1,0,000010110,5923,7920,0,0
0000000000400c20,00006200028a0630,1,0,000100110,7927,24611,2,0
0000000000400270,0000000000400270,1,0,010000110,94264,94505,2,0
0000000000400270,0000000000400270,1,0,010000110,94505,108267,2,1
0000000000400270,0000000000400270,1,0,001000110,94505,108267,3,1
0000000000400270,0000000000400270,1,0,001000110,108267,108267,3,0
0000000000405435,0000000000405435,1,0,010000110,1,3492,0,0
000000000041d800,000000000041d800,1,0,010000110,1,3492,0,0
#+end_example

At this level shared is always 0 or 1, we could instead put the number
of threads sharing the data. It's only a one line change in the post
processing script, let's try it:

#+begin_src sh :results output :exports both
cd  Moca-matrix-modulo-2016-02-29_11-14-03
~/Work/Moca/src/utils/create_event_producer.sh 4096 Moca-full-trace.csv
head Moca-framesoc.csv
#+end_src

#+RESULTS:
#+begin_example
Generating producer files
Generating framesoc trace file
Generating Virtual producers file
Generating Physical producers file
Virtual-producers.log Done
Physical-producers.log Done
Reading from Moca-full-trace.csv
102894 accesses on 6000 pages parsed from Moca-full-trace.csv
done in 00 h 00 min 12.765 sec
@Virt,@Phy,Nreads,Nwrites,CPUMask,Start,End,TaskId,Shared
0000000000400040,00006200028a0630,1,0,000010110,1,3492,0,1
0000000000400a18,00006200028a0630,1,0,000010110,5923,7920,0,1
0000000000400c20,00006200028a0630,1,0,000100110,7927,24611,2,1
0000000000400270,0000000000400270,1,0,010000110,94264,94505,2,1
0000000000400270,0000000000400270,1,0,010000110,94505,108267,2,2
0000000000400270,0000000000400270,1,0,001000110,94505,108267,3,2
0000000000400270,0000000000400270,1,0,001000110,108267,108267,3,1
0000000000405435,0000000000405435,1,0,010000110,1,3492,0,1
000000000041d800,000000000041d800,1,0,010000110,1,3492,0,1
#+end_example


#+begin_src R :results output :session :exports both
computeType <- function(df){
  shared <-9
  write <- 4
  if(df[shared] >= 2){
    mytype <- "Shared"
  }else{
    mytype <- "Private"
  }
  if(df[write] >= 1){
     mytype <- paste(mytype,"Write" , sep="_")
  }else{
     mytype <- paste(mytype,"Read" , sep="_")
  }
  return(mytype)
}

k <- read.csv("Moca-matrix-modulo-2016-02-29_11-14-03/Moca-framesoc.csv", header=T);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

k$Value <- apply(k,1,computeType)
k$Address <- sprintf("%f", as.numeric(paste("0x", k$Address, sep="")))
k$Phy <- NULL;
k$CPU <- NULL;
k$Tid <- NULL;
k$Reads <- NULL ;
k$Writes <- NULL ;
k$Duration <- k$End - k$Start
head(k);
#+end_src

#+RESULTS:
#+begin_example
            X.Virt            X.Phy Nreads Nwrites  CPUMask Start    End TaskId
1 0000000000400040 00006200028a0630      1       0    10110     1   3492      0
2 0000000000400a18 00006200028a0630      1       0    10110  5923   7920      0
3 0000000000400c20 00006200028a0630      1       0   100110  7927  24611      2
4 0000000000400270 0000000000400270      1       0 10000110 94264  94505      2
5 0000000000400270 0000000000400270      1       0 10000110 94505 108267      2
6 0000000000400270 0000000000400270      1       0  1000110 94505 108267      3
  Shared
1      1
2      1
3      1
4      1
5      2
6      2
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
         Address Start    End N        Value Duration
1 4194368.000000     1   3492 1 Private_Read     3491
2 4196888.000000  5923   7920 1 Private_Read     1997
3 4197408.000000  7927  24611 1 Private_Read    16684
4 4194928.000000 94264  94505 1 Private_Read      241
5 4194928.000000 94505 108267 2  Shared_Read    13762
6 4194928.000000 94505 108267 2  Shared_Read    13762
#+end_example


Ok I think that the data frame now looks like what we add with the
pjdump files, let's try to visualize that:

#+begin_src R :results output :session :exports both
g <- k
structs <- read.csv("Moca-matrix-modulo-2016-02-29_11-14-03/matrix.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressEnd = structs$AddressStart + structs$AddressSize;

library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);
#+end_src

#+RESULTS:
:          Address Start   End Duration        Value N       Structure
: 1 6304392.000000  5923  7920     1997 Private_Read 1 UnnamedStruct#0
: 2 6304392.000000  5923  7920     1997 Private_Read 1 UnnamedStruct#1
: 3 6304392.000000  5923  7920     1997 Private_Read 1 UnnamedStruct#2
: 4 6304472.000000  7921 10085     2164 Private_Read 1 UnnamedStruct#0
: 5 6304472.000000  7921 10085     2164 Private_Read 1 UnnamedStruct#1
: 6 6304472.000000  7921 10085     2164 Private_Read 1 UnnamedStruct#2

#+begin_src R :results output graphics :file img/intensity_modulo_threads.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scales="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_modulo_threads.png]]


This is starting to be very interesting, we can see here that the
middle data structure is shared by all thread, which might be bad on
NUMA machines, while the others seems two be shared mostly by two
threads, which should be a bit better.

- What is happening with the addresses in the big data structures ?

Can we do the same thing for the bloc version, see if it looks better:

#+begin_src sh :results output :exports both
cd  Moca-matrix-bloc-fixaddr/
~/Work/Moca/src/utils/create_event_producer.sh 4096 Moca-full-trace.csv
head Moca-framesoc.csv
#+end_src

#+RESULTS:
#+begin_example
Generating producer files
Generating framesoc trace file
Generating Virtual producers file
Generating Physical producers file
Virtual-producers.log Done
Physical-producers.log Done
done in 00 h 00 min 00.062 sec
@Virt,@Phy,Nreads,Nwrites,CPUMask,Start,End,TaskId,Shared
0000000000400040,000062000b0d4f90,1,0,000100110,1,4399,0,0
0000000000400b80,000062000b0d4f90,1,0,000000111,14887,17767,0,0
0000000000400270,0000000000400270,1,0,000001011,1700510,1729918,3,0
0000000000405435,0000000000405435,1,0,000000110,1,4399,0,0
000000000041d800,000000000041d800,1,0,000000110,1,4399,0,0
0000000000420fa0,0000000000420fa0,1,0,000000110,1,4399,0,0
00000000004341e1,00000000004341e1,1,0,000000110,1,4399,0,0
000000000044677a,000000000044677a,1,0,000000110,1,4399,0,0
000000000045dca0,000000000045dca0,1,0,000000110,1,4399,0,0
#+end_example

#+begin_src R :results output :session :exports both
computeType <- function(df){
  shared <-9
  write <- 4
  if(df[shared] >= 2){
    mytype <- "Shared"
  }else{
    mytype <- "Private"
  }
  if(df[write] >= 1){
     mytype <- paste(mytype,"Write" , sep="_")
  }else{
     mytype <- paste(mytype,"Read" , sep="_")
  }
  return(mytype)
}

k <- read.csv("Moca-matrix-bloc-fixaddr/Moca-framesoc.csv", header=T);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

k$Value <- apply(k,1,computeType)
k$Address <- sprintf("%f", as.numeric(paste("0x", k$Address, sep="")))
k$Phy <- NULL;
k$CPU <- NULL;
k$Tid <- NULL;
k$Reads <- NULL ;
k$Writes <- NULL ;
k$Duration <- k$End - k$Start
head(k);

g <- k
structs <- read.csv("Moca-matrix-bloc-fixaddr/matrix.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressEnd = structs$AddressStart + structs$AddressSize;

library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);
#+end_src

#+RESULTS:
#+begin_example
            X.Virt            X.Phy Nreads Nwrites CPUMask   Start     End
1 0000000000400040 000062000b0d4f90      1       0  100110       1    4399
2 0000000000400b80 000062000b0d4f90      1       0     111   14887   17767
3 0000000000400270 0000000000400270      1       0    1011 1700510 1729918
4 0000000000405435 0000000000405435      1       0     110       1    4399
5 000000000041d800 000000000041d800      1       0     110       1    4399
6 0000000000420fa0 0000000000420fa0      1       0     110       1    4399
  TaskId Shared
1      0      1
2      0      1
3      3      1
4      0      1
5      0      1
6      0      1
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
         Address   Start     End N        Value Duration
1 4194368.000000       1    4399 1 Private_Read     4398
2 4197248.000000   14887   17767 1 Private_Read     2880
3 4194928.000000 1700510 1729918 1 Private_Read    29408
4 4215861.000000       1    4399 1 Private_Read     4398
5 4315136.000000       1    4399 1 Private_Read     4398
6 4329376.000000       1    4399 1 Private_Read     4398
         Address Start   End Duration        Value N       Structure
1 6304392.000000  4400  9932     5532 Private_Read 1 UnnamedStruct#0
2 6304392.000000  4400  9932     5532 Private_Read 1 UnnamedStruct#1
3 6304392.000000  4400  9932     5532 Private_Read 1 UnnamedStruct#2
4 6304536.000000 14887 17757     2870 Private_Read 1 UnnamedStruct#0
5 6304536.000000 14887 17757     2870 Private_Read 1 UnnamedStruct#1
6 6304536.000000 14887 17757     2870 Private_Read 1 UnnamedStruct#2
#+end_example

#+begin_src R :results output graphics :file img/intensity_bloc_threads.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scales="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_bloc_threads.png]]


The interesting thing todo here is to compare the bloc version (above)
to the very naive one:
[[file:img/intensity_modulo_threads.png][file:~/Work/labbook-lucas/img/intensity_modulo_threads.png]]

We see several difference in the visualisation:
- The patterns are way more linear in the bloc version which seems
  better in regards of the cache issues
- Sharing is less intensive for the bloc version, especially in terms
  of writes: we manage to go up to 3 threads writing the same page in
  the naive version.
- For both version the 2^nd structure is accessed in an ugly way being
  completely shared, I guess it won't be inefficient for NUMA
  machines.

So I guess we have a visualisation from which we can start to see
things, the next step is to look at some other application and try to
do some improvements. We also should fix the number of addresses
issue.
* 2016-03-01 MOCA availability                                        :Lucas:

David just told me that MOCA is available here:
- https://github.com/dbeniamine/MOCA

The scripts to replay previous sections are there:
- https://github.com/dbeniamine/MOCA/blob/master/src/utils/create_event_producer.sh
- https://github.com/dbeniamine/MOCA/blob/master/src/utils/framesoc_parser.pl

* 2016-03-01 Can we go deeper ?                                       :David:

** Continue previous analysis

Let's restart were we stopped yesterday:

#+begin_src R :results output :session :exports both
computeType <- function(df){
  shared <-9
  write <- 4
  if(df[shared] >= 2){
    mytype <- "Shared"
  }else{
    mytype <- "Private"
  }
  if(df[write] >= 1){
     mytype <- paste(mytype,"Write" , sep="_")
  }else{
     mytype <- paste(mytype,"Read" , sep="_")
  }
  return(mytype)
}

k <- read.csv("Moca-matrix-modulo-2016-02-29_11-14-03/Moca-framesoc.csv", header=T);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

k$Value <- apply(k,1,computeType)
k$Address <- sprintf("%f", as.numeric(paste("0x", k$Address, sep="")))
k$Phy <- NULL;
k$CPU <- NULL;
k$Tid <- NULL;
k$Reads <- NULL ;
k$Writes <- NULL ;
k$Duration <- k$End - k$Start
head(k);

g <- k
structs <- read.csv("Moca-matrix-modulo-2016-02-29_11-14-03/matrix.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressEnd = structs$AddressStart + structs$AddressSize;

library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);
#+end_src

 #+RESULTS:
 #+begin_example
             X.Virt            X.Phy Nreads Nwrites  CPUMask Start    End TaskId
 1 0000000000400040 00006200028a0630      1       0    10110     1   3492      0
 2 0000000000400a18 00006200028a0630      1       0    10110  5923   7920      0
 3 0000000000400c20 00006200028a0630      1       0   100110  7927  24611      2
 4 0000000000400270 0000000000400270      1       0 10000110 94264  94505      2
 5 0000000000400270 0000000000400270      1       0 10000110 94505 108267      2
 6 0000000000400270 0000000000400270      1       0  1000110 94505 108267      3
   Shared
 1      1
 2      1
 3      1
 4      1
 5      2
 6      2
    X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
  "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
    Shared 
 "integer"
          Address Start    End N        Value Duration
 1 4194368.000000     1   3492 1 Private_Read     3491
 2 4196888.000000  5923   7920 1 Private_Read     1997
 3 4197408.000000  7927  24611 1 Private_Read    16684
 4 4194928.000000 94264  94505 1 Private_Read      241
 5 4194928.000000 94505 108267 2  Shared_Read    13762
 6 4194928.000000 94505 108267 2  Shared_Read    13762
          Address Start   End Duration        Value N       Structure
 1 6304392.000000  5923  7920     1997 Private_Read 1 UnnamedStruct#0
 2 6304392.000000  5923  7920     1997 Private_Read 1 UnnamedStruct#1
 3 6304392.000000  5923  7920     1997 Private_Read 1 UnnamedStruct#2
 4 6304472.000000  7921 10085     2164 Private_Read 1 UnnamedStruct#0
 5 6304472.000000  7921 10085     2164 Private_Read 1 UnnamedStruct#1
 6 6304472.000000  7921 10085     2164 Private_Read 1 UnnamedStruct#2
#+end_example

Before doing the plot we'd like to focus on some data structures:

#+begin_src R :results output :session :exports both
head(m)
n <- m[grepl("matrix",m$Structure),]
head(n)
#+end_src

#+RESULTS:
#+begin_example
         Address Start   End Duration        Value N       Structure
1 6304392.000000  5923  7920     1997 Private_Read 1 UnnamedStruct#0
2 6304392.000000  5923  7920     1997 Private_Read 1 UnnamedStruct#1
3 6304392.000000  5923  7920     1997 Private_Read 1 UnnamedStruct#2
4 6304472.000000  7921 10085     2164 Private_Read 1 UnnamedStruct#0
5 6304472.000000  7921 10085     2164 Private_Read 1 UnnamedStruct#1
6 6304472.000000  7921 10085     2164 Private_Read 1 UnnamedStruct#2
                  Address Start   End Duration         Value N
19 140737313341456.000000  5923  7920     1997 Private_Write 1
20 140737313341464.000000  7927 24611    16684  Private_Read 1
21 140737313345536.000000     1  3492     3491 Private_Write 1
22 140737313345536.000000  5923  7920     1997 Private_Write 1
23 140737313345560.000000  7927  7998       71  Private_Read 1
24 140737313345560.000000  7998 10000     2002   Shared_Read 2
                                         Structure
19 /home/david/Work/Bench/matrix/matrix_naif.c:140
20 /home/david/Work/Bench/matrix/matrix_naif.c:140
21 /home/david/Work/Bench/matrix/matrix_naif.c:140
22 /home/david/Work/Bench/matrix/matrix_naif.c:140
23 /home/david/Work/Bench/matrix/matrix_naif.c:140
24 /home/david/Work/Bench/matrix/matrix_naif.c:140
#+end_example

#+begin_src R :results output graphics :file img/intensity_modulo_threads_zoom.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(n) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scales="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_modulo_threads_zoom.png]]


It's a bit better, let's zoom in the middle data structure

#+begin_src R :results output graphics :file img/intensity_modulo_threads_zoom.png :exports both :width 600 :height 400 :session
library(ggplot2);
o <- n[grepl(".c:123",m$Structure),]
p <- ggplot(o) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(~Value, scales="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_modulo_threads_zoom.png]]


Well we don't see much more things, but It doesn't matter I think the
visualization is already quite usefull, let's try to work on some
other traces.

** IS

*** DONE First look
- State "DONE"       from "TODO"       [2016-03-01 Tue 11:26]
- State "TODO"       from              [2016-03-01 Tue 11:26]

IS in one of the NAS paralell benchmark, we saw a particularly
interesting pattern with TABARNAC: all the thread were accessing a
data structure with a Gaussian distribution. In other words each page
of the structure were accessed by each threads and more a page was in
the middle of the structure, more it was accessed.

There is an archive to the IS trace:
https://ligcloud.imag.fr/public.php?service=files&t=d724ad2c1c0c9b648eed5974cc736f58

#+begin_src sh :results output :exports both
md5sum is-a-base.tgz
#+end_src

#+RESULTS:
: a89f1719f4c4d0c68977f4fdcbba4712  is-a-base.tgz

#+begin_src sh :results output :exports both :session
DIR=Moca-is.A-2016-02-26_16-29-49
MOCAPATH=~/Work/Moca
cd $DIR
$MOCAPATH/src/utils/create_event_producer.sh 4096 Moca-full-trace.csv
head Moca-framesoc.csv
#+end_src

#+RESULTS:
#+begin_example
Generating producer files
Generating framesoc trace file
Generating Virtual producers file
Generating Physical producers file
Virtual-producers.log Done
Physical-producers.log Done
Reading from Moca-full-trace.csv
48577 accesses on 17022 pages parsed from Moca-full-trace.csv
done in 00 h 00 min 02.225 sec
@Virt,@Phy,Nreads,Nwrites,CPUMask,Start,End,TaskId,Shared
0000000000400040,000062000b08fa48,1,0,000001011,1,157,0,1
0000000000400040,000062000b08fa48,1,0,000001011,157,2825,0,2
0000000000400848,000062000b08fa48,1,0,000010011,157,2825,3,2
0000000000400848,000062000b08fa48,1,0,000010011,2825,5603,3,1
0000000000400848,000062000b08fa48,1,0,000010011,5603,8610,3,2
00000000004002a8,000062000b08fa48,1,0,000001011,5603,8610,0,2
0000000000400848,000062000b08fa48,1,0,000010011,8610,8616,3,1
0000000000400848,000062000b08fa48,1,0,000010011,8616,20399,3,2
0000000000400bd4,000062000b08fa48,1,0,000001011,8616,20399,0,2
#+end_example

#+begin_src sh :results output :exports both :session
DIR=Moca-is.A-2016-02-26_16-29-49
awk -F , 'BEGIN{p="";cpt=1} {if(p==$1){n=$1"-"cpt;cpt++}\
else{cpt=1;n=$1};p=$1;print n","$2","$3}' \
$DIR/is.A.structs.csv > $DIR/is.A.structs-uniq.csv
cat  $DIR/is.A.structs-uniq.csv
#+end_src

#+RESULTS:
#+begin_example
-1,,
__GI___pthread_keys,2196192,16384
__pthread_keys,2196192,16384
key_buff1,6305024,2097152
key_array,8402176,33554432
key_buff2,41956608,33554432
UnnamedStruct#2,75513872,32816
/tmp/NPB3.3-OMP/IS/is.c:494,75519344,4096
/tmp/NPB3.3-OMP/IS/is.c:494-1,75523456,4096
/tmp/NPB3.3-OMP/IS/is.c:494-2,75527568,4096
/tmp/NPB3.3-OMP/IS/is.c:494-3,75531680,4096
/tmp/NPB3.3-OMP/IS/is.c:494-4,75535792,4096
/tmp/NPB3.3-OMP/IS/is.c:494-5,75539904,4096
/tmp/NPB3.3-OMP/IS/is.c:494-6,75544016,4096
/tmp/NPB3.3-OMP/IS/is.c:494-7,75548128,4096
#+end_example

Hum it looks like there are a lot of data structures with the same
name here, it's gona be a mess to understand which one is which ...

#+begin_src R :results output :session :exports both
computeType <- function(df){
  shared <-9
  write <- 4
  if(df[shared] >= 2){
    mytype <- "Shared"
  }else{
    mytype <- "Private"
  }
  if(df[write] >= 1){
     mytype <- paste(mytype,"Write" , sep="_")
  }else{
     mytype <- paste(mytype,"Read" , sep="_")
  }
  return(mytype)
}

k <- read.csv("Moca-is.A-2016-02-26_16-29-49/Moca-framesoc.csv", header=T);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

k$Value <- apply(k,1,computeType)
k$Address <- sprintf("%f", as.numeric(paste("0x", k$Address, sep="")))
k$Phy <- NULL;
k$CPU <- NULL;
k$Tid <- NULL;
#k$Reads <- NULL ;
#k$Writes <- NULL ;
k$Duration <- k$End - k$Start
head(k);

g <- k
structs <- read.csv("Moca-is.A-2016-02-26_16-29-49/is.A.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressEnd = structs$AddressStart + structs$AddressSize;

library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.Reads, g.Writes, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);
#+end_src

#+RESULTS:
#+begin_example
            X.Virt            X.Phy Nreads Nwrites CPUMask Start  End TaskId
1 0000000000400040 000062000b08fa48      1       0    1011     1  157      0
2 0000000000400040 000062000b08fa48      1       0    1011   157 2825      0
3 0000000000400848 000062000b08fa48      1       0   10011   157 2825      3
4 0000000000400848 000062000b08fa48      1       0   10011  2825 5603      3
5 0000000000400848 000062000b08fa48      1       0   10011  5603 8610      3
6 00000000004002a8 000062000b08fa48      1       0    1011  5603 8610      0
  Shared
1      1
2      2
3      2
4      1
5      2
6      2
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
         Address Reads Writes Start  End N        Value Duration
1 4194368.000000     1      0     1  157 1 Private_Read      156
2 4194368.000000     1      0   157 2825 2  Shared_Read     2668
3 4196424.000000     1      0   157 2825 2  Shared_Read     2668
4 4196424.000000     1      0  2825 5603 1 Private_Read     2778
5 4196424.000000     1      0  5603 8610 2  Shared_Read     3007
6 4194984.000000     1      0  5603 8610 2  Shared_Read     3007
         Address Start   End Duration         Value Reads Writes N Structure
1 6311168.000000   157   163        6 Private_Write     1      1 1 key_buff1
2 6311168.000000   163 11652    11489  Shared_Write     1      1 2 key_buff1
3 6309120.000000   163 11652    11489  Shared_Write     1      1 2 key_buff1
4 6311168.000000 11652 21776    10124  Shared_Write     1      1 3 key_buff1
5 6309120.000000 11652 21776    10124  Shared_Write     1      1 3 key_buff1
6 6309120.000000 11652 21776    10124  Shared_Write     1      1 3 key_buff1
#+end_example


#+begin_src R :results output graphics :file img/intensity_is_threads.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_is_threads.png]]



 Woh there is a lot of data structures here, most of the accesses
 seems to be on the three first, let's do a plot similar to:
[[*Importance of data structures][Importance of data structures]]

#+begin_src R :results output :session :exports both
library(plyr)
n <- ddply(m,c("Structure"),summarize,Reads=sum(Reads), Writes=sum(Writes));
o <- n
o$Writes <- NULL
o$Type <- rep("Read", nrow(o))
names(o) <- c("Structure", "N", "Type")
q <- n
q$Reads <- NULL
q$Type <- rep("Write", nrow(o))
names(q) <- c("Structure", "N", "Type")
q <- rbind(q,o)
head(q)
#+end_src

#+RESULTS:
:                       Structure     N  Type
: 1                     key_array  8194 Write
: 2                     key_buff1 49647 Write
: 3                     key_buff2 36940 Write
: 4   /tmp/NPB3.3-OMP/IS/is.c:494     1 Write
: 5 /tmp/NPB3.3-OMP/IS/is.c:494-1     7 Write
: 6 /tmp/NPB3.3-OMP/IS/is.c:494-2     2 Write

#+begin_src R :results output graphics :file img/struct_importance_is.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(q,aes(x=Structure,y=N, fill=Type)) +
  theme_bw() +
  geom_bar(stat="identity")
p
#+end_src

#+RESULTS:
[[file:img/struct_importance_is.png]]


Ok we can clearly focus on the first three data structures. BTW this
version of the plot is more compelete than the previous, it is nice to
see the read / write ratio.

#+begin_src R :results output graphics :file img/intensity_is_threads_zoom.png :exports both :width 600 :height 400 :session
library(ggplot2);
r <- m[grepl("key_", m$Structure),]
p <- ggplot(r) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_is_threads_zoom.png]]


- So we see that keybuff1 is shared in write mode
  - At the beginning it's is shared by 2 or 3 threads, but when it the
    number of threads increase with the time
  - It seems that the addresses in the middle are accessed by more
    threads than the other, but it's not as obvious as in Tabarnac. We
    shoul try to plot the number of accesses per addresses.
- key buff1 seems to never be read, I guess we always do something
  like  keybuff1[i]++ that triggers a read and a write.
- The read write pattern of key array is quite fun: basicely we never
  re write anything, which is not the case for the two other data
  structure. This information could be used to replicate the data
  structure if needed.
  
#+begin_src R :results output graphics :file img/intensity_is_threads_zoom_nacc.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(r) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(Reads+Writes))) +
  facet_grid(Structure~Value, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_is_threads_zoom_nacc.png]]

The number of accesses for writes are higher than for reads, it is an
artifacts as a write access always contains also a read.

I'm a bit disapointed here, I thought I will see the fact that the
middle addreses of keybuff1 are more accessed ...

What if we remove the facet on the type of access

#+begin_src R :results output graphics :file img/intensity_is_threads_zoom_nacc2.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(r) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(Reads+Writes))) +
  facet_grid(Structure~., scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_is_threads_zoom_nacc2.png]]


Well  he we can only say that keybuff1 have more accesses at the same
time than the two other structures, but we still can't see this gaussian

I'll just check that the trace is indeed the original version of is,
(If yes the result of the following line should be Macros: DYN).

#+begin_src sh :results output :exports both
grep Macros Moca-is.A-2016-02-26_16-29-49/Moca-is.A.log
#+end_src

#+RESULTS:
: Macros:	DYN

It looks fine, I should compare these plots to the modified version of
IS, and see what happens ...
For reminder Tabarnac IS visualisation are available here:
http://dbeniamine.github.io/Tabarnac/examples/is.B-original.html
and
http://dbeniamine.github.io/Tabarnac/examples/is.B-modif.html

Also we are looking to a class A version of IS, for tabarnac we used a
class B, maybe it could help to work on a bigger version.

*** DONE Class B
- State "DONE"       from "STARTED"    [2016-03-01 Tue 14:55]
- State "STARTED"    from "TODO"       [2016-03-01 Tue 14:11]
- State "TODO"       from              [2016-03-01 Tue 11:26]
 
So I just generated three new is traces:
- is.A-modif: Class A, modification from tabarnac paper (see
  http://dbeniamine.github.io/Tabarnac/examples/ ).
- is.B-orig: Class A, original version.
- is.B-modif: Class B, modified.

As usual, there is an archive on ligcloud:
https://ligcloud.imag.fr/public.php?service=files&t=4e9547f6da887a6c8ebcca9dea4c159f

#+begin_src sh :results output :exports both
md5sum is-AB.tgz
tar xvzf is-AB.tgz
#+end_src

#+RESULTS:
#+begin_example
a20fd83a6de147c13ac7d572f3d526b4  is-AB.tgz
Moca-is.A-modif-2016-03-01_14-00-23/
Moca-is.A-modif-2016-03-01_14-00-23/is.A-modif-stackmap.csv
Moca-is.A-modif-2016-03-01_14-00-23/Moca-full-trace.csv
Moca-is.A-modif-2016-03-01_14-00-23/Moca-output.log
Moca-is.A-modif-2016-03-01_14-00-23/stacks.log
Moca-is.A-modif-2016-03-01_14-00-23/Moca-is.A-modif.log
Moca-is.A-modif-2016-03-01_14-00-23/temp_1760
Moca-is.A-modif-2016-03-01_14-00-23/Moca-is.A-modif.log.err
Moca-is.A-modif-2016-03-01_14-00-23/is.A-modif.structs.csv
Moca-is.B-modif-2016-03-01_14-00-58/
Moca-is.B-modif-2016-03-01_14-00-58/Moca-is.B-modif.log
Moca-is.B-modif-2016-03-01_14-00-58/Moca-is.B-modif.log.err
Moca-is.B-modif-2016-03-01_14-00-58/is.B-modif-stackmap.csv
Moca-is.B-modif-2016-03-01_14-00-58/Moca-full-trace.csv
Moca-is.B-modif-2016-03-01_14-00-58/Moca-output.log
Moca-is.B-modif-2016-03-01_14-00-58/stacks.log
Moca-is.B-modif-2016-03-01_14-00-58/is.B-modif.structs.csv
Moca-is.B-modif-2016-03-01_14-00-58/temp_3266
Moca-is.B-orig-2016-03-01_14-03-40/
Moca-is.B-orig-2016-03-01_14-03-40/Moca-is.B-orig.log
Moca-is.B-orig-2016-03-01_14-03-40/is.B-orig-stackmap.csv
Moca-is.B-orig-2016-03-01_14-03-40/Moca-is.B-orig.log.err
Moca-is.B-orig-2016-03-01_14-03-40/Moca-full-trace.csv
Moca-is.B-orig-2016-03-01_14-03-40/Moca-output.log
Moca-is.B-orig-2016-03-01_14-03-40/stacks.log
Moca-is.B-orig-2016-03-01_14-03-40/is.B-orig.structs.csv
Moca-is.B-orig-2016-03-01_14-03-40/temp_5417
#+end_example

We start with the original is.B trace, see if the patterns are more
visible than on the class A, same analysis as [[*First look][above.]] 

#+begin_src sh :results output :exports both :session
DIR=Moca-is.B-orig-2016-03-01_14-03-40
MOCAPATH=~/Work/Moca
cd $DIR
$MOCAPATH/src/utils/create_event_producer.sh 4096 Moca-full-trace.csv
head Moca-framesoc.csv
awk -F , 'BEGIN{p="";cpt=1} {if(p==$1){n=$1"-"cpt;cpt++}\
else{cpt=1;n=$1};p=$1;print n","$2","$3}' \
is.B-orig.structs.csv > is.B-orig.structs-uniq.csv
cat  is.B-orig.structs-uniq.csv
#+end_src

#+RESULTS:
#+begin_example
Generating producer files
Generating framesoc trace file
Generating Virtual producers file
Generating Physical producers file
Virtual-producers.log Done
Physical-producers.log Done
Reading from Moca-full-trace.csv
770601 accesses on 67715 pages parsed from Moca-full-trace.csv
done in 00 h 00 min 23.992 sec
@Virt,@Phy,Nreads,Nwrites,CPUMask,Start,End,TaskId,Shared
0000000000400040,000062000b1dfa80,1,0,000001011,1,171,0,1
00000000004002a8,000062000b1dfa80,1,0,000001011,32663,34153,0,1
0000000000400bd4,000062000b1dfa80,1,0,000001011,55271,72678,0,1
00000000004009a0,000062000b1dfa80,1,0,000000011,88569,88776,1,1
00000000004009a0,000062000b1dfa80,1,0,000000111,92562,103554,7,1
00000000004009a0,000062000b1dfa80,1,0,000010011,238634,245102,2,1
00000000004009a0,000062000b1dfa80,1,0,001000000,254421,258859,4,1
00000000004009a0,000062000b1dfa80,1,0,001000000,258859,286485,4,2
0000000000400990,000062000b1dfa80,1,0,010000000,258859,286485,6,2
-1,,
__GI___pthread_keys,2196192,16384
__pthread_keys,2196192,16384
key_buff1,6305024,8388608
key_array,14693632,134217728
key_buff2,148911360,134217728
UnnamedStruct#2,283131920,32816
/tmp/NPB3.3-OMP/IS/is.c:494,283137392,4096
/tmp/NPB3.3-OMP/IS/is.c:494-1,283141504,4096
/tmp/NPB3.3-OMP/IS/is.c:494-2,283145616,4096
/tmp/NPB3.3-OMP/IS/is.c:494-3,283149728,4096
/tmp/NPB3.3-OMP/IS/is.c:494-4,283153840,4096
/tmp/NPB3.3-OMP/IS/is.c:494-5,283157952,4096
/tmp/NPB3.3-OMP/IS/is.c:494-6,283162064,4096
/tmp/NPB3.3-OMP/IS/is.c:494-7,283166176,4096
#+end_example


#+begin_src R :results output :session :exports both
computeType <- function(df){
  shared <-9
  write <- 4
  if(df[shared] >= 2){
    mytype <- "Shared"
  }else{
    mytype <- "Private"
  }
  if(df[write] >= 1){
     mytype <- paste(mytype,"Write" , sep="_")
  }else{
     mytype <- paste(mytype,"Read" , sep="_")
  }
  return(mytype)
}

k <- read.csv("Moca-is.B-orig-2016-03-01_14-03-40/Moca-framesoc.csv", header=T);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

k$Value <- apply(k,1,computeType)
k$Address <- sprintf("%f", as.numeric(paste("0x", k$Address, sep="")))
k$Phy <- NULL;
k$CPU <- NULL;
k$Tid <- NULL;
#k$Reads <- NULL ;
#k$Writes <- NULL ;
k$Duration <- k$End - k$Start
head(k);

g <- k
structs <- read.csv("Moca-is.B-orig-2016-03-01_14-03-40/is.B-orig.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressEnd = structs$AddressStart + structs$AddressSize;

library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.Reads, g.Writes, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);
#+end_src

#+RESULTS:
#+begin_example
            X.Virt            X.Phy Nreads Nwrites CPUMask  Start    End TaskId
1 0000000000400040 000062000b1dfa80      1       0    1011      1    171      0
2 00000000004002a8 000062000b1dfa80      1       0    1011  32663  34153      0
3 0000000000400bd4 000062000b1dfa80      1       0    1011  55271  72678      0
4 00000000004009a0 000062000b1dfa80      1       0      11  88569  88776      1
5 00000000004009a0 000062000b1dfa80      1       0     111  92562 103554      7
6 00000000004009a0 000062000b1dfa80      1       0   10011 238634 245102      2
  Shared
1      1
2      1
3      1
4      1
5      1
6      1
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
         Address Reads Writes  Start    End N        Value Duration
1 4194368.000000     1      0      1    171 1 Private_Read      170
2 4194984.000000     1      0  32663  34153 1 Private_Read     1490
3 4197332.000000     1      0  55271  72678 1 Private_Read    17407
4 4196768.000000     1      0  88569  88776 1 Private_Read      207
5 4196768.000000     1      0  92562 103554 1 Private_Read    10992
6 4196768.000000     1      0 238634 245102 1 Private_Read     6468
Loading required package: gsubfn
Loading required package: proto
Loading required package: RSQLite
Loading required package: DBI
 Loading required package: tcltk
         Address  Start    End Duration         Value Reads Writes N Structure
1 6307840.000000 279630 283344     3714 Private_Write     1      1 1 key_buff1
2 6307840.000000 310398 410993   100595 Private_Write     1      1 1 key_buff1
3 6307840.000000 452318 485570    33252 Private_Write     1      1 1 key_buff1
4 6307840.000000 485572 511748    26176 Private_Write     1      1 1 key_buff1
5 6307840.000000 511748 521080     9332  Shared_Write     1      1 2 key_buff1
6 6307840.000000 511748 521080     9332  Shared_Write     1      1 2 key_buff1
#+end_example


#+begin_src R :results output graphics :file img/intensity_is_B_orig_threads.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_is_B_orig_threads.png]]



#+begin_src R :results output :session :exports both
library(plyr)
n <- ddply(m,c("Structure"),summarize,Reads=sum(Reads), Writes=sum(Writes));
o <- n
o$Writes <- NULL
o$Type <- rep("Read", nrow(o))
names(o) <- c("Structure", "N", "Type")
q <- n
q$Reads <- NULL
q$Type <- rep("Write", nrow(o))
names(q) <- c("Structure", "N", "Type")
q <- rbind(q,o)
head(q)
#+end_src

#+RESULTS:
:                       Structure      N  Type
: 1                     key_array  76186 Write
: 2                     key_buff1  59945 Write
: 3                     key_buff2 406236 Write
: 4   /tmp/NPB3.3-OMP/IS/is.c:494     37 Write
: 5 /tmp/NPB3.3-OMP/IS/is.c:494-1     59 Write
: 6 /tmp/NPB3.3-OMP/IS/is.c:494-2     65 Write

#+begin_src R :results output graphics :file img/struct_importance_is_B_orig.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(q,aes(x=Structure,y=N, fill=Type)) +
  theme_bw() +
  geom_bar(stat="identity")
p
#+end_src

#+RESULTS:
[[file:img/struct_importance_is_B_orig.png]]


So far no suprise, the B class looks like the A.

#+begin_src R :results output graphics :file img/intensity_is_B_orig_threads_zoom.png :exports both :width 600 :height 400 :session
library(ggplot2);
r <- m[grepl("key_", m$Structure),]
p <- ggplot(r) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_is_B_orig_threads_zoom.png]]

So we can compare this visualisation to the previous one:
[[file:img/intensity_is_threads_zoom.png][file:~/Work/labbook-lucas/img/intensity_is_threads_zoom.png]]

- It seems that there are some writes on keyarray at the end of the
  execution.
- It is still hard to see anything on keybuff1.
- Although keybuff2 patterns differs than on the previous trace, we
  have again the exact same patterns of shared read and writes.

  
#+begin_src R :results output graphics :file img/intensity_is_B_orig_threads_zoom_nacc.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(r) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(Reads+Writes))) +
  facet_grid(Structure~Value, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_is_B_orig_threads_zoom_nacc.png]]

Still hard to see but there is a little something in the middle of keybuff1
Let's try to zoom as mush as possible:

#+begin_src R :results output graphics :file img/intensity_is_threads_zoom_nacc2.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(subset(r, r$Structure=="key_buff1")) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(Reads+Writes))) +
  facet_grid(Structure~., scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_is_threads_zoom_nacc2.png]]

Still hard to see anything ...
What happens if we do the same zoom on the thread based intensity ?

#+begin_src R :results output graphics :file img/intensity_is_B_orig_threads_zoo2m.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(subset(r,r$Structure=="key_buff1")) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~., scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_is_B_orig_threads_zoo2m.png]]

Still hard to see anything ...
Maybe it is harder to see such behavior over the time ...
So next step, compare these results to the modified version, maybe we
will be able to see something.

*** DONE Compare with modified trace
- State "DONE"       from "STARTED"    [2016-03-01 Tue 16:11]
- State "STARTED"    from "DONE"       [2016-03-01 Tue 16:09]
- State "DONE"       from "TODO"       [2016-03-01 Tue 15:19]
- State "TODO"       from              [2016-03-01 Tue 11:26]

Let's do this analysis one more time but with the modified version:

#+begin_src sh :results output :exports both :session
DIR=Moca-is.B-modif-2016-03-01_14-00-58
MOCAPATH=~/Work/Moca
cd $DIR
$MOCAPATH/src/utils/create_event_producer.sh 4096 Moca-full-trace.csv
head Moca-framesoc.csv
awk -F , 'BEGIN{p="";cpt=1} {if(p==$1){n=$1"-"cpt;cpt++}\
else{cpt=1;n=$1};p=$1;print n","$2","$3}' \
is.B-orig.structs.csv > is.B-orig.structs-uniq.csv
cat  is.B-orig.structs-uniq.csv
#+end_src

#+RESULTS:
#+begin_example
Generating producer files
Generating Virtual producers file
Generating framesoc trace file
Generating Physical producers file
Virtual-producers.log Done
Physical-producers.log Done
Reading from Moca-full-trace.csv
367388 accesses on 67713 pages parsed from Moca-full-trace.csv
done in 00 h 00 min 13.934 sec
@Virt,@Phy,Nreads,Nwrites,CPUMask,Start,End,TaskId,Shared
0000000000400040,00006200028860e0,1,0,000001000,1,169,0,1
00000000004002a8,00006200028860e0,1,0,000000010,32987,97290,0,1
00000000004002a8,00006200028860e0,1,0,000000010,97290,117666,0,2
0000000000400860,00006200028860e0,1,0,000010011,97290,117666,7,2
0000000000400860,00006200028860e0,1,0,000010011,117666,203309,7,1
0000000000400860,00006200028860e0,1,0,000010011,203309,204176,7,2
0000000000400860,00006200028860e0,1,0,000000011,203309,204176,6,2
0000000000400860,00006200028860e0,1,0,000000011,204176,242458,6,1
0000000000400860,00006200028860e0,1,0,000000011,242458,244604,6,2
#+end_example


#+begin_src R :results output :session :exports both
computeType <- function(df){
  shared <-9
  write <- 4
  if(df[shared] >= 2){
    mytype <- "Shared"
  }else{
    mytype <- "Private"
  }
  if(df[write] >= 1){
     mytype <- paste(mytype,"Write" , sep="_")
  }else{
     mytype <- paste(mytype,"Read" , sep="_")
  }
  return(mytype)
}

k <- read.csv("Moca-is.B-modif-2016-03-01_14-00-58/Moca-framesoc.csv", header=T);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

k$Value <- apply(k,1,computeType)
k$Address <- sprintf("%f", as.numeric(paste("0x", k$Address, sep="")))
k$Phy <- NULL;
k$CPU <- NULL;
k$Tid <- NULL;
#k$Reads <- NULL ;
#k$Writes <- NULL ;
k$Duration <- k$End - k$Start
head(k);

g <- k
structs <- read.csv("Moca-is.B-modif-2016-03-01_14-00-58/is.B-modif.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressEnd = structs$AddressStart + structs$AddressSize;

library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.Reads, g.Writes, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);
#+end_src

#+RESULTS:
#+begin_example
            X.Virt            X.Phy Nreads Nwrites CPUMask  Start    End TaskId
1 0000000000400040 00006200028860e0      1       0    1000      1    169      0
2 00000000004002a8 00006200028860e0      1       0      10  32987  97290      0
3 00000000004002a8 00006200028860e0      1       0      10  97290 117666      0
4 0000000000400860 00006200028860e0      1       0   10011  97290 117666      7
5 0000000000400860 00006200028860e0      1       0   10011 117666 203309      7
6 0000000000400860 00006200028860e0      1       0   10011 203309 204176      7
  Shared
1      1
2      1
3      2
4      2
5      1
6      2
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
         Address Reads Writes  Start    End N        Value Duration
1 4194368.000000     1      0      1    169 1 Private_Read      168
2 4194984.000000     1      0  32987  97290 1 Private_Read    64303
3 4194984.000000     1      0  97290 117666 2  Shared_Read    20376
4 4196448.000000     1      0  97290 117666 2  Shared_Read    20376
5 4196448.000000     1      0 117666 203309 1 Private_Read    85643
6 4196448.000000     1      0 203309 204176 2  Shared_Read      867
Error in file(file, "rt") : cannot open the connection
In addition: Warning message:
In file(file, "rt") :
  cannot open file 'Moca-is.B-modif-2016-03-01_14-00-58/is.B-modif.structs-uniq.csv': No such file or directory
         Address  Start    End Duration         Value Reads Writes N Structure
1 6307840.000000  32987 117666    84679 Private_Write     1      1 1 key_buff1
2 6307840.000000 120476 210547    90071 Private_Write     1      1 1 key_buff1
3 6307840.000000 221274 258171    36897 Private_Write     1      1 1 key_buff1
4 6307840.000000 258178 335045    76867 Private_Write     1      1 1 key_buff1
5 6311936.000000  32987 117666    84679 Private_Write     1      1 1 key_buff1
6 6311936.000000 120476 210547    90071 Private_Write     1      1 1 key_buff1
#+end_example

#+begin_src R :results output graphics :file img/intensity_is_B_modif_threads_zoom.png :exports both :width 600 :height 400 :session
library(ggplot2);
r <- m[grepl("key_", m$Structure),]
p <- ggplot(r) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_is_B_modif_threads_zoom.png]]



This is interesting, if it was hard to visualize the issue on the
original version (linked below), we can clearly see somme differences with the
modified version. Indeed, the amount of sharing on keybuff1 have
significantly decreased.
It seems to impact also a little bit the two other data structures.
Still the difference of behavior are not as impressive as what we saw
with Tabarnac, maybe we should try to plot this data in a different
way ...

[[file:img/intensity_is_B_orig_threads_zoom.png][file:~/Work/labbook-lucas/img/intensity_is_B_orig_threads_zoom.png]]

Before trying something else, let's compare the two version in terms
of number of accesses

#+begin_src R :results output graphics :file img/intensity_is_B_modif_threads_zoom_nacc.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(r) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(Reads+Writes))) +
  facet_grid(Structure~Value, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_is_B_modif_threads_zoom_nacc.png]]

Original verion here:
[[file:img/intensity_is_B_orig_threads_zoom_nacc.png][file:~/Work/labbook-lucas/img/intensity_is_B_orig_threads_zoom_nacc.png]]


I think the difference betweens these plots are quite similar to the
difference betwen the plots showing the intensity en terms of
threads, I guess it means that they are too similar. I'd really like
to see something like tabarnac's plot but over the time...

Maybe we should first do some plot similar to Tabarnac's ones without
time. It will tell us two different things: first if we have enough
information in Moca traces to see these behavior. The second thing is
that maybe, when we visualize the accesses over the time, we can't see
the differences because they are only significant when we sum
everything up.


*** DONE Tabarnac like plots wth Moca traces
- State "DONE"       from "TODO"       [2016-03-03 Thu 18:11]
- State "TODO"       from              [2016-03-01 Tue 15:21]

  
We restart from the original trace, but we keep the Tid in the dataframe:

#+begin_src R :results output :session :exports both
computeType <- function(df){
  shared <-9
  write <- 4
  if(df[shared] >= 2){
    mytype <- "Shared"
  }else{
    mytype <- "Private"
  }
  if(df[write] >= 1){
     mytype <- paste(mytype,"Write" , sep="_")
  }else{
     mytype <- paste(mytype,"Read" , sep="_")
  }
  return(mytype)
}

k <- read.csv("Moca-is.B-orig-2016-03-01_14-03-40/Moca-framesoc.csv", header=T);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

k$Value <- apply(k,1,computeType)
k$Address <- sprintf("%f", as.numeric(paste("0x", k$Address, sep="")))
k$Phy <- NULL;
k$CPU <- NULL;
#k$Tid <- NULL;
#k$Reads <- NULL ;
#k$Writes <- NULL ;
k$Duration <- k$End - k$Start
head(k);

g <- k
structs <- read.csv("Moca-is.B-orig-2016-03-01_14-03-40/is.B-orig.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressEnd = structs$AddressStart + structs$AddressSize;

library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.Reads, g.Writes, g.Tid, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);
#+end_src

#+RESULTS:
#+begin_example
            X.Virt            X.Phy Nreads Nwrites CPUMask  Start    End TaskId
1 0000000000400040 000062000b1dfa80      1       0    1011      1    171      0
2 00000000004002a8 000062000b1dfa80      1       0    1011  32663  34153      0
3 0000000000400bd4 000062000b1dfa80      1       0    1011  55271  72678      0
4 00000000004009a0 000062000b1dfa80      1       0      11  88569  88776      1
5 00000000004009a0 000062000b1dfa80      1       0     111  92562 103554      7
6 00000000004009a0 000062000b1dfa80      1       0   10011 238634 245102      2
  Shared
1      1
2      1
3      1
4      1
5      1
6      1
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
         Address Reads Writes  Start    End Tid N        Value Duration
1 4194368.000000     1      0      1    171   0 1 Private_Read      170
2 4194984.000000     1      0  32663  34153   0 1 Private_Read     1490
3 4197332.000000     1      0  55271  72678   0 1 Private_Read    17407
4 4196768.000000     1      0  88569  88776   1 1 Private_Read      207
5 4196768.000000     1      0  92562 103554   7 1 Private_Read    10992
6 4196768.000000     1      0 238634 245102   2 1 Private_Read     6468
Loading required package: gsubfn
Loading required package: proto
Loading required package: RSQLite
Loading required package: DBI
 Loading required package: tcltk
         Address  Start    End Duration         Value Reads Writes Tid N
1 6307840.000000 279630 283344     3714 Private_Write     1      1   7 1
2 6307840.000000 310398 410993   100595 Private_Write     1      1   6 1
3 6307840.000000 452318 485570    33252 Private_Write     1      1   6 1
4 6307840.000000 485572 511748    26176 Private_Write     1      1   6 1
5 6307840.000000 511748 521080     9332  Shared_Write     1      1   6 2
6 6307840.000000 511748 521080     9332  Shared_Write     1      1   0 2
  Structure
1 key_buff1
2 key_buff1
3 key_buff1
4 key_buff1
5 key_buff1
6 key_buff1
#+end_example

Now we sum up the date to remove the temporal information.

#+begin_src R :results output :session :exports both
r <- m[grepl("key_",m$Structure),]
r <- ddply(r, c("Address","Tid", "Structure"), summarize, N=sum(Reads)+sum(Writes))
head(r) 
#+end_src

#+RESULTS:
:            Address Tid Structure  N
: 1 100000888.000000   6 key_array  4
: 2 100003840.000000   3 key_array 11
: 3 100007216.000000   6 key_array  4
: 4 100007936.000000   3 key_array 11
: 5 100009484.000000   6 key_array  4
: 6 100012032.000000   3 key_array 11

#+begin_src R :results output graphics :file img/tabarnac_is_b_orig.png :exports both :width 600 :height 400 :session
library(ggplot2);
s <- r[grepl("key_buff1",r$Structure),]
p <- ggplot(s) +
  theme_bw() +
  geom_point(aes(x=Address,y=Tid,color=N)) +
  #facet_wrap(~Structure, ncol=1) +
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/tabarnac_is_b_orig.png]]

Still hard to see anything, maybe we can group the number of accesses
per pages:
#+begin_src R :results output :session :exports both
s <- r[grepl("key_",r$Structure),]
#head(s)
library(gmp)
pageAddr <- function(df){
    a <- as.bigz(gsub('\\..*', '', df[1]))
    a <- a - mod.bigz(a,4096)*4096
    return (as.character(a,b=10))
}
s$Page <- apply(s,1,pageAddr)
head(s)
t <- ddply(s,c("Page","Tid","Structure"), summarize, N=sum(N))
head(t)
#+end_src

#+RESULTS:
#+begin_example

Attaching package: ‘gmp’

The following objects are masked from ‘package:base’:

    %*%, apply, crossprod, matrix, tcrossprod
           Address Tid Structure  N      Page
1 100000888.000000   6 key_array  4  95315064
2 100003840.000000   3 key_array 11 100003840
3 100007216.000000   6 key_array  4  86179120
4 100007936.000000   3 key_array 11 100007936
5 100009484.000000   6 key_array  4  93668876
6 100012032.000000   3 key_array 11 100012032
       Page Tid Structure  N
1 100003840   3 key_array 11
2 100007936   3 key_array 11
3 100012032   3 key_array 11
4 100016128   3 key_array 11
5 100020224   3 key_array 11
6  10002432   0 key_buff1  4
#+end_example

#+begin_src R :results output graphics :file img/tabarnac_page_is_b_orig.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(t,aes(x=Page,y=Tid,color=N)) +
  theme_bw() +
  geom_point() +
  facet_wrap(~Structure) +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/tabarnac_page_is_b_orig.png]]



Still the same issue, we are not able to see any pattern.
Maybe the issue is not in Moca traces, but in my R: the addresses used
for plotting are stored as factor, because they are 64 bits integer
and the numeric representation keeps only the high part of the
addresses.
Let see if I manage to plot something using the gmp library:

#+begin_src R :results output :session :exports both
library(gmp)
head(t)
str(t)
t$PageB <- as.bigz(t$Page)
head(t)
str(t)
#+end_src

#+RESULTS:
#+begin_example
       Page Tid Structure  N
1 100003840   3 key_array 11
2 100007936   3 key_array 11
3 100012032   3 key_array 11
4 100016128   3 key_array 11
5 100020224   3 key_array 11
6  10002432   0 key_buff1  4
'data.frame':	337133 obs. of  4 variables:
 $ Page     : chr  "100003840" "100007936" "100012032" "100016128" ...
 $ Tid      : int  3 3 3 3 3 0 1 2 5 6 ...
 $ Structure: Factor w/ 14 levels "__GI___pthread_keys",..: 2 2 2 2 2 3 3 3 3 3 ...
 $ N        : int  11 11 11 11 11 4 2 4 4 4 ...
       Page Tid Structure  N     PageB
1 100003840   3 key_array 11 100003840
2 100007936   3 key_array 11 100007936
3 100012032   3 key_array 11 100012032
4 100016128   3 key_array 11 100016128
5 100020224   3 key_array 11 100020224
6  10002432   0 key_buff1  4  10002432
'data.frame':	337133 obs. of  5 variables:
 $ Page     : chr  "100003840" "100007936" "100012032" "100016128" ...
 $ Tid      : int  3 3 3 3 3 0 1 2 5 6 ...
 $ Structure: Factor w/ 14 levels "__GI___pthread_keys",..: 2 2 2 2 2 3 3 3 3 3 ...
 $ N        : int  11 11 11 11 11 4 2 4 4 4 ...
 $ PageB    :Class 'bigz'  raw [1:4045600] ed 24 05 00 ...
#+end_example

Was it that easy ?

#+begin_src R :results output graphics :file img/tabarnac_page_is_b_orig_bigz.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(t,aes(x=PageB,y=Tid,color=N)) +
  theme_bw() +
  geom_point() +
  facet_wrap(~Structure) +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/tabarnac_page_is_b_orig_bigz.png]]

Obviously it is not working we can try to unclass the dataframe, not
sure how it works:

#+begin_src R :results output graphics :file img/tabarnac_page_is_b_orig_bigz1.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(unclass(t),aes(x=PageB,y=Tid,color=N)) +
  theme_bw() +
  geom_point() +
  facet_wrap(~Structure) +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/tabarnac_page_is_b_orig_bigz1.png]]

That was a bad idea ...

I think it will be simpler to affect to each page a number
corresponding to it's delta in the structure:

#+begin_src R :results output :session :exports both
pageId <- function(df){
    base <- as.bigz(structs[grepl(df[3],structs$Structure),]$AddressStart)
    return(as.integer(as.character(df[5] - base)))
}
str(structs)
head(t)
t$PageI <- apply(t,1,pageId)
head(t)
#+end_src

#+RESULTS:
#+begin_example
'data.frame':	14 obs. of  4 variables:
 $ Structure   : Factor w/ 14 levels "__GI___pthread_keys",..: 1 5 3 2 4 14 6 7 8 9 ...
 $ AddressStart: int  2196192 2196192 6305024 14693632 148911360 283131920 283137392 283141504 283145616 283149728 ...
 $ AddressSize : int  16384 16384 8388608 134217728 134217728 32816 4096 4096 4096 4096 ...
 $ AddressEnd  : int  2212576 2212576 14693632 148911360 283129088 283164736 283141488 283145600 283149712 283153824 ...
       Page Tid Structure  N     PageB
1 100003840   3 key_array 11 100003840
2 100007936   3 key_array 11 100007936
3 100012032   3 key_array 11 100012032
4 100016128   3 key_array 11 100016128
5 100020224   3 key_array 11 100020224
6  10002432   0 key_buff1  4  10002432
       Page Tid Structure  N     PageB    PageI
1 100003840   3 key_array 11 100003840 85310208
2 100007936   3 key_array 11 100007936 85314304
3 100012032   3 key_array 11 100012032 85318400
4 100016128   3 key_array 11 100016128 85322496
5 100020224   3 key_array 11 100020224 85326592
6  10002432   0 key_buff1  4  10002432  3697408
#+end_example


#+begin_src R :results output graphics :file img/tabarnac_page_is_b_orig_int.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(t,aes(x=PageI,y=Tid,color=N)) +
  theme_bw() +
  geom_point() +
  facet_wrap(~Structure) +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/tabarnac_page_is_b_orig_int.png]]



We should plot data structure separatly, keybuff1 is so small we can't
see anything:

#+begin_src R :results output :session :exports both
head(s)
head(t)
heat(t[grepl("key_buff1",t$Structure),],n=50)
#+end_src

#+RESULTS:
#+begin_example
           Address Tid Structure  N      Page
1 100000888.000000   6 key_array  4  95315064
2 100003840.000000   3 key_array 11 100003840
3 100007216.000000   6 key_array  4  86179120
4 100007936.000000   3 key_array 11 100007936
5 100009484.000000   6 key_array  4  93668876
6 100012032.000000   3 key_array 11 100012032
       Page Tid Structure  N     PageB    PageI
1 100003840   3 key_array 11 100003840 85310208
2 100007936   3 key_array 11 100007936 85314304
3 100012032   3 key_array 11 100012032 85318400
4 100016128   3 key_array 11 100016128 85322496
5 100020224   3 key_array 11 100020224 85326592
6  10002432   0 key_buff1  4  10002432  3697408
        Page Tid Structure  N    PageB   PageI
6   10002432   0 key_buff1  4 10002432 3697408
7   10002432   1 key_buff1  2 10002432 3697408
8   10002432   2 key_buff1  4 10002432 3697408
9   10002432   5 key_buff1  4 10002432 3697408
10  10002432   6 key_buff1  4 10002432 3697408
24  10006528   0 key_buff1  2 10006528 3701504
25  10006528   1 key_buff1  2 10006528 3701504
26  10006528   4 key_buff1  6 10006528 3701504
27  10006528   5 key_buff1  6 10006528 3701504
28  10006528   6 key_buff1  6 10006528 3701504
31  10007088   5 key_buff1  5 10007088 3702064
43  10010624   1 key_buff1 10 10010624 3705600
44  10010624   2 key_buff1  4 10010624 3705600
45  10010624   3 key_buff1  8 10010624 3705600
46  10010624   5 key_buff1  4 10010624 3705600
47  10010624   6 key_buff1  4 10010624 3705600
60  10014720   0 key_buff1  4 10014720 3709696
61  10014720   1 key_buff1 10 10014720 3709696
62  10014720   2 key_buff1  6 10014720 3709696
63  10014720   3 key_buff1  8 10014720 3709696
64  10014720   5 key_buff1  8 10014720 3709696
65  10014720   6 key_buff1  4 10014720 3709696
78  10018816   4 key_buff1  4 10018816 3713792
79  10018816   5 key_buff1  2 10018816 3713792
80  10018816   6 key_buff1  2 10018816 3713792
81  10018816   7 key_buff1  6 10018816 3713792
93  10022912   0 key_buff1  6 10022912 3717888
94  10022912   1 key_buff1  4 10022912 3717888
95  10022912   4 key_buff1  8 10022912 3717888
96  10022912   5 key_buff1  8 10022912 3717888
97  10022912   6 key_buff1  2 10022912 3717888
98  10022912   7 key_buff1 16 10022912 3717888
109 10027008   0 key_buff1  2 10027008 3721984
110 10027008   1 key_buff1 10 10027008 3721984
111 10027008   2 key_buff1  4 10027008 3721984
112 10027008   6 key_buff1  4 10027008 3721984
113 10027008   7 key_buff1 14 10027008 3721984
126 10031104   0 key_buff1  2 10031104 3726080
127 10031104   1 key_buff1 10 10031104 3726080
128 10031104   7 key_buff1 20 10031104 3726080
143 10035200   0 key_buff1  6 10035200 3730176
144 10035200   2 key_buff1  4 10035200 3730176
145 10035200   3 key_buff1  4 10035200 3730176
146 10035200   6 key_buff1  2 10035200 3730176
157 10039296   0 key_buff1  6 10039296 3734272
158 10039296   2 key_buff1  4 10039296 3734272
159 10039296   3 key_buff1  4 10039296 3734272
160 10039296   6 key_buff1  2 10039296 3734272
164 10040148   0 key_buff1  4 10040148 3735124
174 10043392   0 key_buff1  2 10043392 3738368
#+end_example


#+begin_src R :results output graphics :file img/tabarnac_page_is_b_orig_int_kb1.png :exports both :width 600 :height 400 :session
library(ggplot2);
u<-t[grepl("key_buff1",t$Structure),];
p <- ggplot(u,aes(x=PageI,y=Tid,color=N)) +
  theme_bw() +
  geom_point() +
  facet_wrap(~Structure) +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/tabarnac_page_is_b_orig_int_kb1.png]]


There are some negative pageIds I don't know why, but it is late and
I'm exhausted, I'll fix that tomorrow.

* DONE 2016-03-02 Continue on Tabarnac likes plot                     :David:
- State "DONE"       from "TODO"       [2016-03-03 Thu 15:11]
- State "TODO"       from              [2016-03-02 Wed 10:58]
  
We continue on the analysis from: [[*Tabarnac like plots wth Moca traces][yesterday]] trying to fix the
"addresses as factor" issue, to do so, we parse the addresses as bigz
as soon as possible:

#+begin_src R :results output :session :exports both
library(gmp)
computeType <- function(df){
  shared <-9
  write <- 4
  if(df[shared] >= 2){
    mytype <- "Shared"
  }else{
    mytype <- "Private"
  }
  if(df[write] >= 1){
     mytype <- paste(mytype,"Write" , sep="_")
  }else{
     mytype <- paste(mytype,"Read" , sep="_")
  }
  return(mytype)
}

k <- read.csv("Moca-is.B-orig-2016-03-01_14-03-40/Moca-framesoc.csv", header=T);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

k$Value <- apply(k,1,computeType)
# Use bigz to parse
k$Address <- as.character(as.bigz(paste("0x", k$Address, sep="")))
k$Phy <- NULL;
k$CPU <- NULL;
#k$Tid <- NULL;
#k$Reads <- NULL ;
#k$Writes <- NULL ;
k$Duration <- k$End - k$Start
head(k);
str(k)

# Add structure info
g <- k
structs <- read.csv("Moca-is.B-orig-2016-03-01_14-03-40/is.B-orig.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
# Use bigz to compute End, then go back tochar at sqldf does not handle bigz
structs$AddressStart <- as.bigz(structs$AddressStart)
structs$AddressSize <- as.bigz(structs$AddressSize)
structs$AddressEnd = as.character(structs$AddressStart + structs$AddressSize);
structs$AddressStart <- as.character(structs$AddressStart)
structs$AddressSize <-  as.character(structs$AddressSize)

str(structs)
show(structs)

library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.Reads, g.Writes, g.Tid, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);
#+end_src

#+RESULTS:
#+begin_example
            X.Virt            X.Phy Nreads Nwrites CPUMask  Start    End TaskId
1 0000000000400040 000062000b1dfa80      1       0    1011      1    171      0
2 00000000004002a8 000062000b1dfa80      1       0    1011  32663  34153      0
3 0000000000400bd4 000062000b1dfa80      1       0    1011  55271  72678      0
4 00000000004009a0 000062000b1dfa80      1       0      11  88569  88776      1
5 00000000004009a0 000062000b1dfa80      1       0     111  92562 103554      7
6 00000000004009a0 000062000b1dfa80      1       0   10011 238634 245102      2
  Shared
1      1
2      1
3      1
4      1
5      1
6      1
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
  Address Reads Writes  Start    End Tid N        Value Duration
1 4194368     1      0      1    171   0 1 Private_Read      170
2 4194984     1      0  32663  34153   0 1 Private_Read     1490
3 4197332     1      0  55271  72678   0 1 Private_Read    17407
4 4196768     1      0  88569  88776   1 1 Private_Read      207
5 4196768     1      0  92562 103554   7 1 Private_Read    10992
6 4196768     1      0 238634 245102   2 1 Private_Read     6468
'data.frame':	1157330 obs. of  9 variables:
 $ Address : chr  "4194368" "4194984" "4197332" "4196768" ...
 $ Reads   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes  : int  0 0 0 0 0 0 0 0 0 0 ...
 $ Start   : int  1 32663 55271 88569 92562 238634 254421 258859 258859 286485 ...
 $ End     : int  171 34153 72678 88776 103554 245102 258859 286485 286485 310331 ...
 $ Tid     : int  0 0 0 1 7 2 4 4 6 6 ...
 $ N       : int  1 1 1 1 1 1 1 2 2 1 ...
 $ Value   : chr  "Private_Read" "Private_Read" "Private_Read" "Private_Read" ...
 $ Duration: int  170 1490 17407 207 10992 6468 4438 27626 27626 23846 ...
'data.frame':	14 obs. of  4 variables:
 $ Structure   : Factor w/ 14 levels "__GI___pthread_keys",..: 1 5 3 2 4 14 6 7 8 9 ...
 $ AddressStart: chr  "2196192" "2196192" "6305024" "14693632" ...
 $ AddressSize : chr  "16384" "16384" "8388608" "134217728" ...
 $ AddressEnd  : chr  "2212576" "2212576" "14693632" "148911360" ...
                       Structure AddressStart AddressSize AddressEnd
1            __GI___pthread_keys      2196192       16384    2212576
2                 __pthread_keys      2196192       16384    2212576
3                      key_buff1      6305024     8388608   14693632
4                      key_array     14693632   134217728  148911360
5                      key_buff2    148911360   134217728  283129088
6                UnnamedStruct#2    283131920       32816  283164736
7    /tmp/NPB3.3-OMP/IS/is.c:494    283137392        4096  283141488
8  /tmp/NPB3.3-OMP/IS/is.c:494-1    283141504        4096  283145600
9  /tmp/NPB3.3-OMP/IS/is.c:494-2    283145616        4096  283149712
10 /tmp/NPB3.3-OMP/IS/is.c:494-3    283149728        4096  283153824
11 /tmp/NPB3.3-OMP/IS/is.c:494-4    283153840        4096  283157936
12 /tmp/NPB3.3-OMP/IS/is.c:494-5    283157952        4096  283162048
13 /tmp/NPB3.3-OMP/IS/is.c:494-6    283162064        4096  283166160
14 /tmp/NPB3.3-OMP/IS/is.c:494-7    283166176        4096  283170272
   Address  Start    End Duration         Value Reads Writes Tid N Structure
1 14693632      1    171      170 Private_Write     1      1   0 1 key_array
2 14693636  55271  72678    17407 Private_Write     1      1   0 1 key_array
3 14693632  88513 100648    12135  Private_Read     1      0   0 1 key_array
4 14695032 100662 103515     2853  Private_Read     1      0   0 1 key_array
5 14693632 341425 377139    35714  Private_Read     1      0   0 1 key_array
6 14693632 377139 384252     7113   Shared_Read     1      0   0 2 key_array
#+end_example

From now on we should be able to use bigz only, so let's compute the
Page and Offset of each accesses

#+begin_src R :results output :session :exports both
n <- m[grepl("key_",m$Structure),]
# Compute the first page of each structure
pageAddr <- function(df,addrcol=1){
    addrCol <- 1
    a <- as.bigz(df[addrCol])
    return (as.character(a - mod.bigz(a,4096)));
}
#structs$Page <- apply(structs[c("AddressStart","Structure")],1,pageAddr);
show(structs)
offset <- function(df){
    AddrCol <- 1
    #PageCol <- 11
    structCol <- 10
    base <- as.bigz(structs[grepl(df[structCol],structs$Structure),]$AddressStart)
    return(as.integer(as.character((as.bigz(df[AddrCol]) - base))));
}
#n$Page <- apply(n,1,pageAddr)
n$Offset <- apply(n,1,offset)
str(n)
head(n)
#+end_src

#+RESULTS:
#+begin_example
                       Structure AddressStart AddressSize AddressEnd
1            __GI___pthread_keys      2196192       16384    2212576
2                 __pthread_keys      2196192       16384    2212576
3                      key_buff1      6305024     8388608   14693632
4                      key_array     14693632   134217728  148911360
5                      key_buff2    148911360   134217728  283129088
6                UnnamedStruct#2    283131920       32816  283164736
7    /tmp/NPB3.3-OMP/IS/is.c:494    283137392        4096  283141488
8  /tmp/NPB3.3-OMP/IS/is.c:494-1    283141504        4096  283145600
9  /tmp/NPB3.3-OMP/IS/is.c:494-2    283145616        4096  283149712
10 /tmp/NPB3.3-OMP/IS/is.c:494-3    283149728        4096  283153824
11 /tmp/NPB3.3-OMP/IS/is.c:494-4    283153840        4096  283157936
12 /tmp/NPB3.3-OMP/IS/is.c:494-5    283157952        4096  283162048
13 /tmp/NPB3.3-OMP/IS/is.c:494-6    283162064        4096  283166160
14 /tmp/NPB3.3-OMP/IS/is.c:494-7    283166176        4096  283170272
'data.frame':	792868 obs. of  11 variables:
 $ Address  : chr  "14693632" "14693636" "14693632" "14695032" ...
 $ Start    : int  1 55271 88513 100662 341425 377139 546598 618709 659766 1 ...
 $ End      : int  171 72678 100648 103515 377139 384252 618709 659753 689920 171 ...
 $ Duration : int  170 17407 12135 2853 35714 7113 72111 41044 30154 170 ...
 $ Value    : chr  "Private_Write" "Private_Write" "Private_Read" "Private_Read" ...
 $ Reads    : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes   : int  1 1 0 0 0 0 0 0 0 1 ...
 $ Tid      : int  0 0 0 0 0 0 0 0 0 0 ...
 $ N        : int  1 1 1 1 1 2 2 1 1 1 ...
 $ Structure: Factor w/ 14 levels "__GI___pthread_keys",..: 2 2 2 2 2 2 2 2 2 2 ...
 $ Offset   : int  0 4 0 1400 0 0 0 0 0 2816 ...
   Address  Start    End Duration         Value Reads Writes Tid N Structure
1 14693632      1    171      170 Private_Write     1      1   0 1 key_array
2 14693636  55271  72678    17407 Private_Write     1      1   0 1 key_array
3 14693632  88513 100648    12135  Private_Read     1      0   0 1 key_array
4 14695032 100662 103515     2853  Private_Read     1      0   0 1 key_array
5 14693632 341425 377139    35714  Private_Read     1      0   0 1 key_array
6 14693632 377139 384252     7113   Shared_Read     1      0   0 2 key_array
  Offset
1      0
2      4
3      0
4   1400
5      0
6      0
#+end_example

Let's check if it's ok:
#+begin_src R :results output :session :exports both
head(subset(n,n$Offset < 0)) 
#+end_src

#+RESULTS:
#+begin_example
     Address  Start    End Duration         Value Reads Writes Tid N Structure
944 14893056    178   2972     2794 Private_Write     1      1   0 1 key_buff2
945 14893056  55271  72678    17407  Private_Read     1      0   0 1 key_buff2
946 14893056 106948 117919    10971  Private_Read     1      0   0 1 key_buff2
947 14893056 313094 341415    28321  Private_Read     1      0   0 1 key_buff2
948 14893056 341425 384252    42827  Private_Read     1      0   0 1 key_buff2
949 14893056 384254 444926    60672  Private_Read     1      0   0 1 key_buff2
        Offset
944 -134018304
945 -134018304
946 -134018304
947 -134018304
948 -134018304
949 -134018304
#+end_example

We have some negative offset again, I guess that the sqldf is not
working as it is doing comparison on factors, let see if we can do
this comparing big integers:

#+begin_src R :results output :session :exports both
library(gmp)


k <- read.csv("Moca-is.B-orig-2016-03-01_14-03-40/Moca-framesoc.csv", header=T);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

# Use bigz to parse
k$Address <- as.bigz(paste("0x", k$Address, sep=""))
k$Phy <- NULL;
k$CPU <- NULL;
k$Duration <- k$End - k$Start
head(k);
str(k)

# Add structure info
structs <- read.csv("Moca-is.B-orig-2016-03-01_14-03-40/is.B-orig.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressStart <- as.bigz(structs$AddressStart)
structs$AddressSize <- as.bigz(structs$AddressSize)
structs$AddressEnd <- structs$AddressStart + structs$AddressSize


# Filter interesting data structure as soon as possible
structs <- structs[grepl("key_",structs$Structure),]
str(structs)
show(structs)
#+end_src

#+RESULTS:
#+begin_example

Attaching package: ‘gmp’

The following objects are masked from ‘package:base’:

    %*%, apply, crossprod, matrix, tcrossprod
            X.Virt            X.Phy Nreads Nwrites CPUMask  Start    End TaskId
1 0000000000400040 000062000b1dfa80      1       0    1011      1    171      0
2 00000000004002a8 000062000b1dfa80      1       0    1011  32663  34153      0
3 0000000000400bd4 000062000b1dfa80      1       0    1011  55271  72678      0
4 00000000004009a0 000062000b1dfa80      1       0      11  88569  88776      1
5 00000000004009a0 000062000b1dfa80      1       0     111  92562 103554      7
6 00000000004009a0 000062000b1dfa80      1       0   10011 238634 245102      2
  Shared
1      1
2      1
3      1
4      1
5      1
6      1
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
  Address Reads Writes  Start    End Tid N Duration
1 4194368     1      0      1    171   0 1      170
2 4194984     1      0  32663  34153   0 1     1490
3 4197332     1      0  55271  72678   0 1    17407
4 4196768     1      0  88569  88776   1 1      207
5 4196768     1      0  92562 103554   7 1    10992
6 4196768     1      0 238634 245102   2 1     6468
'data.frame':	1157330 obs. of  8 variables:
 $ Address :Class 'bigz'  raw [1:13892924] d2 a8 11 00 ...
 $ Reads   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes  : int  0 0 0 0 0 0 0 0 0 0 ...
 $ Start   : int  1 32663 55271 88569 92562 238634 254421 258859 258859 286485 ...
 $ End     : int  171 34153 72678 88776 103554 245102 258859 286485 286485 310331 ...
 $ Tid     : int  0 0 0 1 7 2 4 4 6 6 ...
 $ N       : int  1 1 1 1 1 1 1 2 2 1 ...
 $ Duration: int  170 1490 17407 207 10992 6468 4438 27626 27626 23846 ...
'data.frame':	3 obs. of  4 variables:
 $ Structure   : Factor w/ 14 levels "__GI___pthread_keys",..: 3 2 4
 $ AddressStart:Class 'bigz'  raw [1:40] 03 00 00 00 ...
 $ AddressSize :Class 'bigz'  raw [1:40] 03 00 00 00 ...
 $ AddressEnd  :Class 'bigz'  raw [1:40] 03 00 00 00 ...
  Structure AddressStart AddressSize AddressEnd
3 key_buff1      6305024     8388608   14693632
4 key_array     14693632   134217728  148911360
5 key_buff2    148911360   134217728  283129088
#+end_example

We now that because of the preprocessing both k and structs are sorted
increasingly, we can use this to compute quickly data structure
without using sqldf (which does not handle big integers).
First let filter out everything that is not in a data structure:

#+begin_src R :results output :session :exports both
nrow(k)
minA <- structs[1,2]
maxA <- structs[3,4]
l <- subset(k, k$Address >= minA & k$Address <= maxA)
computeType <- function(df){
  shared <- 7
  write  <- 3
  if(df[shared] >= 2){
    mytype <- "Shared"
  }else{
    mytype <- "Private"
  }
  if(df[write] >= 1){
     mytype <- paste(mytype,"Write" , sep="_")
  }else{
     mytype <- paste(mytype,"Read" , sep="_")
  }
  return(mytype)
}
l$Value <- apply(l,1,computeType)
nrow(l)
head(l)
getStruct <- function(vect){
    aCol <- 1
    while(vect[1] > structs[curStruct,4]){
      curStruct <- curStruct +1;
    }
    return(structs[curStruct,1]);
}
curStruct <- 1
l$Structure <- apply(l,1,getStruct)
head(l)
#+end_src

#+RESULTS:
#+begin_example
[1] 1157330
[1] 1150520
   Address Reads Writes  Start    End Tid N Duration         Value
80 6307840     1      1 279630 283344   7 1     3714 Private_Write
81 6307840     1      1 310398 410993   6 1   100595 Private_Write
82 6307840     1      1 452318 485570   6 1    33252 Private_Write
83 6307840     1      1 485572 511748   6 1    26176 Private_Write
84 6307840     1      1 511748 521080   6 2     9332  Shared_Write
85 6307840     1      1 511748 521080   0 2     9332  Shared_Write
   Address Reads Writes  Start    End Tid N Duration         Value Structure
80 6307840     1      1 279630 283344   7 1     3714 Private_Write key_buff1
81 6307840     1      1 310398 410993   6 1   100595 Private_Write key_buff1
82 6307840     1      1 452318 485570   6 1    33252 Private_Write key_buff1
83 6307840     1      1 485572 511748   6 1    26176 Private_Write key_buff1
84 6307840     1      1 511748 521080   6 2     9332  Shared_Write key_buff1
85 6307840     1      1 511748 521080   0 2     9332  Shared_Write key_buff1
#+end_example

This is clearly not the R way to do this and it is not very efficient
(about 5'), but it works.
We can now compute offset and it shouldn't be negative:

#+begin_src R :results output :session :exports both
pageAddr <- function(df,addrcol=1){
    addrCol <- 1
    a <- as.bigz(df[addrCol])
    return (as.character(a - mod.bigz(a,4096)));
}
structs$Page <- apply(structs[c("AddressStart","Structure")],1,pageAddr);
show(structs)
offset <- function(df){
    PageCol <- 11
    structCol <- 10
    base <- as.bigz(structs[grepl(df[structCol],structs$Structure),]$Page)
    return(as.integer(as.character((as.bigz(df[PageCol]) - base)))/4096);
}
l$Page <- apply(l,1,pageAddr)
l$Offset <- apply(l,1,offset)
str(l)
head(l)
#+end_src

#+RESULTS:
#+begin_example
  Structure AddressStart AddressSize AddressEnd      Page
3 key_buff1      6305024     8388608   14693632   6303744
4 key_array     14693632   134217728  148911360  14692352
5 key_buff2    148911360   134217728  283129088 148910080
'data.frame':	1150520 obs. of  12 variables:
 $ Address  :Class 'bigz'  raw [1:13806244] 38 8e 11 00 ...
 $ Reads    : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Start    : int  279630 310398 452318 485572 511748 511748 521080 522640 522640 538401 ...
 $ End      : int  283344 410993 485570 511748 521080 521080 522640 538401 538401 578774 ...
 $ Tid      : int  7 6 6 6 6 0 0 0 6 6 ...
 $ N        : int  1 1 1 1 2 2 1 2 2 1 ...
 $ Duration : int  3714 100595 33252 26176 9332 9332 1560 15761 15761 40373 ...
 $ Value    : chr  "Private_Write" "Private_Write" "Private_Write" "Private_Write" ...
 $ Structure: Factor w/ 14 levels "__GI___pthread_keys",..: 3 3 3 3 3 3 3 3 3 3 ...
 $ Page     : chr  "6307840" "6307840" "6307840" "6307840" ...
 $ Offset   : num  1 1 1 1 1 1 1 1 1 1 ...
   Address Reads Writes  Start    End Tid N Duration         Value Structure
80 6307840     1      1 279630 283344   7 1     3714 Private_Write key_buff1
81 6307840     1      1 310398 410993   6 1   100595 Private_Write key_buff1
82 6307840     1      1 452318 485570   6 1    33252 Private_Write key_buff1
83 6307840     1      1 485572 511748   6 1    26176 Private_Write key_buff1
84 6307840     1      1 511748 521080   6 2     9332  Shared_Write key_buff1
85 6307840     1      1 511748 521080   0 2     9332  Shared_Write key_buff1
      Page Offset
80 6307840      1
81 6307840      1
82 6307840      1
83 6307840      1
84 6307840      1
85 6307840      1
#+end_example

Once again around 5 minutes, I guess we can improve this, but for now
let's continue

#+begin_src R :results output :session :exports both
library(plyr)
m <- ddply(l,.(Offset, Tid, Structure), summarize, N=sum(Reads)+sum(Writes));
str(m)
head(m)
#+end_src

This was creazily slow, from what I read, I guess that aggregate
should be faster, let's give it a try:

#+begin_src R :results output :session :exports both
m <- aggregate(l[,c('Reads','Writes', 'N')],l[,c('Tid','Structure','Offset')], function(d) sum(d));
str(m)
head(m)
#+end_src

#+RESULTS:
#+begin_example
'data.frame':	201665 obs. of  6 variables:
 $ Tid      : int  0 0 1 2 3 4 5 6 7 0 ...
 $ Structure: Factor w/ 14 levels "__GI___pthread_keys",..: 2 4 4 4 4 4 4 4 4 2 ...
 $ Offset   : num  0 0 0 0 0 0 0 0 0 1 ...
 $ Reads    : int  2 13 5 20 15 11 18 23 25 14 ...
 $ Writes   : int  1 6 5 20 15 10 10 12 14 2 ...
 $ N        : int  2 39 15 42 34 31 58 75 80 14 ...
  Tid Structure Offset Reads Writes  N
1   0 key_array      0     2      1  2
2   0 key_buff2      0    13      6 39
3   1 key_buff2      0     5      5 15
4   2 key_buff2      0    20     20 42
5   3 key_buff2      0    15     15 34
6   4 key_buff2      0    11     10 31
#+end_example

It tooks only a few seconds, this is impressive !

#+begin_src R :results output graphics :file img/tabarnac_page_is_b_offsetfix.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(m,aes(x=Offset,y=Tid,color=Reads+Writes)) +
  theme_bw() +
  geom_point() +
  facet_wrap(~Structure) +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/tabarnac_page_is_b_offsetfix.png]]


No more negative offset, this looks great, let's focus on keybuff1

#+begin_src R :results output graphics :file img/tabarnac_page_is_b_offsetfix_kb1.png :exports both :width 600 :height 400 :session
library(ggplot2);
n <- m[grepl("key_buff1", m$Structure),];
p <- ggplot(n,aes(x=Offset,y=Tid,color=Reads+Writes)) +
  theme_bw() +
  geom_point() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/tabarnac_page_is_b_offsetfix_kb1.png]]

And here comes the bad news: Moca traces are not precise enough to see
the fact that the middle addresses of keybuff1 are accessed more often
than the others...


What happens if we plot the number of threads using the page at the
same time:

#+begin_src R :results output graphics :file img/is_b_intensity_offset.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(m,aes(x=Offset,y=Tid,color=N)) +
  theme_bw() +
  geom_point() +
  theme(legend.title=element_blank()) +
  facet_wrap(~Structure) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/is_b_intensity_offset.png]]

Once again we need to zoom

#+begin_src R :results output graphics :file img/is_b_intensity_offset_kb1.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(n,aes(x=Offset,y=Tid,color=N)) +
  theme_bw() +
  geom_point() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/is_b_intensity_offset_kb1.png]]


And once again we can't see anything.

So it appears that with Moca if we gain the temporal information, our
traces are not precise enough to see the same things as Tabarnac.

While I was writing the code to do these plots, I fixed the ugly
addresses issue, I think I should redo the plot from [[*IShttp:][IS]] but with the
addresses fixed, maybe a pattern can appear.

My R code I very ugly and not really R-ish, @Lucas if you have some
time maybe you can speed up (the call to apply are very slow).

* 2016-03-03 Redo analysis from [[*IS][IS]] with addresses fixed               :David:

Let prepare the data as in [[*2016-03-02 Continue on Tabarnac likes plot][2016-03-02 Continue on Tabarnac likes plot]]:


#+begin_src R :results output :session :exports both
library(gmp)


k <- read.csv("Moca-is.B-orig-2016-03-01_14-03-40/Moca-framesoc.csv", header=T);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

# Use bigz to parse
k$Address <- as.bigz(paste("0x", k$Address, sep=""))
k$Phy <- NULL;
k$CPU <- NULL;
k$Duration <- k$End - k$Start
head(k);
str(k)

# Add structure info
structs <- read.csv("Moca-is.B-orig-2016-03-01_14-03-40/is.B-orig.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressStart <- as.bigz(structs$AddressStart)
structs$AddressSize <- as.bigz(structs$AddressSize)
structs$AddressEnd <- structs$AddressStart + structs$AddressSize


# Filter interesting data structure as soon as possible
structs <- structs[grepl("key_",structs$Structure),]
str(structs)
show(structs)

# Retrieve struct infos
nrow(k)
minA <- structs[1,2]
maxA <- structs[3,4]
l <- subset(k, k$Address >= minA & k$Address <= maxA)
computeType <- function(df){
  shared <- 7
  write  <- 3
  if(df[shared] >= 2){
    mytype <- "Shared"
  }else{
    mytype <- "Private"
  }
  if(df[write] >= 1){
     mytype <- paste(mytype,"Write" , sep="_")
  }else{
     mytype <- paste(mytype,"Read" , sep="_")
  }
  return(mytype)
}
l$Value <- apply(l,1,computeType)
nrow(l)
head(l)
getStruct <- function(vect){
    aCol <- 1
    while(vect[1] > structs[curStruct,4]){
      curStruct <- curStruct +1;
    }
    return(structs[curStruct,1]);
}
curStruct <- 1
l$Structure <- apply(l,1,getStruct)
head(l)
#+end_src

#+RESULTS:
#+begin_example

Attaching package: ‘gmp’

The following objects are masked from ‘package:base’:

    %*%, apply, crossprod, matrix, tcrossprod
            X.Virt            X.Phy Nreads Nwrites CPUMask  Start    End TaskId
1 0000000000400040 000062000b1dfa80      1       0    1011      1    171      0
2 00000000004002a8 000062000b1dfa80      1       0    1011  32663  34153      0
3 0000000000400bd4 000062000b1dfa80      1       0    1011  55271  72678      0
4 00000000004009a0 000062000b1dfa80      1       0      11  88569  88776      1
5 00000000004009a0 000062000b1dfa80      1       0     111  92562 103554      7
6 00000000004009a0 000062000b1dfa80      1       0   10011 238634 245102      2
  Shared
1      1
2      1
3      1
4      1
5      1
6      1
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
  Address Reads Writes  Start    End Tid N Duration
1 4194368     1      0      1    171   0 1      170
2 4194984     1      0  32663  34153   0 1     1490
3 4197332     1      0  55271  72678   0 1    17407
4 4196768     1      0  88569  88776   1 1      207
5 4196768     1      0  92562 103554   7 1    10992
6 4196768     1      0 238634 245102   2 1     6468
'data.frame':	1157330 obs. of  8 variables:
 $ Address :Class 'bigz'  raw [1:13892924] d2 a8 11 00 ...
 $ Reads   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes  : int  0 0 0 0 0 0 0 0 0 0 ...
 $ Start   : int  1 32663 55271 88569 92562 238634 254421 258859 258859 286485 ...
 $ End     : int  171 34153 72678 88776 103554 245102 258859 286485 286485 310331 ...
 $ Tid     : int  0 0 0 1 7 2 4 4 6 6 ...
 $ N       : int  1 1 1 1 1 1 1 2 2 1 ...
 $ Duration: int  170 1490 17407 207 10992 6468 4438 27626 27626 23846 ...
'data.frame':	3 obs. of  4 variables:
 $ Structure   : Factor w/ 14 levels "__GI___pthread_keys",..: 3 2 4
 $ AddressStart:Class 'bigz'  raw [1:40] 03 00 00 00 ...
 $ AddressSize :Class 'bigz'  raw [1:40] 03 00 00 00 ...
 $ AddressEnd  :Class 'bigz'  raw [1:40] 03 00 00 00 ...
  Structure AddressStart AddressSize AddressEnd
3 key_buff1      6305024     8388608   14693632
4 key_array     14693632   134217728  148911360
5 key_buff2    148911360   134217728  283129088
[1] 1157330
[1] 1150520
   Address Reads Writes  Start    End Tid N Duration         Value
80 6307840     1      1 279630 283344   7 1     3714 Private_Write
81 6307840     1      1 310398 410993   6 1   100595 Private_Write
82 6307840     1      1 452318 485570   6 1    33252 Private_Write
83 6307840     1      1 485572 511748   6 1    26176 Private_Write
84 6307840     1      1 511748 521080   6 2     9332  Shared_Write
85 6307840     1      1 511748 521080   0 2     9332  Shared_Write
   Address Reads Writes  Start    End Tid N Duration         Value Structure
80 6307840     1      1 279630 283344   7 1     3714 Private_Write key_buff1
81 6307840     1      1 310398 410993   6 1   100595 Private_Write key_buff1
82 6307840     1      1 452318 485570   6 1    33252 Private_Write key_buff1
83 6307840     1      1 485572 511748   6 1    26176 Private_Write key_buff1
84 6307840     1      1 511748 521080   6 2     9332  Shared_Write key_buff1
85 6307840     1      1 511748 521080   0 2     9332  Shared_Write key_buff1
#+end_example

Now compute offset for each addresses instead of for each pages:

#+begin_src R :results output :session :exports both
# Compute offset
#pageAddr <- function(df,addrcol=1){
#    addrCol <- 1
#    a <- as.bigz(df[addrCol])
#    return (as.character(a - mod.bigz(a,4096)));
#}
#structs$Page <- apply(structs[c("AddressStart","Structure")],1,pageAddr);
#show(structs)
m <- l
offset <- function(df){
    AddrCol <- 1
    structCol <- 10
    base <- as.bigz(structs[grepl(df[structCol],structs$Structure),]$AddressStart)
    return(as.integer(as.character((as.bigz(df[AddrCol]) - base))));
}
#l$Page <- apply(l,1,pageAddr)
m$Offset <- apply(m,1,offset)
str(m)
head(m)
#+end_src

#+RESULTS:
#+begin_example
'data.frame':	1150520 obs. of  11 variables:
 $ Address  :Class 'bigz'  raw [1:13806244] 38 8e 11 00 ...
 $ Reads    : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Start    : int  279630 310398 452318 485572 511748 511748 521080 522640 522640 538401 ...
 $ End      : int  283344 410993 485570 511748 521080 521080 522640 538401 538401 578774 ...
 $ Tid      : int  7 6 6 6 6 0 0 0 6 6 ...
 $ N        : int  1 1 1 1 2 2 1 2 2 1 ...
 $ Duration : int  3714 100595 33252 26176 9332 9332 1560 15761 15761 40373 ...
 $ Value    : chr  "Private_Write" "Private_Write" "Private_Write" "Private_Write" ...
 $ Structure: Factor w/ 14 levels "__GI___pthread_keys",..: 3 3 3 3 3 3 3 3 3 3 ...
 $ Offset   : int  2816 2816 2816 2816 2816 2816 2816 2816 2816 2816 ...
   Address Reads Writes  Start    End Tid N Duration         Value Structure
80 6307840     1      1 279630 283344   7 1     3714 Private_Write key_buff1
81 6307840     1      1 310398 410993   6 1   100595 Private_Write key_buff1
82 6307840     1      1 452318 485570   6 1    33252 Private_Write key_buff1
83 6307840     1      1 485572 511748   6 1    26176 Private_Write key_buff1
84 6307840     1      1 511748 521080   6 2     9332  Shared_Write key_buff1
85 6307840     1      1 511748 521080   0 2     9332  Shared_Write key_buff1
   Offset
80   2816
81   2816
82   2816
83   2816
84   2816
85   2816
#+end_example

#+begin_src R :results output :session :exports both
n <- aggregate(m[,c('Reads','Writes', 'N')],m[,c('Structure','Offset', 'Value', 'Start', 'End')], function(d) sum(d));
str(n)
head(n)
#+end_src

#+RESULTS:
#+begin_example
'data.frame':	1078089 obs. of  8 variables:
 $ Structure: Factor w/ 14 levels "__GI___pthread_keys",..: 2 2 2 3 3 3 3 3 3 3 ...
 $ Offset   : int  83884800 2816 6912 981472 1014168 1019864 1025192 1027256 1034226 1035544 ...
 $ Value    : chr  "Private_Write" "Private_Write" "Private_Write" "Private_Write" ...
 $ Start    : int  157 1 1 1 1 1 1 1 1 1 ...
 $ End      : int  158 171 171 171 171 171 171 171 171 171 ...
 $ Reads    : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ N        : int  1 1 1 1 1 1 1 1 1 1 ...
  Structure   Offset         Value Start End Reads Writes N
1 key_array 83884800 Private_Write   157 158     1      1 1
2 key_array     2816 Private_Write     1 171     1      1 1
3 key_array     6912 Private_Write     1 171     1      1 1
4 key_buff1   981472 Private_Write     1 171     1      1 1
5 key_buff1  1014168 Private_Write     1 171     1      1 1
6 key_buff1  1019864 Private_Write     1 171     1      1 1
#+end_example

#+begin_src R :results output graphics :file img/intensity_Rw_is_B_fixy.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(n) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Offset,yend=Offset, color=Reads+Writes)) +
  facet_grid(Structure~Value, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_Rw_is_B_fixy.png]]

This is the fixed version of 
[[file:img/intensity_is_B_orig_threads_zoom_nacc.png][file:~/Work/labbook-lucas/img/intensity_is_B_orig_threads_zoom_nacc.png]]

The patterns are quite similar, we can see some differences on keyarray.


What happens if we look at the intensity in terms of number of
threads:

#+begin_src R :results output graphics :file img/intensity_Th_is_B_fixy.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Offset,yend=Offset, color=N)) +
  facet_grid(Structure~Value, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_Th_is_B_fixy.png]]

The original version  was 

[[file:img/intensity_is_threads_zoom.png][file:~/Work/labbook-lucas/img/intensity_is_threads_zoom.png]]


Once again we can't see a difference of pattern between the addresses
of IS, still the change on the way we compute the addresses has an
important impact on the resulting visualization. I think we need to
redo the analysis of IS modif and the two matrix, but maybe we should
improve my R code before.

 If we can't see the difference of pattern inside keybuff1 as we did
 with tabarnac, we can still identify that keybuff1 usage is
 problematic as it is intesensively shared in write mode by more than
 half the threads.

* 2016-03-07 Improve parsing time                                     :David:

Same analysis as [[*2016-03-03%20Redo%20analysis%20from%20%5B%5B*IS%5D%5BIS%5D%5D%20with%20addresses%20fixed][2016-03-03 Redo analysis from IS with addresses fixed]]
but try to do it faster

First let compute the base time
#+begin_src R :results output :session :exports both
library(gmp)


system.time(k <- read.csv("Moca-is.B-orig-2016-03-01_14-03-40/Moca-framesoc.csv", header=T));
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

# Use bigz to parse
k$Address <- as.bigz(paste("0x", k$Address, sep=""))
k$Phy <- NULL;
k$CPU <- NULL;
k$Duration <- k$End - k$Start
head(k);
str(k)

# Add structure info
structs <- read.csv("Moca-is.B-orig-2016-03-01_14-03-40/is.B-orig.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressStart <- as.bigz(structs$AddressStart)
structs$AddressSize <- as.bigz(structs$AddressSize)
structs$AddressEnd <- structs$AddressStart + structs$AddressSize


# Filter interesting data structure as soon as possible
structs <- structs[grepl("key_",structs$Structure),]
str(structs)
show(structs)

# Retrieve struct infos
nrow(k)
minA <- structs[1,2]
maxA <- structs[3,4]
system.time(l <- subset(k, k$Address >= minA & k$Address <= maxA));
computeType <- function(df){
  shared <- 7
  write  <- 3
  if(df[shared] >= 2){
    mytype <- "Shared"
  }else{
    mytype <- "Private"
  }
  if(df[write] >= 1){
     mytype <- paste(mytype,"Write" , sep="_")
  }else{
     mytype <- paste(mytype,"Read" , sep="_")
  }
  return(mytype)
}
system.time(l$Value <- apply(l,1,computeType));
nrow(l)
head(l)
getStruct <- function(vect){
    aCol <- 1
    while(vect[1] > structs[curStruct,4]){
      curStruct <- curStruct +1;
    }
    return(structs[curStruct,1]);
}
curStruct <- 1
system.time(l$Structure <- apply(l,1,getStruct))
head(l)
#+end_src

#+RESULTS:
#+begin_example

Attaching package: ‘gmp’

The following objects are masked from ‘package:base’:

    %*%, apply, crossprod, matrix, tcrossprod
   user  system elapsed 
  7.476   0.088   7.566
            X.Virt            X.Phy Nreads Nwrites CPUMask  Start    End TaskId
1 0000000000400040 000062000b1dfa80      1       0    1011      1    171      0
2 00000000004002a8 000062000b1dfa80      1       0    1011  32663  34153      0
3 0000000000400bd4 000062000b1dfa80      1       0    1011  55271  72678      0
4 00000000004009a0 000062000b1dfa80      1       0      11  88569  88776      1
5 00000000004009a0 000062000b1dfa80      1       0     111  92562 103554      7
6 00000000004009a0 000062000b1dfa80      1       0   10011 238634 245102      2
  Shared
1      1
2      1
3      1
4      1
5      1
6      1
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
  Address Reads Writes  Start    End Tid N Duration
1 4194368     1      0      1    171   0 1      170
2 4194984     1      0  32663  34153   0 1     1490
3 4197332     1      0  55271  72678   0 1    17407
4 4196768     1      0  88569  88776   1 1      207
5 4196768     1      0  92562 103554   7 1    10992
6 4196768     1      0 238634 245102   2 1     6468
'data.frame':	1157330 obs. of  8 variables:
 $ Address :Class 'bigz'  raw [1:13892924] d2 a8 11 00 ...
 $ Reads   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes  : int  0 0 0 0 0 0 0 0 0 0 ...
 $ Start   : int  1 32663 55271 88569 92562 238634 254421 258859 258859 286485 ...
 $ End     : int  171 34153 72678 88776 103554 245102 258859 286485 286485 310331 ...
 $ Tid     : int  0 0 0 1 7 2 4 4 6 6 ...
 $ N       : int  1 1 1 1 1 1 1 2 2 1 ...
 $ Duration: int  170 1490 17407 207 10992 6468 4438 27626 27626 23846 ...
'data.frame':	3 obs. of  4 variables:
 $ Structure   : Factor w/ 14 levels "__GI___pthread_keys",..: 3 2 4
 $ AddressStart:Class 'bigz'  raw [1:40] 03 00 00 00 ...
 $ AddressSize :Class 'bigz'  raw [1:40] 03 00 00 00 ...
 $ AddressEnd  :Class 'bigz'  raw [1:40] 03 00 00 00 ...
  Structure AddressStart AddressSize AddressEnd
3 key_buff1      6305024     8388608   14693632
4 key_array     14693632   134217728  148911360
5 key_buff2    148911360   134217728  283129088
[1] 1157330
   user  system elapsed 
  2.604   0.044   2.645
   user  system elapsed 
 23.712   0.092  23.812
[1] 1150520
   Address Reads Writes  Start    End Tid N Duration         Value
80 6307840     1      1 279630 283344   7 1     3714 Private_Write
81 6307840     1      1 310398 410993   6 1   100595 Private_Write
82 6307840     1      1 452318 485570   6 1    33252 Private_Write
83 6307840     1      1 485572 511748   6 1    26176 Private_Write
84 6307840     1      1 511748 521080   6 2     9332  Shared_Write
85 6307840     1      1 511748 521080   0 2     9332  Shared_Write
   user  system elapsed 
200.472   0.396 200.992
   Address Reads Writes  Start    End Tid N Duration         Value Structure
80 6307840     1      1 279630 283344   7 1     3714 Private_Write key_buff1
81 6307840     1      1 310398 410993   6 1   100595 Private_Write key_buff1
82 6307840     1      1 452318 485570   6 1    33252 Private_Write key_buff1
83 6307840     1      1 485572 511748   6 1    26176 Private_Write key_buff1
84 6307840     1      1 511748 521080   6 2     9332  Shared_Write key_buff1
85 6307840     1      1 511748 521080   0 2     9332  Shared_Write key_buff1
#+end_example

As noticed before, the slow path correspond to the apply calls.
Let se if we can replace it by ddply:

#+begin_src R :results output :session :exports both
library(plyr)
m <- l
m$Type <- NULL
m$Structure <- NULL
m$shared <- k$shared
computeType <- function(df){
  shared <- 1
  write  <- 2
  if(df[shared] >= 2){
    mytype <- "Shared"
  }else{
    mytype <- "Private"
  }
  if(df[write] >= 1){
     mytype <- paste(mytype,"Write" , sep="_")
  }else{
     mytype <- paste(mytype,"Read" , sep="_")
  }
  return(mytype)
}
curStruct <- 1
getStruct <- function(vect){
    aCol <- 1
    while(vect[1] > structs[curStruct,4]){
      curStruct <- curStruct +1;
    }
    return(structs[curStruct,1]);
}
system.time(n <- ddply(m,.(Address,Start,End,Tid),Reads=Reads,Writes=Writes,Value=computeType(shared,Writes),
structure=getStruct(Address)));
nrow(n)
head(n)
#+end_src

This is worst, I killed R after around 20 minutes of computing with
results ...

let's retry focus only on access type for now

Redo the parsing step properly:

#+begin_src R :results output :session :exports both
library(gmp)


system.time(k <- read.csv("Moca-is.B-orig-2016-03-01_14-03-40/Moca-framesoc.csv", header=T));
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

# Use bigz to parse
k$Address <- as.bigz(paste("0x", k$Address, sep=""))
k$Phy <- NULL;
k$CPU <- NULL;
k$Duration <- k$End - k$Start
head(k);
str(k)

# Add structure info
structs <- read.csv("Moca-is.B-orig-2016-03-01_14-03-40/is.B-orig.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressStart <- as.bigz(structs$AddressStart)
structs$AddressSize <- as.bigz(structs$AddressSize)
structs$AddressEnd <- structs$AddressStart + structs$AddressSize


# Filter interesting data structure as soon as possible
structs <- structs[grepl("key_",structs$Structure),]
str(structs)
show(structs)

# Retrieve struct infos
nrow(k)
minA <- structs[1,2]
maxA <- structs[3,4]
system.time(l <- subset(k, k$Address >= minA & k$Address <= maxA));
head(l)
str(l)
#+end_src

#+RESULTS:
#+begin_example

Attaching package: ‘gmp’

The following objects are masked from ‘package:base’:

    %*%, apply, crossprod, matrix, tcrossprod
   user  system elapsed 
  7.804   0.212   8.032
            X.Virt            X.Phy Nreads Nwrites CPUMask  Start    End TaskId
1 0000000000400040 000062000b1dfa80      1       0    1011      1    171      0
2 00000000004002a8 000062000b1dfa80      1       0    1011  32663  34153      0
3 0000000000400bd4 000062000b1dfa80      1       0    1011  55271  72678      0
4 00000000004009a0 000062000b1dfa80      1       0      11  88569  88776      1
5 00000000004009a0 000062000b1dfa80      1       0     111  92562 103554      7
6 00000000004009a0 000062000b1dfa80      1       0   10011 238634 245102      2
  Shared
1      1
2      1
3      1
4      1
5      1
6      1
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
  Address Reads Writes  Start    End Tid N Duration
1 4194368     1      0      1    171   0 1      170
2 4194984     1      0  32663  34153   0 1     1490
3 4197332     1      0  55271  72678   0 1    17407
4 4196768     1      0  88569  88776   1 1      207
5 4196768     1      0  92562 103554   7 1    10992
6 4196768     1      0 238634 245102   2 1     6468
'data.frame':	1157330 obs. of  8 variables:
 $ Address :Class 'bigz'  raw [1:13892924] d2 a8 11 00 ...
 $ Reads   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes  : int  0 0 0 0 0 0 0 0 0 0 ...
 $ Start   : int  1 32663 55271 88569 92562 238634 254421 258859 258859 286485 ...
 $ End     : int  171 34153 72678 88776 103554 245102 258859 286485 286485 310331 ...
 $ Tid     : int  0 0 0 1 7 2 4 4 6 6 ...
 $ N       : int  1 1 1 1 1 1 1 2 2 1 ...
 $ Duration: int  170 1490 17407 207 10992 6468 4438 27626 27626 23846 ...
'data.frame':	3 obs. of  4 variables:
 $ Structure   : Factor w/ 14 levels "__GI___pthread_keys",..: 3 2 4
 $ AddressStart:Class 'bigz'  raw [1:40] 03 00 00 00 ...
 $ AddressSize :Class 'bigz'  raw [1:40] 03 00 00 00 ...
 $ AddressEnd  :Class 'bigz'  raw [1:40] 03 00 00 00 ...
  Structure AddressStart AddressSize AddressEnd
3 key_buff1      6305024     8388608   14693632
4 key_array     14693632   134217728  148911360
5 key_buff2    148911360   134217728  283129088
[1] 1157330
   user  system elapsed 
  2.652   0.032   2.692
   Address Reads Writes  Start    End Tid N Duration
80 6307840     1      1 279630 283344   7 1     3714
81 6307840     1      1 310398 410993   6 1   100595
82 6307840     1      1 452318 485570   6 1    33252
83 6307840     1      1 485572 511748   6 1    26176
84 6307840     1      1 511748 521080   6 2     9332
85 6307840     1      1 511748 521080   0 2     9332
'data.frame':	1150520 obs. of  8 variables:
 $ Address :Class 'bigz'  raw [1:13806244] 38 8e 11 00 ...
 $ Reads   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes  : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Start   : int  279630 310398 452318 485572 511748 511748 521080 522640 522640 538401 ...
 $ End     : int  283344 410993 485570 511748 521080 521080 522640 538401 538401 578774 ...
 $ Tid     : int  7 6 6 6 6 0 0 0 6 6 ...
 $ N       : int  1 1 1 1 2 2 1 2 2 1 ...
 $ Duration: int  3714 100595 33252 26176 9332 9332 1560 15761 15761 40373 ...
#+end_example

Now we can work on a clean data frame

#+begin_src R :results output :session :exports both
library(plyr)
m <- l
m$Type <- NULL
m$Structure <- NULL
computeType <- function(df){
  shared <- 1
  write  <- 2
  if(df[shared] >= 2){
    mytype <- "Shared"
  }else{
    mytype <- "Private"
  }
  if(df[write] >= 1){
     mytype <- paste(mytype,"Write" , sep="_")
  }else{
     mytype <- paste(mytype,"Read" , sep="_")
  }
  return(mytype)
}

system.time(n <- ddply(m,.(Address,Reads,Writes,Start,End,Tid,N,Duration),summarize,Value=computeType(N,Writes)));
nrow(n)
head(n)
#+end_src

Killed after 10 minute this time, let's forgot ddply, it does not
seems to be a good idea

We can use the ifelse function for the time:

#+begin_src R :results output :session :exports both
m <- l
system.time(m$aType <- ifelse(m$Write >0,"Write", "Read"));
system.time(m$sType <- ifelse(m$N > 1,"Shared","Private"));
system.time(m$Type <- paste(m$sType,m$aType,sep="_"));
m$sType <- NULL
m$aType <- NULL
head(m)
#+end_src

#+RESULTS:
#+begin_example
   user  system elapsed 
  0.428   0.008   0.437
   user  system elapsed 
  0.368   0.000   0.371
   user  system elapsed 
  0.224   0.000   0.224
   Address Reads Writes  Start    End Tid N Duration          Type
80 6307840     1      1 279630 283344   7 1     3714 Private_Write
81 6307840     1      1 310398 410993   6 1   100595 Private_Write
82 6307840     1      1 452318 485570   6 1    33252 Private_Write
83 6307840     1      1 485572 511748   6 1    26176 Private_Write
84 6307840     1      1 511748 521080   6 2     9332  Shared_Write
85 6307840     1      1 511748 521080   0 2     9332  Shared_Write
#+end_example


That was fast !

Maybe we can use something simlar, doing the apply on structs:

#+begin_src R :results output :session :exports both
n <- m
n$Structure <- NULL
structs <- structs[grepl("key_",structs$Structure),]
show(structs)
getStructReverse <- function (vect){
  name <- 1
  start <- 2
  end <- 4
  return (ifelse(n$Address >= vect[start] & n$Address <= vect[end],vect[name],""));
}
system.time(ans <- as.data.frame(apply(structs,1,getStructReverse)))
system.time(n$Structure <- apply(ans,1,paste,collapse=""));
head(n)
nrow(n)
#+end_src

#+RESULTS:
#+begin_example
  Structure AddressStart AddressSize AddressEnd
3 key_buff1      6305024     8388608   14693632
4 key_array     14693632   134217728  148911360
5 key_buff2    148911360   134217728  283129088
   user  system elapsed 
  3.144   0.000   3.144
   user  system elapsed 
  5.292   0.000   5.309
   Address Reads Writes  Start    End Tid N Duration          Type Structure
80 6307840     1      1 279630 283344   7 1     3714 Private_Write key_buff1
81 6307840     1      1 310398 410993   6 1   100595 Private_Write key_buff1
82 6307840     1      1 452318 485570   6 1    33252 Private_Write key_buff1
83 6307840     1      1 485572 511748   6 1    26176 Private_Write key_buff1
84 6307840     1      1 511748 521080   6 2     9332  Shared_Write key_buff1
85 6307840     1      1 511748 521080   0 2     9332  Shared_Write key_buff1
[1] 1150520
#+end_example

This is way faster than the previous method, about 8 seconds instead
of 200.

Let see if the data are correct (aka try to reproduce the same plots)

Hum the code of the followin step look slow, let see

#+begin_src R :results output :session :exports both
o <- n
offset <- function(df){
    AddrCol <- 1
    structCol <- 10
    base <- as.bigz(structs[grepl(df[structCol],structs$Structure),]$AddressStart)
    return(as.integer(as.character((as.bigz(df[AddrCol]) - base))));
}
system.time(o$Offset <- apply(o,1,offset))
str(o)
head(o)
#+end_src

#+RESULTS:
#+begin_example
   user  system elapsed 
288.736   0.384 289.671
[list output truncated]
   Address Reads Writes  Start    End Tid N Duration          Type Structure
80 6307840     1      1 279630 283344   7 1     3714 Private_Write key_buff1
81 6307840     1      1 310398 410993   6 1   100595 Private_Write key_buff1
82 6307840     1      1 452318 485570   6 1    33252 Private_Write key_buff1
83 6307840     1      1 485572 511748   6 1    26176 Private_Write key_buff1
84 6307840     1      1 511748 521080   6 2     9332  Shared_Write key_buff1
85 6307840     1      1 511748 521080   0 2     9332  Shared_Write key_buff1
   Offset
80   2816
81   2816
82   2816
83   2816
84   2816
85   2816
#+end_example

This is indeed quite slow ...
Maybe we can improve this by computing the offset while we retrieve
data structures:

#+begin_src R :results output :session :exports both
n <- m
n$Structure <- NULL
structs <- structs[grepl("key_",structs$Structure),]
show(structs)
getStructReverse <- function (vect){
  name <- 1
  start <- 2
  end <- 4
  return (ifelse(n$Address >= vect[start] & n$Address <= vect[end],
                paste(vect[name],as.bigz(n$Address) - as.bigz(vect[start]),sep="@"),""));
}
system.time(ans <- as.data.frame(apply(structs,1,getStructReverse)))
system.time(vect <- apply(ans,1,paste,collapse=""));
str(vect)
system.time(vect <- strsplit(vect,"@"))
str(vect)
system.time(n$Structure <- unlist(lapply(vect,"[[",1)))
system.time(n$Offset <- as.integer(unlist(lapply(vect,"[[",2))));
str(n)
head(n)
nrow(n)
#+end_src

#+RESULTS:
#+begin_example
  Structure AddressStart AddressSize AddressEnd
3 key_buff1      6305024     8388608   14693632
4 key_array     14693632   134217728  148911360
5 key_buff2    148911360   134217728  283129088
   user  system elapsed 
 11.308   0.036  11.357
   user  system elapsed 
  5.068   0.000   5.071
 chr [1:1150520] "key_buff1@2816" "key_buff1@2816" "key_buff1@2816" ...
   user  system elapsed 
  1.932   0.000   1.933
List of 1150520
 $ : chr [1:2] "key_buff1" "2816"
 $ : chr [1:2] "key_buff1" "2816"
 $ : chr [1:2] "key_buff1" "2816"
 $ : chr [1:2] "key_buff1" "2816"
 $ : chr [1:2] "key_buff1" "2816"
 $ : chr [1:2] "key_buff1" "2816"
 $ : chr [1:2] "key_buff1" "2816"
 $ : chr [1:2] "key_buff1" "2816"
 $ : chr [1:2] "key_buff1" "2816"
 $ : chr [1:2] "key_buff1" "2816"
 $ : chr [1:2] "key_buff1" "2816"
 $ : chr [1:2] "key_buff1" "2816"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "8192"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "6912"
 $ : chr [1:2] "key_buff1" "11008"
 $ : chr [1:2] "key_buff1" "11008"
 $ : chr [1:2] "key_buff1" "11008"
 $ : chr [1:2] "key_buff1" "11008"
 $ : chr [1:2] "key_buff1" "11008"
 $ : chr [1:2] "key_buff1" "11008"
 $ : chr [1:2] "key_buff1" "11008"
 $ : chr [1:2] "key_buff1" "11008"
 $ : chr [1:2] "key_buff1" "11008"
 $ : chr [1:2] "key_buff1" "11008"
 $ : chr [1:2] "key_buff1" "11008"
 $ : chr [1:2] "key_buff1" "11008"
 $ : chr [1:2] "key_buff1" "11008"
 $ : chr [1:2] "key_buff1" "11008"
 $ : chr [1:2] "key_buff1" "16384"
 $ : chr [1:2] "key_buff1" "16384"
 $ : chr [1:2] "key_buff1" "16384"
 $ : chr [1:2] "key_buff1" "16384"
 $ : chr [1:2] "key_buff1" "16384"
 $ : chr [1:2] "key_buff1" "16384"
 $ : chr [1:2] "key_buff1" "16384"
 $ : chr [1:2] "key_buff1" "16384"
 $ : chr [1:2] "key_buff1" "16384"
 $ : chr [1:2] "key_buff1" "16384"
 $ : chr [1:2] "key_buff1" "16384"
 $ : chr [1:2] "key_buff1" "16384"
 $ : chr [1:2] "key_buff1" "16384"
 $ : chr [1:2] "key_buff1" "15104"
 $ : chr [1:2] "key_buff1" "15104"
 $ : chr [1:2] "key_buff1" "19200"
 $ : chr [1:2] "key_buff1" "19200"
 $ : chr [1:2] "key_buff1" "19200"
 $ : chr [1:2] "key_buff1" "19200"
 $ : chr [1:2] "key_buff1" "19200"
 $ : chr [1:2] "key_buff1" "19200"
 $ : chr [1:2] "key_buff1" "19200"
  [list output truncated]
   user  system elapsed 
  0.552   0.000   0.550
   user  system elapsed 
  0.660   0.000   0.661 
Warning message:
In system.time(n$Offset <- as.integer(unlist(lapply(vect, "[[",  :
  NAs introduced by coercion
'data.frame':	1150520 obs. of  11 variables:
 $ Address  :Class 'bigz'  raw [1:13806244] 38 8e 11 00 ...
 $ Reads    : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Start    : int  279630 310398 452318 485572 511748 511748 521080 522640 522640 538401 ...
 $ End      : int  283344 410993 485570 511748 521080 521080 522640 538401 538401 578774 ...
 $ Tid      : int  7 6 6 6 6 0 0 0 6 6 ...
 $ N        : int  1 1 1 1 2 2 1 2 2 1 ...
 $ Duration : int  3714 100595 33252 26176 9332 9332 1560 15761 15761 40373 ...
 $ Type     : chr  "Private_Write" "Private_Write" "Private_Write" "Private_Write" ...
 $ Structure: chr  "key_buff1" "key_buff1" "key_buff1" "key_buff1" ...
 $ Offset   : int  2816 2816 2816 2816 2816 2816 2816 2816 2816 2816 ...
   Address Reads Writes  Start    End Tid N Duration          Type Structure
80 6307840     1      1 279630 283344   7 1     3714 Private_Write key_buff1
81 6307840     1      1 310398 410993   6 1   100595 Private_Write key_buff1
82 6307840     1      1 452318 485570   6 1    33252 Private_Write key_buff1
83 6307840     1      1 485572 511748   6 1    26176 Private_Write key_buff1
84 6307840     1      1 511748 521080   6 2     9332  Shared_Write key_buff1
85 6307840     1      1 511748 521080   0 2     9332  Shared_Write key_buff1
   Offset
80   2816
81   2816
82   2816
83   2816
84   2816
85   2816
[1] 1150520
#+end_example

Ok fast enough for me, I guess this is it, let's aggregate and do the plots:

#+begin_src R :results output :session :exports both
system.time(o <- aggregate(n[,c('Reads','Writes', 'N')],n[,c('Structure','Offset', 'Type', 'Start', 'End')], function(d) sum(d)));
str(o)
head(o)
#+end_src

#+RESULTS:
#+begin_example
   user  system elapsed 
 64.948   0.132  65.145
'data.frame':	1078075 obs. of  8 variables:
 $ Structure: chr  "key_array" "key_array" "key_array" "key_buff1" ...
 $ Offset   : int  83884800 2816 6912 981472 1014168 1019864 1025192 1027256 1034226 1035544 ...
 $ Type     : chr  "Private_Write" "Private_Write" "Private_Write" "Private_Write" ...
 $ Start    : int  157 1 1 1 1 1 1 1 1 1 ...
 $ End      : int  158 171 171 171 171 171 171 171 171 171 ...
 $ Reads    : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ N        : int  1 1 1 1 1 1 1 1 1 1 ...
  Structure   Offset          Type Start End Reads Writes N
1 key_array 83884800 Private_Write   157 158     1      1 1
2 key_array     2816 Private_Write     1 171     1      1 1
3 key_array     6912 Private_Write     1 171     1      1 1
4 key_buff1   981472 Private_Write     1 171     1      1 1
5 key_buff1  1014168 Private_Write     1 171     1      1 1
6 key_buff1  1019864 Private_Write     1 171     1      1 1
#+end_example

This step is a bit slow, but I dont now how to make it go faster, so
for now let keep it this way.

So now we should be able to redo the plots from [[*2016-03-03%20Redo%20analysis%20from%20%5B%5B*IS%5D%5BIS%5D%5D%20with%20addresses%20fixed][last thursday]] 

#+begin_src R :results output graphics :file img/intensity_Rw_is_B_fixy_replay.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(o) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Offset,yend=Offset, color=Reads+Writes)) +
  facet_grid(Structure~Type, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_Rw_is_B_fixy_replay.png]]


this is the same as:

[[file:img/intensity_Rw_is_B_fixy.png][file:~/Work/labbook-lucas/img/intensity_Rw_is_B_fixy.png]]


So our improvements work, there is the whole post processing phase as
one block:


#+begin_src R :results output :session :exports both
ptm <- proc.time()
library(gmp)


system.time(k <- read.csv("Moca-is.B-orig-2016-03-01_14-03-40/Moca-framesoc.csv", header=T));
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

# Use bigz to parse
k$Address <- as.bigz(paste("0x", k$Address, sep=""))
k$Phy <- NULL;
k$CPU <- NULL;
k$Duration <- k$End - k$Start
head(k);
str(k)

# Add structure info
structs <- read.csv("Moca-is.B-orig-2016-03-01_14-03-40/is.B-orig.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressStart <- as.bigz(structs$AddressStart)
structs$AddressSize <- as.bigz(structs$AddressSize)
structs$AddressEnd <- structs$AddressStart + structs$AddressSize


# Filter interesting data structure as soon as possible
# The following line is specific to IS.B, adapt it for other analysis
structs <- structs[grepl("key_",structs$Structure),]
str(structs)
show(structs)

# Retrieve struct infos
nrow(k)
# These lines are specific to IS.B, adapt it for other analysis
minA <- structs[1,2]
maxA <- structs[3,4]
system.time(l <- subset(k, k$Address >= minA & k$Address <= maxA));
head(l)
str(l)

# Compute accesses type

m <- l
system.time(m$aType <- ifelse(m$Write >0,"Write", "Read"));
system.time(m$sType <- ifelse(m$N > 1,"Shared","Private"));
system.time(m$Type <- paste(m$sType,m$aType,sep="_"));
m$sType <- NULL
m$aType <- NULL
head(m)

# Compute data structure name and offset
n <- m
show(structs)
getStructReverse <- function (vect){
  name <- 1
  start <- 2
  end <- 4
  return (ifelse(n$Address >= vect[start] & n$Address <= vect[end],
                paste(vect[name],as.bigz(n$Address) - as.bigz(vect[start]),sep="@"),""));
}
system.time(ans <- as.data.frame(apply(structs,1,getStructReverse)))
system.time(vect <- apply(ans,1,paste,collapse=""));
#str(vect)
system.time(vect <- strsplit(vect,"@"))
#str(vect)
system.time(n$Structure <- unlist(lapply(vect,"[[",1)))
system.time(n$Offset <- as.integer(unlist(lapply(vect,"[[",2))));
#str(n)
head(n)
nrow(n)

# Aggregate
system.time(o <- aggregate(n[,c('Reads','Writes', 'N')],n[,c('Structure','Offset', 'Type', 'Start', 'End')], function(d) sum(d)));
str(o)
head(o)

proc.time() - ptm
#+end_src

#+RESULTS:
#+begin_example
   user  system elapsed 
  6.212   0.044   6.283
            X.Virt            X.Phy Nreads Nwrites CPUMask  Start    End TaskId
1 0000000000400040 000062000b1dfa80      1       0    1011      1    171      0
2 00000000004002a8 000062000b1dfa80      1       0    1011  32663  34153      0
3 0000000000400bd4 000062000b1dfa80      1       0    1011  55271  72678      0
4 00000000004009a0 000062000b1dfa80      1       0      11  88569  88776      1
5 00000000004009a0 000062000b1dfa80      1       0     111  92562 103554      7
6 00000000004009a0 000062000b1dfa80      1       0   10011 238634 245102      2
  Shared
1      1
2      1
3      1
4      1
5      1
6      1
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
  Address Reads Writes  Start    End Tid N Duration
1 4194368     1      0      1    171   0 1      170
2 4194984     1      0  32663  34153   0 1     1490
3 4197332     1      0  55271  72678   0 1    17407
4 4196768     1      0  88569  88776   1 1      207
5 4196768     1      0  92562 103554   7 1    10992
6 4196768     1      0 238634 245102   2 1     6468
'data.frame':	1157330 obs. of  8 variables:
 $ Address :Class 'bigz'  raw [1:13892924] d2 a8 11 00 ...
 $ Reads   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes  : int  0 0 0 0 0 0 0 0 0 0 ...
 $ Start   : int  1 32663 55271 88569 92562 238634 254421 258859 258859 286485 ...
 $ End     : int  171 34153 72678 88776 103554 245102 258859 286485 286485 310331 ...
 $ Tid     : int  0 0 0 1 7 2 4 4 6 6 ...
 $ N       : int  1 1 1 1 1 1 1 2 2 1 ...
 $ Duration: int  170 1490 17407 207 10992 6468 4438 27626 27626 23846 ...
'data.frame':	3 obs. of  4 variables:
 $ Structure   : Factor w/ 14 levels "__GI___pthread_keys",..: 3 2 4
 $ AddressStart:Class 'bigz'  raw [1:40] 03 00 00 00 ...
 $ AddressSize :Class 'bigz'  raw [1:40] 03 00 00 00 ...
 $ AddressEnd  :Class 'bigz'  raw [1:40] 03 00 00 00 ...
  Structure AddressStart AddressSize AddressEnd
3 key_buff1      6305024     8388608   14693632
4 key_array     14693632   134217728  148911360
5 key_buff2    148911360   134217728  283129088
[1] 1157330
   user  system elapsed 
  2.644   0.000   2.642
   Address Reads Writes  Start    End Tid N Duration
80 6307840     1      1 279630 283344   7 1     3714
81 6307840     1      1 310398 410993   6 1   100595
82 6307840     1      1 452318 485570   6 1    33252
83 6307840     1      1 485572 511748   6 1    26176
84 6307840     1      1 511748 521080   6 2     9332
85 6307840     1      1 511748 521080   0 2     9332
'data.frame':	1150520 obs. of  8 variables:
 $ Address :Class 'bigz'  raw [1:13806244] 38 8e 11 00 ...
 $ Reads   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes  : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Start   : int  279630 310398 452318 485572 511748 511748 521080 522640 522640 538401 ...
 $ End     : int  283344 410993 485570 511748 521080 521080 522640 538401 538401 578774 ...
 $ Tid     : int  7 6 6 6 6 0 0 0 6 6 ...
 $ N       : int  1 1 1 1 2 2 1 2 2 1 ...
 $ Duration: int  3714 100595 33252 26176 9332 9332 1560 15761 15761 40373 ...
   user  system elapsed 
  0.364   0.004   0.368
   user  system elapsed 
  0.364   0.000   0.367
   user  system elapsed 
   0.24    0.00    0.24
   Address Reads Writes  Start    End Tid N Duration          Type
80 6307840     1      1 279630 283344   7 1     3714 Private_Write
81 6307840     1      1 310398 410993   6 1   100595 Private_Write
82 6307840     1      1 452318 485570   6 1    33252 Private_Write
83 6307840     1      1 485572 511748   6 1    26176 Private_Write
84 6307840     1      1 511748 521080   6 2     9332  Shared_Write
85 6307840     1      1 511748 521080   0 2     9332  Shared_Write
  Structure AddressStart AddressSize AddressEnd
3 key_buff1      6305024     8388608   14693632
4 key_array     14693632   134217728  148911360
5 key_buff2    148911360   134217728  283129088
   user  system elapsed 
 11.496   0.024  11.528
   user  system elapsed 
  5.236   0.040   5.277
   user  system elapsed 
  1.924   0.004   1.930
   user  system elapsed 
  0.512   0.000   0.513
   user  system elapsed 
  0.656   0.000   0.656 
Warning message:
In system.time(n$Offset <- as.integer(unlist(lapply(vect, "[[",  :
  NAs introduced by coercion
   Address Reads Writes  Start    End Tid N Duration          Type Structure
80 6307840     1      1 279630 283344   7 1     3714 Private_Write key_buff1
81 6307840     1      1 310398 410993   6 1   100595 Private_Write key_buff1
82 6307840     1      1 452318 485570   6 1    33252 Private_Write key_buff1
83 6307840     1      1 485572 511748   6 1    26176 Private_Write key_buff1
84 6307840     1      1 511748 521080   6 2     9332  Shared_Write key_buff1
85 6307840     1      1 511748 521080   0 2     9332  Shared_Write key_buff1
   Offset
80   2816
81   2816
82   2816
83   2816
84   2816
85   2816
[1] 1150520
   user  system elapsed 
 63.424   0.156  63.705
'data.frame':	1078075 obs. of  8 variables:
 $ Structure: chr  "key_array" "key_array" "key_array" "key_buff1" ...
 $ Offset   : int  83884800 2816 6912 981472 1014168 1019864 1025192 1027256 1034226 1035544 ...
 $ Type     : chr  "Private_Write" "Private_Write" "Private_Write" "Private_Write" ...
 $ Start    : int  157 1 1 1 1 1 1 1 1 1 ...
 $ End      : int  158 171 171 171 171 171 171 171 171 171 ...
 $ Reads    : int  1 1 1 1 1 1 1 1 1 1 ...
 $ Writes   : int  1 1 1 1 1 1 1 1 1 1 ...
 $ N        : int  1 1 1 1 1 1 1 1 1 1 ...
  Structure   Offset          Type Start End Reads Writes N
1 key_array 83884800 Private_Write   157 158     1      1 1
2 key_array     2816 Private_Write     1 171     1      1 1
3 key_array     6912 Private_Write     1 171     1      1 1
4 key_buff1   981472 Private_Write     1 171     1      1 1
5 key_buff1  1014168 Private_Write     1 171     1      1 1
6 key_buff1  1019864 Private_Write     1 171     1      1 1
   user  system elapsed 
100.220   0.296 107.203
#+end_example

So the whole process is almost 3 times faster than the slowest step of
the previous version. I think we can still improve it but I don't know
how ... Also a process that takes less than 2 minutes is reasably slow
from my point of view.
