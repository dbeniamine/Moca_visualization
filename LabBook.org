#+TITLE: Beniamine's LabBook
#+AUTHOR: Beniamine
#+LATEX_HEADER: \usepackage[margin=2cm,a4paper]{geometry}
#+STARTUP: overview indent
#+TAGS: Lucas(L) David(D) noexport(n) deprecated(d)
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+SEQ_TODO: TODO(t!) STARTED(s!) WAITING(w!) | DONE(d!) CANCELLED(c!) DEFERRED(f!)

* 2016-02-17 Memory access along time (from MOCA)

David's traces have only variables. We should look to them as states.

So convert accordingly:

#+begin_src bash :results output :session :exports both
grep ^Variable Moca_matrix_bloc_20160217_Virt.pjdump | 
   awk -F, '{print "State,"$2",access,"$4","$5","$6",0,"$3}' > states_Virt.csv
grep ^Variable Moca_matrix_bloc_20160217_Phy.pjdump | 
   awk -F, '{print "State,"$2",access,"$4","$5","$6",0,"$3}' > states_Phy.csv
#+END_SRC

#+RESULTS:

Great, now let's load them into R.

#+begin_src R :results output :session :exports both
read_paje_trace <- function(file) {
  df <- read.csv(file, header=FALSE, strip.white=TRUE)
  names(df) <- c("Nature","ResourceId","Type","Start","End","Duration", "Depth", "Value")
  df$Origin=file
  m <- min(df$Start)
  df$Start <- df$Start - m
  df$End <- df$Start+df$Duration
  df$Origin <- NULL
  df$Nature <- NULL
  df$Depth <- NULL
  df
}
df_Virt <- read_paje_trace("states_Virt.csv");
df_Phy <- read_paje_trace("states_Phy.csv");
#+end_src

#+RESULTS:

#+begin_src R :results output :session :exports both
nrow(df_Virt);
nrow(df_Phy);
#+end_src

#+RESULTS:
: [1] 4478461
: [1] 4472513

The largest dataframes I have ever seen.

Let's play with care.

#+begin_src R :results output graphics :file (org-babel-temp-file "figure" ".png") :exports both :width 600 :height 400 :session
library(ggplot2);
df <- df_Virt;
df <- df[df$ResourceId == 140737310789152, ];
p <- ggplot(df) +
  theme_bw() +
  geom_segment(size=15, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId), color="black") +
  geom_segment(size=13, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value)) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[file:/tmp/babel-9357QOL/figure9357w0Z.png]]


Strange. Let's see how many *Shared_read* there are.

#+begin_src R :results output :session :exports both
nrow(df[df$Value == "Private_Read" & df$Start < 200000 & df$Start > 150000,]);
nrow(df[df$Value == "Shared_Read" & df$Start < 180000 & df$Start > 210000,]);
df[df$Start > 180000 & df$Start < 210000,]
#+end_src

#+RESULTS:
: [1] 0
: [1] 0
:          ResourceId   Type  Start    End Duration       Value
: 289172 1.407373e+14 access 189573 221868    32295 Shared_Read
: 289173 1.407373e+14 access 189573 221868    32295 Shared_Read
: 289174 1.407373e+14 access 189573 221868    32295 Shared_Read
: 289175 1.407373e+14 access 189573 221868    32295 Shared_Read

Lot's of them for this particular address. Let's zoom in.

#+begin_src R :results output graphics :file img/virt_first_try_2.png :exports both :width 600 :height 400 :session
library(ggplot2);
df <- df_Virt;
df <- df;
p <- ggplot(df) +
  theme_bw() +
  geom_segment(size=13, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value), alpha=.4) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[file:img/first_try_2.png]]



#+begin_src R :results output graphics :file img/phy_first_try_1.png :exports both :width 600 :height 400 :session
library(ggplot2);
df <- df_Phy;
df <- df;
p <- ggplot(df) +
  theme_bw() +
  geom_segment(size=13, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value), alpha=.4) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[file:img/phy_first_try_1.png]]


* 2016-02-17 Calculating intensity

_First Attempt_

I'll try with bash.

#+begin_src bash :results output :session :exports both
cat states_Virt.csv  | grep Shared_Read > states_Virt_shared_read.csv
cat states_Virt_shared_read.csv | cut -d, -f2 | sort | uniq > add_Virt
cat states_Virt_shared_read.csv  | cut -d, -f4-6 | sort | uniq  > timeslices

cat states_Virt_shared_read.csv  | cut -d, -f2,4,5,8 > states_Virt_shared_read_essential.csv
cat states_Virt_shared_read_essential.csv  | sort | uniq  > states_Virt_shared_read_essential_unique.csv
while read line ; do echo -n "$line,"; cat states_Virt_shared_read_essential.csv | grep "$line" | wc -l; done < states_Virt_shared_read_essential_unique.csv > states_Virt_shared_read_essential_unique_with_intensity.csv
#+end_src

Done. Just check the file:
+ =states_Virt_shared_read_essential_unique_with_intensity.csv=
You can load with R and play with it.

_Second Attempt_

Actually, I believe I can do it faster and cleaner with R.

#+begin_src R :results output :session :exports both
library(plyr);
k <- read.csv("states_Virt_shared_read.csv", header=FALSE);
options("scipen"=100, "digits"=4);
head(k);
#+end_src

#+RESULTS:
:      V1              V2     V3 V4   V5   V6 V7          V8
: 1 State 140737351871824 access  1 4396 4395  0 Shared_Read
: 2 State 140737351871976 access  1 4396 4395  0 Shared_Read
: 3 State 140737347542408 access  1 4396 4395  0 Shared_Read
: 4 State 140737347542640 access  1 4396 4395  0 Shared_Read
: 5 State 140737488351205 access  1 4396 4395  0 Shared_Read
: 6 State 140737488350713 access  1 4396 4395  0 Shared_Read

#+begin_src R :results output :session :exports both
sapply(k, class);
#+end_src

#+RESULTS:
:        V1        V2        V3        V4        V5        V6        V7        V8 
:  "factor" "numeric"  "factor" "integer" "integer" "integer" "integer"  "factor"

#+begin_src R :results output :session :exports both
names(k) <- c("Nature", "Address", "Type", "Start", "End", "Duration", "Imbric", "Value");
k$Nature <- NULL;
k$Type <- NULL;
k$Imbric <- NULL;
head(k);
#+end_src

#+RESULTS:
:           Address Start  End Duration       Value
: 1 140737351871824     1 4396     4395 Shared_Read
: 2 140737351871976     1 4396     4395 Shared_Read
: 3 140737347542408     1 4396     4395 Shared_Read
: 4 140737347542640     1 4396     4395 Shared_Read
: 5 140737488351205     1 4396     4395 Shared_Read
: 6 140737488350713     1 4396     4395 Shared_Read

#+begin_src R :results output :session :exports both
sapply(k, class);
#+end_src

#+RESULTS:
:   Address     Start       End  Duration     Value 
: "numeric" "integer" "integer" "integer"  "factor"

Do the magic. This command takes time.

#+begin_src R :results output :session :exports both
library(plyr);
g <- ddply(k, .(Address, Start, End, Duration, Value), summarize, N=length(Value));
head(g);
#+end_src

#+RESULTS:
:        Address Start  End Duration       Value N
: 1 1.407374e+14     1 4396     4395 Shared_Read 1
: 2 1.407374e+14     1 4396     4395 Shared_Read 1
: 3 1.407373e+14     1 4396     4395 Shared_Read 1
: 4 1.407373e+14     1 4396     4395 Shared_Read 1
: 5 1.407375e+14     1 4396     4395 Shared_Read 1
: 6 1.407375e+14     1 4396     4395 Shared_Read 1

#+begin_src R :results output :session :exports both
head(g);
sapply(g, class);
#+end_src

#+RESULTS:
:           Address Start  End Duration       Value N
: 1 140737351871824     1 4396     4395 Shared_Read 1
: 2 140737351871976     1 4396     4395 Shared_Read 1
: 3 140737347542408     1 4396     4395 Shared_Read 1
: 4 140737347542640     1 4396     4395 Shared_Read 1
: 5 140737488351205     1 4396     4395 Shared_Read 1
: 6 140737488350713     1 4396     4395 Shared_Read 1
:   Address     Start       End  Duration     Value         N 
: "numeric" "integer" "integer" "integer"  "factor" "integer"

#+begin_src R :results output :session :exports both
summary(g$N);
#+end_src

#+RESULTS:
:    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
:   1.000   2.000   3.000   3.421   5.000   8.000

#+begin_src R :results output :session :exports both
#head(g[g$Address == 140737308215152,]);
head(g[g$Address == 140737312395264,]);
median(g[g$Address > 7000000,]$Address);
#tail(g);
#+end_src

#+RESULTS:
:               Address  Start    End Duration       Value N
: 17014 140737312395264  28278  67005    38727 Shared_Read 3
: 22805 140737312395264  54041  77448    23407 Shared_Read 2
: 30183 140737312395264  67009 126332    59323 Shared_Read 3
: 33031 140737312395264  77453  90227    12774 Shared_Read 2
: 36721 140737312395264  90243 137116    46873 Shared_Read 2
: 50336 140737312395264 126336 171611    45275 Shared_Read 5
: [1] 140737314631680

#+begin_src R :results output graphics :file img/intensity_1_up.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(g[g$Address > 6304416,]) +
  theme_bw() +
  geom_segment(size=7, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_wrap(~Value, ncol=1);# + ylim(139000000000000, NA);
p
#+end_src

#+RESULTS:
[[file:img/intensity_1_up.png]]

I just can't find out the best Y scale. Let's create a histogram of
these addresses.

#+begin_src R :results output :session :exports both
h <- g[g$Address > 7304416,];
h$Address = h$Address - 140737000000000;
head(h);
#+end_src

#+RESULTS:
:     Address Start  End Duration       Value N
: 1 351871824     1 4396     4395 Shared_Read 1
: 2 351871976     1 4396     4395 Shared_Read 1
: 3 347542408     1 4396     4395 Shared_Read 1
: 4 347542640     1 4396     4395 Shared_Read 1
: 5 488351205     1 4396     4395 Shared_Read 1
: 6 488350713     1 4396     4395 Shared_Read 1

#+begin_src R :results output graphics :file img/address_histogram.png :exports both :width 600 :height 400 :session
ggplot(h, aes(Address)) + xlim(300000000, 330000000) + geom_histogram();
#+end_src

#+RESULTS:
[[file:img/address_histogram.png]]

Okay, let's try again.

#+begin_src R :results output graphics :file img/intensity_2.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(h) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_wrap(~Value, ncol=1);# + ylim(300000000, 330000000)
p
#+end_src

#+RESULTS:
[[file:img/intensity_2.png]]


Not that good, need further filtering:

#+begin_src R :results output :session :exports both
summary(h$Address);
#+end_src

#+RESULTS:
:      Min.   1st Qu.    Median      Mean   3rd Qu.      Max. 
: 271000000 310000000 315000000 315000000 319000000 488000000

Let's get only addresses from the 1st to the 3rd Qu.

#+begin_src R :results output graphics :file img/intensity_3.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(h) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_wrap(~Value, ncol=1) + ylim(310000000, 319000000)
p
#+end_src

#+RESULTS:
[[file:img/intensity_3.png]]

Finally. Let's reduce size.

#+begin_src R :results output graphics :file img/intensity_4.png :exports both :width 600 :height 800 :session
library(ggplot2);
p <- ggplot(h) +
  theme_bw() +
  geom_segment(size=0.2, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_wrap(~Value, ncol=1) + ylim(310000000, 319000000)
p
#+end_src

#+RESULTS:
[[file:img/intensity_4.png]]


#+begin_src R :results output graphics :file img/intensity_5.png :exports both :width 600 :height 2000 :session
library(ggplot2);
p <- ggplot(h) +
  theme_bw() +
  geom_segment(size=0.2, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_wrap(~Value, ncol=1) + ylim(310000000, 319000000)
p
#+end_src

#+RESULTS:
[[file:img/intensity_5.png]]

#+begin_src R :results output graphics :file img/intensity_6.png :exports both :width 600 :height 2000 :session
library(ggplot2);
p <- ggplot(h) +
  theme_bw() +
  geom_segment(size=0.5, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_wrap(~Value, ncol=1) + ylim(310000000, 311000000)
p
#+end_src

#+RESULTS:
[[file:img/intensity_6.png]]

** Old Stuff                                                    :deprecated:

Let's make rows unique, since now we have the intensity.

#+begin_src R :results output :session :exports both
h <- unique(g);
#+end_src

#+RESULTS:

#+begin_src R :results output :session :exports both
head(h);
#+end_src

#+RESULTS:
:        Address Start  End Duration       Value N
: 1 1.407374e+14     1 4396     4395 Shared_Read 1
: 2 1.407374e+14     1 4396     4395 Shared_Read 1
: 3 1.407373e+14     1 4396     4395 Shared_Read 1
: 4 1.407373e+14     1 4396     4395 Shared_Read 1
: 5 1.407375e+14     1 4396     4395 Shared_Read 1
: 6 1.407375e+14     1 4396     4395 Shared_Read 1

#+begin_src R :results output graphics :file (org-babel-temp-file "figure" ".png") :exports both :width 600 :height 400 :session
ggplot(h, aes(x=Start, y=N)) + geom_point();
#+end_src

#+RESULTS:
[[file:/tmp/babel-9357QOL/figure9357x8U.png]]

* 2016-02-23 New traces

I got a new tarbal from David, here's its MD5 signature.

#+begin_src sh :results output :session :exports both
md5sum ../Moca-matrix.tgz
#+end_src

#+RESULTS:
: 7a81360ff13bcdd0cb3dc23e5b006805  ../Moca-matrix.tgz

Extracting the data in the =v2= directory.

#+begin_src sh :results output :session :exports both
mkdir -p v2; cd v2; tar xfz ../../Moca-matrix.tgz; mv Moca-matrix-bloc/* .; rm -rf Moca-matrix-bloc;
#+end_src

#+RESULTS:

List contents:

#+begin_src sh :results output :session :exports both
pwd
ls -hl v2
#+end_src

#+RESULTS:
: /home/schnorr/TRACES/david/Moca-matrix-bloc
: total 1.1G
: -rw-r--r-- 1 schnorr schnorr  126 Feb 17 10:54 matrix.stackmap.csv
: -rw-r--r-- 1 schnorr schnorr  331 Feb 17 10:54 matrix.structs.csv
: -rw-r--r-- 1 schnorr schnorr 317M Feb 18 13:31 Moca-framesoc.csv
: -rw-r--r-- 1 schnorr schnorr  94M Feb 17 10:54 Moca-full-trace.csv
: -rw-r--r-- 1 schnorr schnorr 351M Feb 18 14:01 Moca_matrix_bloc_20160218Virt.pjdump
: -rw-r--r-- 1 schnorr schnorr 301M Feb 18 14:31 states

Great, now we are ready to start again.

* 2016-02-23 Playing with new traces

It looks like I only get virtual mem addresses this time. Okay.

#+begin_src sh :results output :session :exports both
cd v2
grep ^Variable Moca_matrix_bloc_20160218Virt.pjdump | 
   awk -F, '{print "State,"$2",access,"$4","$5","$6",0,"$3}' > states_Virt.csv
#+end_src

#+RESULTS:

I have noticed that some durations are negative. See:

#+begin_src sh :results output :session :exports both
cd v2
cat states_Virt.csv | grep "-" | head
#+end_src

#+RESULTS:
#+begin_example
State,140737305567232,access,17863,17762,-101,0,Shared_Read
State,140737305567232,access,17863,17762,-101,0,Shared_Read
State,140737305569152,access,17863,17762,-101,0,Shared_Read
State,140737305599152,access,17863,17762,-101,0,Shared_Read
State,140737305599152,access,17863,17762,-101,0,Shared_Read
State,140737305595904,access,17863,17762,-101,0,Shared_Read
State,140737305611152,access,17863,17762,-101,0,Shared_Read
State,140737305608192,access,17863,17762,-101,0,Shared_Read
State,140737305623152,access,17863,17762,-101,0,Shared_Read
State,140737305623152,access,17863,17762,-101,0,Shared_Read
#+end_example

_Summary_:
- Negative durations (probably an error)

* 2016-02-23 Removing durations with negative values                  :Lucas:

Okay, let's proceed anyway, removing the problem.

#+begin_src sh :results output :session :exports both
cd v2
cat states_Virt.csv | grep -v "-" > states_Virt_without_neg_durations.csv
#+end_src

#+RESULTS:

Great, now let's load it.

#+begin_src R :results output :session :exports both
read_paje_trace <- function(file) {
  df <- read.csv(file, header=FALSE, strip.white=TRUE)
  names(df) <- c("Nature","ResourceId","Type","Start","End","Duration", "Depth", "Value")
  df$Origin=file
  m <- min(df$Start)
  df$Start <- df$Start - m
  df$End <- df$Start+df$Duration
  df$Origin <- NULL
  df$Nature <- NULL
  df$Depth <- NULL
  df
}
df_Virt <- read_paje_trace("v2/states_Virt_without_neg_durations.csv");
#+end_src

#+RESULTS:

#+begin_src R :results output :session :exports both
df <- df_Virt;
df$Type <- NULL;
head(df);
#+end_src

#+RESULTS:
:   ResourceId Start  End Duration         Value
: 1    4656816     0 4395     4395  Private_Read
: 2    6303348     0 4395     4395  Private_Read
: 3    6303348     0 4395     4395 Private_Write
: 4    6303752     0 4395     4395  Private_Read
: 5    6303752     0 4395     4395 Private_Write
: 6    7330440     0 4395     4395  Private_Read

#+begin_src R :results output graphics :file img/Moca_matrix_bloc_20160218Virt_overview.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(df) +
  theme_bw() +
  geom_segment(size=13, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value), alpha=.4) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[./img/Moca_matrix_bloc_20160218Virt_overview.png]]

Let's remove =Shared_Write= and =Private_Write=.

#+begin_src R :results output graphics :file img/Moca_matrix_bloc_20160218Virt_filter_1.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(df[df$Value != "Private_Write" & df$Value != "Shared_Write",]) +
  theme_bw() +
  geom_segment(size=13, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value), alpha=.4) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[file:img/Moca_matrix_bloc_20160218Virt_filter_1.png]]

Let's zoom in to the beginning, reduce segment size:

#+begin_src R :results output graphics :file img/Moca_matrix_bloc_20160218Virt_filter_2.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(df[df$Value != "Private_Write" & df$Value != "Shared_Write",]) +
  theme_bw() +
  geom_segment(size=1, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value), alpha=.4) +
  facet_wrap(~Value, ncol=1) + xlim(0, 90243);
p
#+end_src

#+RESULTS:
[[file:img/Moca_matrix_bloc_20160218Virt_filter_2.png]]

That's strange the middle with nothing. The problem is this:

#+begin_src sh :results output :session :exports both
cat v2/states_Virt_without_neg_durations.csv | cut -d, -f2 | head -n30 | cat -n
#+end_src

#+RESULTS:
#+begin_example
     1	4656816
     2	6303348
     3	6303348
     4	6303752
     5	6303752
     6	7330440
     7	7330440
     8	7341840
     9	7341840
    10	8700368
    11	8700368
    12	8737104
    13	8737104
    14	8784688
    15	8784688
    16	8787648
    17	8787648
    18	8790320
    19	8790320
    20	140152691697344
    21	140152691777685
    22	140152691881456
    23	140152691913632
    24	140152692128528
    25	140152692183424
    26	140152692227168
    27	140152692306624
    28	140152692447204
    29	140152692585408
    30	140152692856576
#+end_example

The first 19 events have very low addresses. All other addresses are
much larger. That's why we have those blank spaces in the plot. We
should remove these low addresses. Sorting these events numerically
indicates that I should look only to addresses between 
140152691697344 and 
140737488351205.

#+begin_src R :results output :session :exports both
sapply(df, class);
#+end_src

#+RESULTS:
: ResourceId      Start        End   Duration      Value 
:  "numeric"  "integer"  "integer"  "integer"   "factor"

Great, we can filter easily.

#+begin_src R :results output graphics :file img/Moca_matrix_bloc_20160218Virt_filter_3.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(
  df[df$Value != "Private_Write" &
  df$Value != "Shared_Write" &
  df$ResourceId >= 140152691697344 &
  df$ResourceId <= 140737488351205,]) +
  theme_bw() +
  geom_segment(size=1, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value), alpha=.4) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[file:img/Moca_matrix_bloc_20160218Virt_filter_3.png]]

That didn't work. Let's create a histogram:


#+begin_src R :results output :session :exports both

#+end_src


#+begin_src R :results output graphics :file img/Moca_matrix_bloc_20160218Virt_ResourceId_histogram.png :exports both :width 600 :height 400 :session
ggplot(df, aes(ResourceId)) + geom_histogram() + theme_bw();
#+end_src

#+RESULTS:
[[file:img/Moca_matrix_bloc_20160218Virt_ResourceId_histogram.png]]

Okay, let's zoom in:


#+begin_src R :results output graphics :file img/Moca_matrix_bloc_20160218Virt_ResourceId_histogram_1.png :exports both :width 600 :height 400 :session
ggplot(df, aes(ResourceId)) + geom_histogram() + theme_bw() + xlim(1.4073e+14,NA);
#+end_src

#+RESULTS:
[[file:img/Moca_matrix_bloc_20160218Virt_ResourceId_histogram_1.png]]

Okay, limits should be =xlim(1.4073e+14,NA)=.

#+begin_src R :results output graphics :file img/Moca_matrix_bloc_20160218Virt_filter_4.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(
  df[df$Value != "Private_Write" &
  df$Value != "Shared_Write" &
  df$ResourceId >= 1.4073e+14,]) +
  theme_bw() +
  geom_segment(size=1, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value), alpha=.4) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[file:img/Moca_matrix_bloc_20160218Virt_filter_4.png]]


Now we are finally going somewhere. ResourceId filtering is essential.

Let's go on, limiting the upper bound.

#+begin_src R :results output graphics :file img/Moca_matrix_bloc_20160218Virt_filter_5.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(
  df[df$Value != "Private_Write" &
  df$Value != "Shared_Write" &
  df$ResourceId >= 1.4073e+14 &
  df$ResourceId <= 1.407374e+14,]) +
  theme_bw() +
  geom_segment(size=1, aes(x=Start,xend=End, y=ResourceId,yend=ResourceId, color=Value), alpha=.4) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[file:img/Moca_matrix_bloc_20160218Virt_filter_5.png]]

Great. I stop here for now.

The problem for me is to correctly define the Address bounds for the
visualization. Since MOCA dumps really every single memory address
accessed (no matter where), and we don't know which part we should
look for, the prototype should allow an easy search methodology in the
address space (pretty much following what I have done above, but
automatically). Then, and only then, plot things.


Some recomendations:
- filter by memory address in MOCA (if intrusion is acceptable)
- create a script to easily filter by memory address interval
  - automatic address interval selection should be possible

Future analysis methodology:
- I am using alpha values to draw segments, but I shouldn't.
  - Intensity should correlate with number of concurrent mem access.
  - So, a preprocessing of the trace do the magic
    - Take a look at [[*2016-02-17 Calculating intensity][2016-02-17 Calculating intensity]] to see how to
  - Then plot as usual after all this filtering stuff mentioned above

* 2016-02-24 Answers for questions of previous section                :David:
- The filtering on the address space can be done using the structs.csv and stackmaps.csv
that provides addresses, name and size of the various data structures
and stacks. 
In Ocelotl, I usually filter out all the addresses that are not in a
data structure at import time. Still it can be interesting to do it
during the preprocessing phase.
Sadly I realized yesterday that Pin (the tool that I am using to
record data structure addresses) was providing bad addresses, thus the
filter won't work this the trace version two.
This issue is not yet completly fixed but there is a trace with
manually fixed data structure addresses and with the address space
already reduced to data structures:
 https://ligcloud.imag.fr/public.php?service=files&t=13b4b28b657943bdf7c4d31d6a7a18ba
- The idea of Moca is to provide a trace as precise as possible, we don't know a priori what
we are looking for, thus I'd rather avoid filtering during tracing.
- The preprocessing can also be done when we detect sharing, currently when I dectect that
two threads are sharing a page, I create to different accesses. I
could create only one access to the page with a value of two. Still
with this reprensentation, we only now the address of the shared page
and loose the precise addresses of each accesses.

* 2016-02-25 New trace / Redo analysis / Try to be faster in filtering :Lucas:

I have been provided with a new trace.

#+begin_src sh :results output :session :exports both
md5sum matrix.tgz
#+end_src

#+RESULTS:
: 098f7ee5632a20cf82290737e89c3ad2  matrix.tgz

#+begin_src sh :results output :session :exports both
tar xfz matrix.tgz
#+end_src

#+RESULTS:

#+begin_src sh :results output :session :exports both
ls -1 Moca-matrix-bloc-fixaddr/
#+end_src

#+RESULTS:
: matrix.stackmap.csv
: matrix.structs.csv
: Moca-framesoc.csv
: Moca_matrix_bloc_fixaddr_20160222_144532_CET_Physical_6.pjdump
: Moca_matrix_bloc_fixaddr_20160223_172342_CET_Physical_6.pjdump
: Moca_matrix_bloc_fixaddr_20160223_172342_CET_Virtual_7.pjdump

David told me the file =matrix.structs.csv= has information about the
memory addresses of main data structures, the ones I should be looking
for. Here's the contents:

#+begin_src sh :results output :session :exports both
cat Moca-matrix-bloc-fixaddr/matrix.structs.csv
#+end_src

#+RESULTS:
: name,start,sz
: __GI___pthread_keys,2196192,16384
: __pthread_keys,2196192,16384
: UnnamedStruct#0,6303760,5280
: UnnamedStruct#1,6303888,32816
: UnnamedStruct#2,6303888,32816
: /tmp/matrix/matrix_naif.c:122,140737323565072,18000000
: /tmp/matrix/matrix_naif.c:123,140737305563152,18000000
: /tmp/matrix/matrix_naif.c:123,140737287561232,18000000

Great, let's focus our analysis below in addresses starting at
- 140737305563152 up to 140737305563152+18000000

First, convert to =states=, using bash.

#+begin_src sh :results output :session :exports both
UNIQFILE=Moca_matrix_bloc_fixaddr_20160223_172342_CET_Virtual_7
cat Moca-matrix-bloc-fixaddr/${UNIQFILE}.pjdump | grep ^Variable |
   awk -F, '{print "State,"$2",access,"$4","$5","$6",0,"$3}' > ${UNIQFILE}-states.csv
#+end_src

#+RESULTS:

Now, calculate intensity as in:
- [[*2016-02-17 Calculating intensity][2016-02-17 Calculating intensity]]

#+begin_src R :results output :session :exports both
k <- read.csv("Moca_matrix_bloc_fixaddr_20160223_172342_CET_Virtual_7-states.csv", header=FALSE);
options("scipen"=100, "digits"=4);
head(k);
#+end_src

#+RESULTS:
:      V1      V2     V3 V4   V5   V6 V7            V8
: 1 State 4656816 access  1 4399 4398  0  Private_Read
: 2 State 6303500 access  1 4399 4398  0  Private_Read
: 3 State 6303500 access  1 4399 4398  0 Private_Write
: 4 State 6303752 access  1 4399 4398  0  Private_Read
: 5 State 6303752 access  1 4399 4398  0 Private_Write
: 6 State 7330440 access  1 4399 4398  0  Private_Read

#+begin_src R :results output :session :exports both
sapply(k, class);
#+end_src

#+RESULTS:
:        V1        V2        V3        V4        V5        V6        V7        V8 
:  "factor" "numeric"  "factor" "integer" "integer" "integer" "integer"  "factor"

#+begin_src R :results output :session :exports both
names(k) <- c("Nature", "Address", "Type", "Start", "End", "Duration", "Imbric", "Value");
k$Niature <- NULL;
k$Type <- NULL;
k$Imbric <- NULL;
head(k);
#+end_src

#+RESULTS:
:   Address Start  End Duration         Value
: 1 4656816     1 4399     4398  Private_Read
: 2 6303500     1 4399     4398  Private_Read
: 3 6303500     1 4399     4398 Private_Write
: 4 6303752     1 4399     4398  Private_Read
: 5 6303752     1 4399     4398 Private_Write
: 6 7330440     1 4399     4398  Private_Read

#+begin_src R :results output :session :exports both
sapply(k, class);
#+end_src

#+RESULTS:
:   Address     Start       End  Duration     Value 
: "numeric" "integer" "integer" "integer"  "factor"

Do the magic. This command takes time.

#+begin_src R :results output :session :exports both
library(plyr);
g <- ddply(k, .(Address, Start, End, Duration, Value), summarize, N=length(Value));
head(g);
#+end_src

*Attention*: I aborted the command above since I was waiting for too long.

Let's try again with dplyr.

#+begin_src R :results output :session :exports both
library(dplyr);
#+end_src

#+RESULTS:
#+begin_example

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union
#+end_example

See this introduction to _dplyr_ (specially tthe section on chaining):
https://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html

Okay, let's write new code:

#+begin_src R :results output :session :exports both
g <- k %>%
       group_by(Address, Start, End, Duration, Value) %>%
       summarize(N = length(Value));
#+end_src

#+RESULTS:

It was fast (I think around a minute in my machine).

#+begin_src R :results output :session :exports both
nrow(g);
head(g);
#+end_src

#+RESULTS:
#+begin_example
[1] 3368394
Source: local data frame [6 x 6]
Groups: Address, Start, End, Duration

  Address   Start     End Duration         Value N
1 4194928 1700510 1729918    29408  Private_Read 1
2 4197248   14887   17767     2880  Private_Read 1
3 4656816       1    4399     4398  Private_Read 1
4 6303496   14887   17767     2880  Private_Read 1
5 6303500       1    4399     4398  Private_Read 1
6 6303500       1    4399     4398 Private_Write 1
#+end_example

Filter out the space address:
- 140737305563152 up to 140737305563152+18000000

#+begin_src R :results output :session :exports both
head(g[g$Address >= 140737305563152 & g$Address <= 140737305563152+18000000,]);
#+end_src

#+RESULTS:
#+begin_example
Source: local data frame [6 x 6]
Groups: Address, Start, End, Duration

          Address Start   End Duration         Value N
1 140737305563152  4400  9932     5532  Private_Read 1
2 140737305563152  4400  9932     5532 Private_Write 1
3 140737305563152 17734 17757       23  Private_Read 1
4 140737305563152 17757 20391     2634   Shared_Read 2
5 140737305563152 20391 27232     6841  Private_Read 1
6 140737305563152 27232 32008     4776   Shared_Read 2
#+end_example

It worked, but it was a little slow. Let's also use =dplyr=.

#+begin_src R :results output :session :exports both
h <- g %>% filter(Address >= 140737305563152 & Address <= 140737305563152+18000000);
#+end_src

#+RESULTS:

My feeling is that it was slower.

#+begin_src R :results output :session :exports both
head(h);
#+end_src

#+RESULTS:
#+begin_example
Source: local data frame [6 x 6]
Groups: Address, Start, End, Duration

          Address Start   End Duration         Value N
1 140737305563152  4400  9932     5532  Private_Read 1
2 140737305563152  4400  9932     5532 Private_Write 1
3 140737305563152 17734 17757       23  Private_Read 1
4 140737305563152 17757 20391     2634   Shared_Read 2
5 140737305563152 20391 27232     6841  Private_Read 1
6 140737305563152 27232 32008     4776   Shared_Read 2
#+end_example

Let's plot the intensity of =h= anyway:


#+begin_src R :results output graphics :file img/intensity_fixaddr_v1.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(h) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_wrap(~Value, ncol=1);
p
#+end_src

#+RESULTS:
[[file:img/intensity_fixaddr_v1.png]]

That's precise.

* 2016-02-25 Merge access information with data structure information :Lucas:

Let's look to another data structure, ow, much better, let's change
our data frame to contain such information.

#+begin_src R :results output :session :exports both
head(g);
#+end_src

#+RESULTS:
#+begin_example
Source: local data frame [6 x 6]
Groups: Address, Start, End, Duration

  Address   Start     End Duration         Value N
1 4194928 1700510 1729918    29408  Private_Read 1
2 4197248   14887   17767     2880  Private_Read 1
3 4656816       1    4399     4398  Private_Read 1
4 6303496   14887   17767     2880  Private_Read 1
5 6303500       1    4399     4398  Private_Read 1
6 6303500       1    4399     4398 Private_Write 1
#+end_example

#+begin_src R :results output :session :exports both
structs <- read.csv("Moca-matrix-bloc-fixaddr/matrix.structs.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressEnd = structs$AddressStart + structs$AddressSize;

#+end_src

#+RESULTS:
:                       Structure    AddressStart AddressSize      AddressEnd
: 1           __GI___pthread_keys         2196192       16384         2212576
: 2                __pthread_keys         2196192       16384         2212576
: 3               UnnamedStruct#0         6303760        5280         6309040
: 4               UnnamedStruct#1         6303888       32816         6336704
: 5               UnnamedStruct#2         6303888       32816         6336704
: 6 /tmp/matrix/matrix_naif.c:122 140737323565072    18000000 140737341565072
: 7 /tmp/matrix/matrix_naif.c:123 140737305563152    18000000 140737323563152
: 8 /tmp/matrix/matrix_naif.c:123 140737287561232    18000000 140737305561232

I'll have to use =sqldf= I think.

#+begin_src R :results output :session :exports both
library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);
#+end_src

#+RESULTS:
#+begin_example
Loading required package: gsubfn
Loading required package: proto
Loading required package: RSQLite
Loading required package: DBI
 Loading required package: tcltk
  Address Start    End Duration        Value N       Structure
1 6304392  4400   9932     5532 Private_Read 1 UnnamedStruct#0
2 6304392  4400   9932     5532 Private_Read 1 UnnamedStruct#1
3 6304392  4400   9932     5532 Private_Read 1 UnnamedStruct#2
4 6304416 87595 101980    14385  Shared_Read 1 UnnamedStruct#0
5 6304416 87595 101980    14385  Shared_Read 1 UnnamedStruct#1
6 6304416 87595 101980    14385  Shared_Read 1 UnnamedStruct#2
#+end_example

Ow, that was fast.

Let's plot:

#+begin_src R :results output graphics :file img/intensity_fixaddr_with_structure_v1.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_wrap(~Value, ncol=1) + facet_wrap(~Structure,ncol=1) +
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_fixaddr_with_structure_v1.png]]

The Y axis should be independent. I should also use =facet_grid= to
different by access type. Ow, I just realized I made two =facet_wrap=.


#+begin_src R :results output graphics :file img/intensity_fixaddr_with_structure_v2.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=N)) +
  facet_grid(Structure~Value, scales="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_fixaddr_with_structure_v2.png]]

That's great.

Using color as factor.

#+begin_src R :results output graphics :file img/intensity_fixaddr_with_structure_v3.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scales="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_fixaddr_with_structure_v3.png]]


Strange. It is either one or two accesses only.

Is that normal for this application?

* 2016-02-25 Answer to questions of previous section                  :David:

The last image start to be quite interesting but there are several
issues:

** DONE Issue with visualization from file:img/intensity_fixaddr_with_structure_v2.png  [3/3]
- State "DONE"       from "STARTED"    [2016-02-26 Fri 13:40]
- State "STARTED"    from "TODO"       [2016-02-25 Thu 15:42]

*** DONE Number of writes
- State "DONE"       from "WAITING"    [2016-02-25 Thu 15:41]
- State "WAITING"    from "STARTED"    [2016-02-25 Thu 15:41]
- State "STARTED"    from "TODO"       [2016-02-25 Thu 15:41]
The visulisation contans only reads. Around a fourth of the accesses
should be writes. Where does this come from ?

Ok let see where does it comes from first, check that I'm working on
the same files than Lucas:

#+begin_src sh :results output :session :exports both
md5sum matrix.tgz
#+end_src

#+RESULTS:
: 098f7ee5632a20cf82290737e89c3ad2  matrix.tgz

seems to be the good ones, let's take a look

#+begin_src sh :results output :session :exports both
tar xvzf matrix.tgz
#+end_src

#+RESULTS:
: Moca-matrix-bloc-fixaddr/
: Moca-matrix-bloc-fixaddr/Moca_matrix_bloc_fixaddr_20160223_172342_CET_Virtual_7.pjdump
: Moca-matrix-bloc-fixaddr/Moca-framesoc.csv
: Moca-matrix-bloc-fixaddr/Moca_matrix_bloc_fixaddr_20160223_172342_CET_Physical_6.pjdump
: Moca-matrix-bloc-fixaddr/matrix.structs.csv
: Moca-matrix-bloc-fixaddr/matrix.stackmap.csv
: Moca-matrix-bloc-fixaddr/Moca_matrix_bloc_fixaddr_20160222_144532_CET_Physical_6.pjdump

Let's take a look at the main file

#+begin_src sh :results output :exports both
head Moca-matrix-bloc-fixaddr/Moca-framesoc.csv
#+end_src

#+RESULTS:
#+begin_example
@Virt,@Phy,Nreads,Nwrites,CPUMask,Start,End,TaskId,Shared
0000000000400040,000062000b0d4f90,1,0,000100110,1,4399,0,0
0000000000400b80,000062000b0d4f90,1,0,000000111,14887,17767,0,0
0000000000400270,0000000000400270,1,0,000001011,1700510,1729918,3,0
0000000000405435,0000000000405435,1,0,000000110,1,4399,0,0
000000000041d800,000000000041d800,1,0,000000110,1,4399,0,0
0000000000420fa0,0000000000420fa0,1,0,000000110,1,4399,0,0
00000000004341e1,00000000004341e1,1,0,000000110,1,4399,0,0
000000000044677a,000000000044677a,1,0,000000110,1,4399,0,0
000000000045dca0,000000000045dca0,1,0,000000110,1,4399,0,0
#+end_example

So the number of writes is the field number 4, lets count the number
of reads and writes in this file.

#+begin_src sh :results output :exports both
awk -F , 'BEGIN{r=0;w=0} {if($3>0){r++};if($4>0){w++}} END{print r" reads and "w" writes"}' Moca-matrix-bloc-fixaddr/Moca-framesoc.csv
#+end_src

#+RESULTS:
: 5479661 reads and 18285 writes

Ok the difference is way more than a factor 2 or 3 ...
I've recovered the original trace file (not processed) that is not in
the archive. it has the same headers as framesoc file without the last
field, thus the previous command should work on it.

#+begin_src sh :results output :exports both
awk -F , 'BEGIN{r=0;w=0} {if($3>0){r++};if($4>0){w++}} END{print r" reads and "w" writes"}' Moca-matrix-bloc-fixaddr/Moca-full-trace.csv
#+end_src

#+RESULTS:
: 1194354 reads and 17629 writes

#+begin_src sh :results output :exports both
echo 1194354 / 17629 | bc -l 
echo 5479661 / 1194354 | bc -l
echo 18285 / 17629 | bc -l 
#+end_src

#+RESULTS:
: 67.74939020931419819615
: 4.58797056819000061958
: 1.03721141301264961143

So in the raw trace we have already 67.8 more reads than write, event
if we admit that most accessses are reads and each writes also
triggers a read, it's a lot more than what I expected, I guess that I
should work on the way Moca decide if an access is a read or a write.

Still it is also weird that the post processing multiply by 4.6 the
number of reads while it almost doesn't change the number of
writes. I guess it comes from the fact that the number of accesses is
increased only when a shared is detected and according to the last
visualisation every write are private (and actually correspond to the
initialisation).

For now we will consider that this issue comes from Moca collection system.

*** DONE Duplicate data structure name
- State "DONE"       from "TODO"       [2016-02-26 Fri 11:20]
There are two entries in the structs.csv file with the same name, thus
they are merged in the visu

First make the name of data structures unique

#+begin_src sh :results output :exports both
awk -F , 'BEGIN{p="";cpt=1} {if(p==$1){n=$1"-"cpt;cpt++}\
else{cpt=1;n=$1};p=$1;print n","$2","$3}' \
Moca-matrix-bloc-fixaddr/matrix.structs.csv > Moca-matrix-bloc-fixaddr/matrix.structs-uniq.csv
cat  Moca-matrix-bloc-fixaddr/matrix.structs-uniq.csv
#+end_src

#+RESULTS:
: name,start,sz
: __GI___pthread_keys,2196192,16384
: __pthread_keys,2196192,16384
: UnnamedStruct#0,6303760,5280
: UnnamedStruct#1,6303888,32816
: UnnamedStruct#2,6303888,32816
: /tmp/matrix/matrix_naif.c:122,140737323565072,18000000
: /tmp/matrix/matrix_naif.c:123,140737305563152,18000000
: /tmp/matrix/matrix_naif.c:123-1,140737287561232,18000000

Better, now let's redo the analysis from [[*2016-02-25 New trace / Redo analysis / Try to be faster in filtering][2016-02-25 New trace / Redo analysis / Try to be faster in filtering]]  

#+begin_src sh :results output :session :exports both
UNIQFILE=Moca_matrix_bloc_fixaddr_20160223_172342_CET_Virtual_7
cat Moca-matrix-bloc-fixaddr/${UNIQFILE}.pjdump | grep ^Variable |
   awk -F, '{print "State,"$2",access,"$4","$5","$6",0,"$3}' > ${UNIQFILE}-states.csv
head ${UNIQFILE}-states.csv
#+end_src

#+RESULTS:
#+begin_example
State,4656816,access,1,4399,4398,0,Private_Read
State,6303500,access,1,4399,4398,0,Private_Read
State,6303500,access,1,4399,4398,0,Private_Write
State,6303752,access,1,4399,4398,0,Private_Read
State,6303752,access,1,4399,4398,0,Private_Write
State,7330440,access,1,4399,4398,0,Private_Read
State,7330440,access,1,4399,4398,0,Private_Write
State,7341840,access,1,4399,4398,0,Private_Read
State,7341840,access,1,4399,4398,0,Private_Write
State,7370576,access,1,4399,4398,0,Private_Read
#+end_example

Now, calculate intensity as in:
- [[*2016-02-17 Calculating intensity][2016-02-17 Calculating intensity]]

#+begin_src R :results output :session :exports both
k <- read.csv("Moca_matrix_bloc_fixaddr_20160223_172342_CET_Virtual_7-states.csv", header=FALSE);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Nature", "Address", "Type", "Start", "End", "Duration", "Imbric", "Value");
k$Niature <- NULL;
k$Type <- NULL;
k$Imbric <- NULL;
head(k);

sapply(k, class);

library(dplyr);

g <- k %>%
       group_by(Address, Start, End, Duration, Value) %>%
       summarize(N = length(Value));


nrow(g);
head(g);
h <- g %>% filter(Address >= 140737305563152 & Address <= 140737305563152+18000000);
head(h)
#+end_src

#+RESULTS:
#+begin_example
     V1      V2     V3 V4   V5   V6 V7            V8
1 State 4656816 access  1 4399 4398  0  Private_Read
2 State 6303500 access  1 4399 4398  0  Private_Read
3 State 6303500 access  1 4399 4398  0 Private_Write
4 State 6303752 access  1 4399 4398  0  Private_Read
5 State 6303752 access  1 4399 4398  0 Private_Write
6 State 7330440 access  1 4399 4398  0  Private_Read
       V1        V2        V3        V4        V5        V6        V7        V8 
 "factor" "numeric"  "factor" "integer" "integer" "integer" "integer"  "factor"
  Nature Address Start  End Duration         Value
1  State 4656816     1 4399     4398  Private_Read
2  State 6303500     1 4399     4398  Private_Read
3  State 6303500     1 4399     4398 Private_Write
4  State 6303752     1 4399     4398  Private_Read
5  State 6303752     1 4399     4398 Private_Write
6  State 7330440     1 4399     4398  Private_Read
   Nature   Address     Start       End  Duration     Value 
 "factor" "numeric" "integer" "integer" "integer"  "factor"
[1] 3368394
Source: local data frame [6 x 6]
Groups: Address, Start, End, Duration [5]

  Address   Start     End Duration         Value     N
    (dbl)   (int)   (int)    (int)        (fctr) (int)
1 4194928 1700510 1729918    29408  Private_Read     1
2 4197248   14887   17767     2880  Private_Read     1
3 4656816       1    4399     4398  Private_Read     1
4 6303496   14887   17767     2880  Private_Read     1
5 6303500       1    4399     4398  Private_Read     1
6 6303500       1    4399     4398 Private_Write     1
Source: local data frame [6 x 6]
Groups: Address, Start, End, Duration [5]

          Address Start   End Duration         Value     N
            (dbl) (int) (int)    (int)        (fctr) (int)
1 140737305563152  4400  9932     5532  Private_Read     1
2 140737305563152  4400  9932     5532 Private_Write     1
3 140737305563152 17734 17757       23  Private_Read     1
4 140737305563152 17757 20391     2634   Shared_Read     2
5 140737305563152 20391 27232     6841  Private_Read     1
6 140737305563152 27232 32008     4776   Shared_Read     2
#+end_example


Finally redo the plot v3 from [[*2016-02-25 Merge access information with data structure information][2016-02-25 Merge access information with data structure information]] 

#+begin_src R :results output graphics :file img/intensity_fixaddr_with_structure_v4.png :exports both :width 600 :height 400 :session
structs <- read.csv("Moca-matrix-bloc-fixaddr/matrix.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressEnd = structs$AddressStart + structs$AddressSize;

library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);


library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scales="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_fixaddr_with_structure_v4.png]]

Now this fix the non unique structure name issue.

*** DONE Importance of data structures
- State "DONE"       from "TODO"       [2016-02-26 Fri 13:40]
It seems that the last three data structures are not as
important as the first, but it is not clear, maybe plotting the
number of reads/write per structure would help determining if we can
ignore them.

Let's try to plot the number of accesses to each data structure:

#+begin_src R :results output :session :exports both
head(m)
library(plyr)
n <- ddply(m,c("Structure"),summarize,Nacc=sum(N));
head(n)
#+end_src

#+RESULTS:
#+begin_example
  Address Start    End Duration        Value N       Structure
1 6304392  4400   9932     5532 Private_Read 1 UnnamedStruct#0
2 6304392  4400   9932     5532 Private_Read 1 UnnamedStruct#1
3 6304392  4400   9932     5532 Private_Read 1 UnnamedStruct#2
4 6304416 87595 101980    14385  Shared_Read 1 UnnamedStruct#0
5 6304416 87595 101980    14385  Shared_Read 1 UnnamedStruct#1
6 6304416 87595 101980    14385  Shared_Read 1 UnnamedStruct#2
Error: length(rows) == 1 is not TRUE
                        Structure    Nacc
1   /tmp/matrix/matrix_naif.c:122   17508
2   /tmp/matrix/matrix_naif.c:123 5453604
3 /tmp/matrix/matrix_naif.c:123-1   24981
4                 UnnamedStruct#0    1214
5                 UnnamedStruct#1    1214
6                 UnnamedStruct#2    1214
#+end_example

ok let's plot it
#+begin_src R :results output graphics :file img/struct_importance_fixaddr_v1.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(n,aes(x=Structure,y=Nacc, fill=Structure)) +
  theme_bw() +
  geom_bar(stat="identity")
p
#+end_src

#+RESULTS:
[[file:img/struct_importance_fixaddr_v1.png]]

We can't see anything, let's try in log scale

#+begin_src R :results output graphics :file img/struct_importance_fixaddr_v2.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(n,aes(x=Structure,y=Nacc, fill=Structure)) +
  geom_bar(stat="identity") +
  theme_bw() +
  theme(panel.grid.minor = element_line(colour = "black", linetype="dashed", size = 0.1),
    panel.grid.major = element_line(colour = "black", size = 0.1)) +
  scale_y_log10()
  #lab=("Data structure name") +
  #ylab=("Number of accesses") +
p
#+end_src

#+RESULTS:
[[file:img/struct_importance_fixaddr.png]]


Better, so the unamed structures are indeed less accessed (about half
an order) but I don't think it's enough to neglect them.


** Conclusions

The visualisation is starting to be intersting, from those small test
we have seen several "weird" things:
- The number of access is always 1 or 2: I guess it comes from Moca
  tracing method usually there should be only 1 page fault (thus one
  access) per chunk having more than one access should be rare as it
  means a very specific order of accesses between two threads. Instead
  of plotting the intensity of accesses, we should probably plot the
  intensity in terms of number of threads.
- The detection of writes in Moca seems bad, I'll try to fix that

* 2016-02-29 Try on new traces                                        :David:

Moca's code to detect if an access is a read or a write seems correct,
the difference comes from the sampling, so we will try to look at some
other traces and compare them.

** Matrix modulo

The first trace we were studing is a naive matrix multiplication by
blocs, the next trace is an even more naive algorithm were threads
works on close piece of data.

The new trace is available on ligcloud:

We do the same analysis as here [[*Duplicate data structure name][Duplicate data structure name]]

#+begin_src sh :results output :exports both
DIR=Moca-matrix-modulo-2016-02-29_11-14-03
awk -F , 'BEGIN{p="";cpt=1} {if(p==$1){n=$1"-"cpt;cpt++}\
else{cpt=1;n=$1};p=$1;print n","$2","$3}' \
$DIR/matrix.structs.csv > $DIR/matrix.structs-uniq.csv
cat  $DIR/matrix.structs-uniq.csv
#+end_src

#+RESULTS:
: -1,,
: __GI___pthread_keys,2196192,16384
: __pthread_keys,2196192,16384
: UnnamedStruct#0,6303760,5280
: UnnamedStruct#1,6303888,32816
: UnnamedStruct#2,6303888,32816
: /home/david/Work/Bench/matrix/matrix_naif.c:140,140737313341456,8000000
: /home/david/Work/Bench/matrix/matrix_naif.c:123,140737321345040,8000000
: /home/david/Work/Bench/matrix/matrix_naif.c:122,140737329348624,8000000

Better, now let's redo the analysis from [[*2016-02-25 New trace / Redo analysis / Try to be faster in filtering][2016-02-25 New trace / Redo analysis / Try to be faster in filtering]]  

#+begin_src sh :results output :session :exports both
DIR=Moca-matrix-modulo-2016-02-29_11-14-03
UNIQFILE=$DIR/Moca_matrix_modulo_2016_02_29_11_14_03_20160229_112157_CET_Virtual_4
cat ${UNIQFILE}.pjdump | grep ^Variable |
   awk -F, '{print "State,"$2",access,"$4","$5","$6",0,"$3}' > ${UNIQFILE}-states.csv
head ${UNIQFILE}-states.csv
#+end_src

#+RESULTS:
#+begin_example
State,6303348,access,1,3492,3491,0,Private_Read
State,6303348,access,1,3492,3491,0,Private_Write
State,6303752,access,1,3492,3491,0,Private_Read
State,6303752,access,1,3492,3491,0,Private_Write
State,7330216,access,1,3492,3491,0,Private_Read
State,7330216,access,1,3492,3491,0,Private_Write
State,7332280,access,1,3492,3491,0,Private_Read
State,7332280,access,1,3492,3491,0,Private_Write
State,7339250,access,1,3492,3491,0,Private_Read
State,7339250,access,1,3492,3491,0,Private_Write
#+end_example

Now, calculate intensity as in:
- [[*2016-02-17 Calculating intensity][2016-02-17 Calculating intensity]]

#+begin_src R :results output :session :exports both
k <- read.csv("Moca-matrix-modulo-2016-02-29_11-14-03/Moca_matrix_modulo_2016_02_29_11_14_03_20160229_112157_CET_Virtual_4-states.csv", header=FALSE);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Nature", "Address", "Type", "Start", "End", "Duration", "Imbric", "Value");
k$Niature <- NULL;
k$Type <- NULL;
k$Imbric <- NULL;
head(k);

sapply(k, class);

library(dplyr);

g <- k %>%
       group_by(Address, Start, End, Duration, Value) %>%
       summarize(N = length(Value));


nrow(g);
head(g);
#h <- g %>% filter(Address >= 140737313341456 & Address <= 140737313341456+24000000);
#head(h)
#+end_src

#+RESULTS:
#+begin_example
     V1      V2     V3 V4   V5   V6 V7            V8
1 State 6303348 access  1 3492 3491  0  Private_Read
2 State 6303348 access  1 3492 3491  0 Private_Write
3 State 6303752 access  1 3492 3491  0  Private_Read
4 State 6303752 access  1 3492 3491  0 Private_Write
5 State 7330216 access  1 3492 3491  0  Private_Read
6 State 7330216 access  1 3492 3491  0 Private_Write
       V1        V2        V3        V4        V5        V6        V7        V8 
 "factor" "numeric"  "factor" "integer" "integer" "integer" "integer"  "factor"
  Nature Address Start  End Duration         Value
1  State 6303348     1 3492     3491  Private_Read
2  State 6303348     1 3492     3491 Private_Write
3  State 6303752     1 3492     3491  Private_Read
4  State 6303752     1 3492     3491 Private_Write
5  State 7330216     1 3492     3491  Private_Read
6  State 7330216     1 3492     3491 Private_Write
   Nature   Address     Start       End  Duration     Value 
 "factor" "numeric" "integer" "integer" "integer"  "factor"
[1] 1224679
Source: local data frame [6 x 6]
Groups: Address, Start, End, Duration [6]

  Address  Start    End Duration        Value     N
    (dbl)  (int)  (int)    (int)       (fctr) (int)
1 4194928  94264  94505      241 Private_Read     1
2 4194928  94505 108267    13762  Shared_Read     2
3 4194928 108267 108267        0 Private_Read     1
4 4196888   5923   7920     1997 Private_Read     1
5 4197408   7927  24611    16684 Private_Read     1
6 6303232   5923   7920     1997 Private_Read     1
#+end_example


Finally redo the plot v3 from [[*2016-02-25 Merge access information with data structure information][2016-02-25 Merge access information with data structure information]] 

#+begin_src R :results output graphics :file img/intensity_modulo_with_structure_v4.png :exports both :width 600 :height 400 :session
structs <- read.csv("Moca-matrix-modulo-2016-02-29_11-14-03/matrix.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressEnd = structs$AddressStart + structs$AddressSize;

library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);


library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scales="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_modulo_with_structure_v4.png]]


Let's compare this visualisation to
[[file:img/intensity_fixaddr_with_structure_v4.png][file:~/Work/labbook-lucas/img/intensity_fixaddr_with_structure_v4.png]] :
- The intensity goes up to 12 sometimes while it was never more than 2
  in matrix-bloc. This happens because the different thread work on
  very close addresses.
- As expected, the number of detected write have significantly
  increased, I think we can consider that the previous trace was clean
  and this is not a BUG in Moca.
- We can see a lot of shared write on the third data structure which
  is clearly bad in terms of cache.
- We can't see any patterns in the middle structure an the patterns in
  the other structure seems way less linear.
- It is still hard to know which thread is doing what. We really should try
  to visualize the intensity in terms of number of thread involved.


** DONE New visualisation: number of threads                         :David:
- State "DONE"       from "TODO"       [2016-02-29 Mon 18:54]
- State "TODO"       from              [2016-02-29 Mon 14:08]
  
Here is a link to an archive containing the trace I am  working on:
https://ligcloud.imag.fr/public.php?service=files&t=1d3fdcfed0bda3e1cdd30d6ff0093d7e

#+begin_src sh :results output :exports both
md5sum matrix-modulo.tgz
#+end_src

#+RESULTS:
: 82e5aa80788c8c8c5c1a021e45dea44e  matrix-modulo.tgz

#+begin_src sh :results output :exports both
DIR=Moca-matrix-modulo-2016-02-29_11-14-03
head $DIR/Moca_matrix_modulo_2016_02_29_11_14_03_20160229_112157_CET_Virtual_4-states.csv
#+end_src

#+RESULTS:
#+begin_example
State,6303348,access,1,3492,3491,0,Private_Read
State,6303348,access,1,3492,3491,0,Private_Write
State,6303752,access,1,3492,3491,0,Private_Read
State,6303752,access,1,3492,3491,0,Private_Write
State,7330216,access,1,3492,3491,0,Private_Read
State,7330216,access,1,3492,3491,0,Private_Write
State,7332280,access,1,3492,3491,0,Private_Read
State,7332280,access,1,3492,3491,0,Private_Write
State,7339250,access,1,3492,3491,0,Private_Read
State,7339250,access,1,3492,3491,0,Private_Write
#+end_example

The thread information is not in the pjdump file, and the pipeline
from the original trace to this file is very long (trace ->
preprocessing -> framesoc -> pjdump -> states.csv). We should modify
the csv generated by the preprocessing phase and work on this.

#+begin_src sh :results output :exports both
head Moca-matrix-modulo-2016-02-29_11-14-03/Moca-framesoc.csv
#+end_src

#+RESULTS:
#+begin_example
@Virt,@Phy,Nreads,Nwrites,CPUMask,Start,End,TaskId,Shared
0000000000400040,00006200028a0630,1,0,000010110,1,3492,0,0
0000000000400a18,00006200028a0630,1,0,000010110,5923,7920,0,0
0000000000400c20,00006200028a0630,1,0,000100110,7927,24611,2,0
0000000000400270,0000000000400270,1,0,010000110,94264,94505,2,0
0000000000400270,0000000000400270,1,0,010000110,94505,108267,2,1
0000000000400270,0000000000400270,1,0,001000110,94505,108267,3,1
0000000000400270,0000000000400270,1,0,001000110,108267,108267,3,0
0000000000405435,0000000000405435,1,0,010000110,1,3492,0,0
000000000041d800,000000000041d800,1,0,010000110,1,3492,0,0
#+end_example

At this level shared is always 0 or 1, we could instead put the number
of threads sharing the data. It's only a one line change in the post
processing script, let's try it:

#+begin_src sh :results output :exports both
cd  Moca-matrix-modulo-2016-02-29_11-14-03
~/Work/Moca/src/utils/create_event_producer.sh 4096 Moca-full-trace.csv
head Moca-framesoc.csv
#+end_src

#+RESULTS:
#+begin_example
Generating producer files
Generating framesoc trace file
Generating Virtual producers file
Generating Physical producers file
Virtual-producers.log Done
Physical-producers.log Done
Reading from Moca-full-trace.csv
102894 accesses on 6000 pages parsed from Moca-full-trace.csv
done in 00 h 00 min 12.765 sec
@Virt,@Phy,Nreads,Nwrites,CPUMask,Start,End,TaskId,Shared
0000000000400040,00006200028a0630,1,0,000010110,1,3492,0,1
0000000000400a18,00006200028a0630,1,0,000010110,5923,7920,0,1
0000000000400c20,00006200028a0630,1,0,000100110,7927,24611,2,1
0000000000400270,0000000000400270,1,0,010000110,94264,94505,2,1
0000000000400270,0000000000400270,1,0,010000110,94505,108267,2,2
0000000000400270,0000000000400270,1,0,001000110,94505,108267,3,2
0000000000400270,0000000000400270,1,0,001000110,108267,108267,3,1
0000000000405435,0000000000405435,1,0,010000110,1,3492,0,1
000000000041d800,000000000041d800,1,0,010000110,1,3492,0,1
#+end_example


#+begin_src R :results output :session :exports both
computeType <- function(df){
  shared <-9
  write <- 4
  if(df[shared] >= 2){
    mytype <- "Shared"
  }else{
    mytype <- "Private"
  }
  if(df[write] >= 1){
     mytype <- paste(mytype,"Write" , sep="_")
  }else{
     mytype <- paste(mytype,"Read" , sep="_")
  }
  return(mytype)
}

k <- read.csv("Moca-matrix-modulo-2016-02-29_11-14-03/Moca-framesoc.csv", header=T);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

k$Value <- apply(k,1,computeType)
k$Address <- sprintf("%f", as.numeric(paste("0x", k$Address, sep="")))
k$Phy <- NULL;
k$CPU <- NULL;
k$Tid <- NULL;
k$Reads <- NULL ;
k$Writes <- NULL ;
k$Duration <- k$End - k$Start
head(k);
#+end_src

#+RESULTS:
#+begin_example
            X.Virt            X.Phy Nreads Nwrites  CPUMask Start    End TaskId
1 0000000000400040 00006200028a0630      1       0    10110     1   3492      0
2 0000000000400a18 00006200028a0630      1       0    10110  5923   7920      0
3 0000000000400c20 00006200028a0630      1       0   100110  7927  24611      2
4 0000000000400270 0000000000400270      1       0 10000110 94264  94505      2
5 0000000000400270 0000000000400270      1       0 10000110 94505 108267      2
6 0000000000400270 0000000000400270      1       0  1000110 94505 108267      3
  Shared
1      1
2      1
3      1
4      1
5      2
6      2
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
         Address Start    End N        Value Duration
1 4194368.000000     1   3492 1 Private_Read     3491
2 4196888.000000  5923   7920 1 Private_Read     1997
3 4197408.000000  7927  24611 1 Private_Read    16684
4 4194928.000000 94264  94505 1 Private_Read      241
5 4194928.000000 94505 108267 2  Shared_Read    13762
6 4194928.000000 94505 108267 2  Shared_Read    13762
#+end_example


Ok I think that the data frame now looks like what we add with the
pjdump files, let's try to visualize that:

#+begin_src R :results output :session :exports both
g <- k
structs <- read.csv("Moca-matrix-modulo-2016-02-29_11-14-03/matrix.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressEnd = structs$AddressStart + structs$AddressSize;

library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);
#+end_src

#+RESULTS:
:          Address Start   End Duration        Value N       Structure
: 1 6304392.000000  5923  7920     1997 Private_Read 1 UnnamedStruct#0
: 2 6304392.000000  5923  7920     1997 Private_Read 1 UnnamedStruct#1
: 3 6304392.000000  5923  7920     1997 Private_Read 1 UnnamedStruct#2
: 4 6304472.000000  7921 10085     2164 Private_Read 1 UnnamedStruct#0
: 5 6304472.000000  7921 10085     2164 Private_Read 1 UnnamedStruct#1
: 6 6304472.000000  7921 10085     2164 Private_Read 1 UnnamedStruct#2

#+begin_src R :results output graphics :file img/intensity_modulo_threads.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scales="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_modulo_threads.png]]


This is starting to be very interesting, we can see here that the
middle data structure is shared by all thread, which might be bad on
NUMA machines, while the others seems two be shared mostly by two
threads, which should be a bit better.

- What is happening with the addresses in the big data structures ?

Can we do the same thing for the bloc version, see if it looks better:

#+begin_src sh :results output :exports both
cd  Moca-matrix-bloc-fixaddr/
~/Work/Moca/src/utils/create_event_producer.sh 4096 Moca-full-trace.csv
head Moca-framesoc.csv
#+end_src

#+RESULTS:
#+begin_example
Generating producer files
Generating framesoc trace file
Generating Virtual producers file
Generating Physical producers file
Virtual-producers.log Done
Physical-producers.log Done
done in 00 h 00 min 00.062 sec
@Virt,@Phy,Nreads,Nwrites,CPUMask,Start,End,TaskId,Shared
0000000000400040,000062000b0d4f90,1,0,000100110,1,4399,0,0
0000000000400b80,000062000b0d4f90,1,0,000000111,14887,17767,0,0
0000000000400270,0000000000400270,1,0,000001011,1700510,1729918,3,0
0000000000405435,0000000000405435,1,0,000000110,1,4399,0,0
000000000041d800,000000000041d800,1,0,000000110,1,4399,0,0
0000000000420fa0,0000000000420fa0,1,0,000000110,1,4399,0,0
00000000004341e1,00000000004341e1,1,0,000000110,1,4399,0,0
000000000044677a,000000000044677a,1,0,000000110,1,4399,0,0
000000000045dca0,000000000045dca0,1,0,000000110,1,4399,0,0
#+end_example

#+begin_src R :results output :session :exports both
computeType <- function(df){
  shared <-9
  write <- 4
  if(df[shared] >= 2){
    mytype <- "Shared"
  }else{
    mytype <- "Private"
  }
  if(df[write] >= 1){
     mytype <- paste(mytype,"Write" , sep="_")
  }else{
     mytype <- paste(mytype,"Read" , sep="_")
  }
  return(mytype)
}

k <- read.csv("Moca-matrix-bloc-fixaddr/Moca-framesoc.csv", header=T);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

k$Value <- apply(k,1,computeType)
k$Address <- sprintf("%f", as.numeric(paste("0x", k$Address, sep="")))
k$Phy <- NULL;
k$CPU <- NULL;
k$Tid <- NULL;
k$Reads <- NULL ;
k$Writes <- NULL ;
k$Duration <- k$End - k$Start
head(k);

g <- k
structs <- read.csv("Moca-matrix-bloc-fixaddr/matrix.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressEnd = structs$AddressStart + structs$AddressSize;

library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);
#+end_src

#+RESULTS:
#+begin_example
            X.Virt            X.Phy Nreads Nwrites CPUMask   Start     End
1 0000000000400040 000062000b0d4f90      1       0  100110       1    4399
2 0000000000400b80 000062000b0d4f90      1       0     111   14887   17767
3 0000000000400270 0000000000400270      1       0    1011 1700510 1729918
4 0000000000405435 0000000000405435      1       0     110       1    4399
5 000000000041d800 000000000041d800      1       0     110       1    4399
6 0000000000420fa0 0000000000420fa0      1       0     110       1    4399
  TaskId Shared
1      0      1
2      0      1
3      3      1
4      0      1
5      0      1
6      0      1
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
         Address   Start     End N        Value Duration
1 4194368.000000       1    4399 1 Private_Read     4398
2 4197248.000000   14887   17767 1 Private_Read     2880
3 4194928.000000 1700510 1729918 1 Private_Read    29408
4 4215861.000000       1    4399 1 Private_Read     4398
5 4315136.000000       1    4399 1 Private_Read     4398
6 4329376.000000       1    4399 1 Private_Read     4398
         Address Start   End Duration        Value N       Structure
1 6304392.000000  4400  9932     5532 Private_Read 1 UnnamedStruct#0
2 6304392.000000  4400  9932     5532 Private_Read 1 UnnamedStruct#1
3 6304392.000000  4400  9932     5532 Private_Read 1 UnnamedStruct#2
4 6304536.000000 14887 17757     2870 Private_Read 1 UnnamedStruct#0
5 6304536.000000 14887 17757     2870 Private_Read 1 UnnamedStruct#1
6 6304536.000000 14887 17757     2870 Private_Read 1 UnnamedStruct#2
#+end_example

#+begin_src R :results output graphics :file img/intensity_bloc_threads.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scales="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_bloc_threads.png]]


The interesting thing todo here is to compare the bloc version (above)
to the very naive one:
[[file:img/intensity_modulo_threads.png][file:~/Work/labbook-lucas/img/intensity_modulo_threads.png]]

We see several difference in the visualisation:
- The patterns are way more linear in the bloc version which seems
  better in regards of the cache issues
- Sharing is less intensive for the bloc version, especially in terms
  of writes: we manage to go up to 3 threads writing the same page in
  the naive version.
- For both version the 2^nd structure is accessed in an ugly way being
  completely shared, I guess it won't be inefficient for NUMA
  machines.

So I guess we have a visualisation from which we can start to see
things, the next step is to look at some other application and try to
do some improvements. We also should fix the number of addresses
issue.
* 2016-03-01 MOCA availability                                        :Lucas:

David just told me that MOCA is available here:
- https://github.com/dbeniamine/MOCA

The scripts to replay previous sections are there:
- https://github.com/dbeniamine/MOCA/blob/master/src/utils/create_event_producer.sh
- https://github.com/dbeniamine/MOCA/blob/master/src/utils/framesoc_parser.pl

* 2016-03-01 Can we go deeper ?                                       :David:

** Continue previous analysis

Let's restart were we stopped yesterday:

#+begin_src R :results output :session :exports both
computeType <- function(df){
  shared <-9
  write <- 4
  if(df[shared] >= 2){
    mytype <- "Shared"
  }else{
    mytype <- "Private"
  }
  if(df[write] >= 1){
     mytype <- paste(mytype,"Write" , sep="_")
  }else{
     mytype <- paste(mytype,"Read" , sep="_")
  }
  return(mytype)
}

k <- read.csv("Moca-matrix-modulo-2016-02-29_11-14-03/Moca-framesoc.csv", header=T);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

k$Value <- apply(k,1,computeType)
k$Address <- sprintf("%f", as.numeric(paste("0x", k$Address, sep="")))
k$Phy <- NULL;
k$CPU <- NULL;
k$Tid <- NULL;
k$Reads <- NULL ;
k$Writes <- NULL ;
k$Duration <- k$End - k$Start
head(k);

g <- k
structs <- read.csv("Moca-matrix-modulo-2016-02-29_11-14-03/matrix.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressEnd = structs$AddressStart + structs$AddressSize;

library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);
#+end_src

 #+RESULTS:
 #+begin_example
             X.Virt            X.Phy Nreads Nwrites  CPUMask Start    End TaskId
 1 0000000000400040 00006200028a0630      1       0    10110     1   3492      0
 2 0000000000400a18 00006200028a0630      1       0    10110  5923   7920      0
 3 0000000000400c20 00006200028a0630      1       0   100110  7927  24611      2
 4 0000000000400270 0000000000400270      1       0 10000110 94264  94505      2
 5 0000000000400270 0000000000400270      1       0 10000110 94505 108267      2
 6 0000000000400270 0000000000400270      1       0  1000110 94505 108267      3
   Shared
 1      1
 2      1
 3      1
 4      1
 5      2
 6      2
    X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
  "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
    Shared 
 "integer"
          Address Start    End N        Value Duration
 1 4194368.000000     1   3492 1 Private_Read     3491
 2 4196888.000000  5923   7920 1 Private_Read     1997
 3 4197408.000000  7927  24611 1 Private_Read    16684
 4 4194928.000000 94264  94505 1 Private_Read      241
 5 4194928.000000 94505 108267 2  Shared_Read    13762
 6 4194928.000000 94505 108267 2  Shared_Read    13762
          Address Start   End Duration        Value N       Structure
 1 6304392.000000  5923  7920     1997 Private_Read 1 UnnamedStruct#0
 2 6304392.000000  5923  7920     1997 Private_Read 1 UnnamedStruct#1
 3 6304392.000000  5923  7920     1997 Private_Read 1 UnnamedStruct#2
 4 6304472.000000  7921 10085     2164 Private_Read 1 UnnamedStruct#0
 5 6304472.000000  7921 10085     2164 Private_Read 1 UnnamedStruct#1
 6 6304472.000000  7921 10085     2164 Private_Read 1 UnnamedStruct#2
#+end_example

Before doing the plot we'd like to focus on some data structures:

#+begin_src R :results output :session :exports both
head(m)
n <- m[grepl("matrix",m$Structure),]
head(n)
#+end_src

#+RESULTS:
#+begin_example
         Address Start   End Duration        Value N       Structure
1 6304392.000000  5923  7920     1997 Private_Read 1 UnnamedStruct#0
2 6304392.000000  5923  7920     1997 Private_Read 1 UnnamedStruct#1
3 6304392.000000  5923  7920     1997 Private_Read 1 UnnamedStruct#2
4 6304472.000000  7921 10085     2164 Private_Read 1 UnnamedStruct#0
5 6304472.000000  7921 10085     2164 Private_Read 1 UnnamedStruct#1
6 6304472.000000  7921 10085     2164 Private_Read 1 UnnamedStruct#2
                  Address Start   End Duration         Value N
19 140737313341456.000000  5923  7920     1997 Private_Write 1
20 140737313341464.000000  7927 24611    16684  Private_Read 1
21 140737313345536.000000     1  3492     3491 Private_Write 1
22 140737313345536.000000  5923  7920     1997 Private_Write 1
23 140737313345560.000000  7927  7998       71  Private_Read 1
24 140737313345560.000000  7998 10000     2002   Shared_Read 2
                                         Structure
19 /home/david/Work/Bench/matrix/matrix_naif.c:140
20 /home/david/Work/Bench/matrix/matrix_naif.c:140
21 /home/david/Work/Bench/matrix/matrix_naif.c:140
22 /home/david/Work/Bench/matrix/matrix_naif.c:140
23 /home/david/Work/Bench/matrix/matrix_naif.c:140
24 /home/david/Work/Bench/matrix/matrix_naif.c:140
#+end_example

#+begin_src R :results output graphics :file img/intensity_modulo_threads_zoom.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(n) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scales="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_modulo_threads_zoom.png]]


It's a bit better, let's zoom in the middle data structure

#+begin_src R :results output graphics :file img/intensity_modulo_threads_zoom.png :exports both :width 600 :height 400 :session
library(ggplot2);
o <- n[grepl(".c:123",m$Structure),]
p <- ggplot(o) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(~Value, scales="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_modulo_threads_zoom.png]]


Well we don't see much more things, but It doesn't matter I think the
visualization is already quite usefull, let's try to work on some
other traces.

** IS

*** DONE First look
- State "DONE"       from "TODO"       [2016-03-01 Tue 11:26]
- State "TODO"       from              [2016-03-01 Tue 11:26]

IS in one of the NAS paralell benchmark, we saw a particularly
interesting pattern with TABARNAC: all the thread were accessing a
data structure with a Gaussian distribution. In other words each page
of the structure were accessed by each threads and more a page was in
the middle of the structure, more it was accessed.

There is an archive to the IS trace:
https://ligcloud.imag.fr/public.php?service=files&t=d724ad2c1c0c9b648eed5974cc736f58

#+begin_src sh :results output :exports both
md5sum is-a-base.tgz
#+end_src

#+RESULTS:
: a89f1719f4c4d0c68977f4fdcbba4712  is-a-base.tgz

#+begin_src sh :results output :exports both :session
DIR=Moca-is.A-2016-02-26_16-29-49
MOCAPATH=~/Work/Moca
cd $DIR
$MOCAPATH/src/utils/create_event_producer.sh 4096 Moca-full-trace.csv
head Moca-framesoc.csv
#+end_src

#+RESULTS:
#+begin_example
Generating producer files
Generating framesoc trace file
Generating Virtual producers file
Generating Physical producers file
Virtual-producers.log Done
Physical-producers.log Done
Reading from Moca-full-trace.csv
48577 accesses on 17022 pages parsed from Moca-full-trace.csv
done in 00 h 00 min 02.225 sec
@Virt,@Phy,Nreads,Nwrites,CPUMask,Start,End,TaskId,Shared
0000000000400040,000062000b08fa48,1,0,000001011,1,157,0,1
0000000000400040,000062000b08fa48,1,0,000001011,157,2825,0,2
0000000000400848,000062000b08fa48,1,0,000010011,157,2825,3,2
0000000000400848,000062000b08fa48,1,0,000010011,2825,5603,3,1
0000000000400848,000062000b08fa48,1,0,000010011,5603,8610,3,2
00000000004002a8,000062000b08fa48,1,0,000001011,5603,8610,0,2
0000000000400848,000062000b08fa48,1,0,000010011,8610,8616,3,1
0000000000400848,000062000b08fa48,1,0,000010011,8616,20399,3,2
0000000000400bd4,000062000b08fa48,1,0,000001011,8616,20399,0,2
#+end_example

#+begin_src sh :results output :exports both :session
DIR=Moca-is.A-2016-02-26_16-29-49
awk -F , 'BEGIN{p="";cpt=1} {if(p==$1){n=$1"-"cpt;cpt++}\
else{cpt=1;n=$1};p=$1;print n","$2","$3}' \
$DIR/is.A.structs.csv > $DIR/is.A.structs-uniq.csv
cat  $DIR/is.A.structs-uniq.csv
#+end_src

#+RESULTS:
#+begin_example
-1,,
__GI___pthread_keys,2196192,16384
__pthread_keys,2196192,16384
key_buff1,6305024,2097152
key_array,8402176,33554432
key_buff2,41956608,33554432
UnnamedStruct#2,75513872,32816
/tmp/NPB3.3-OMP/IS/is.c:494,75519344,4096
/tmp/NPB3.3-OMP/IS/is.c:494-1,75523456,4096
/tmp/NPB3.3-OMP/IS/is.c:494-2,75527568,4096
/tmp/NPB3.3-OMP/IS/is.c:494-3,75531680,4096
/tmp/NPB3.3-OMP/IS/is.c:494-4,75535792,4096
/tmp/NPB3.3-OMP/IS/is.c:494-5,75539904,4096
/tmp/NPB3.3-OMP/IS/is.c:494-6,75544016,4096
/tmp/NPB3.3-OMP/IS/is.c:494-7,75548128,4096
#+end_example

Hum it looks like there are a lot of data structures with the same
name here, it's gona be a mess to understand which one is which ...

#+begin_src R :results output :session :exports both
computeType <- function(df){
  shared <-9
  write <- 4
  if(df[shared] >= 2){
    mytype <- "Shared"
  }else{
    mytype <- "Private"
  }
  if(df[write] >= 1){
     mytype <- paste(mytype,"Write" , sep="_")
  }else{
     mytype <- paste(mytype,"Read" , sep="_")
  }
  return(mytype)
}

k <- read.csv("Moca-is.A-2016-02-26_16-29-49/Moca-framesoc.csv", header=T);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

k$Value <- apply(k,1,computeType)
k$Address <- sprintf("%f", as.numeric(paste("0x", k$Address, sep="")))
k$Phy <- NULL;
k$CPU <- NULL;
k$Tid <- NULL;
#k$Reads <- NULL ;
#k$Writes <- NULL ;
k$Duration <- k$End - k$Start
head(k);

g <- k
structs <- read.csv("Moca-is.A-2016-02-26_16-29-49/is.A.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressEnd = structs$AddressStart + structs$AddressSize;

library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.Reads, g.Writes, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);
#+end_src

#+RESULTS:
#+begin_example
            X.Virt            X.Phy Nreads Nwrites CPUMask Start  End TaskId
1 0000000000400040 000062000b08fa48      1       0    1011     1  157      0
2 0000000000400040 000062000b08fa48      1       0    1011   157 2825      0
3 0000000000400848 000062000b08fa48      1       0   10011   157 2825      3
4 0000000000400848 000062000b08fa48      1       0   10011  2825 5603      3
5 0000000000400848 000062000b08fa48      1       0   10011  5603 8610      3
6 00000000004002a8 000062000b08fa48      1       0    1011  5603 8610      0
  Shared
1      1
2      2
3      2
4      1
5      2
6      2
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
         Address Reads Writes Start  End N        Value Duration
1 4194368.000000     1      0     1  157 1 Private_Read      156
2 4194368.000000     1      0   157 2825 2  Shared_Read     2668
3 4196424.000000     1      0   157 2825 2  Shared_Read     2668
4 4196424.000000     1      0  2825 5603 1 Private_Read     2778
5 4196424.000000     1      0  5603 8610 2  Shared_Read     3007
6 4194984.000000     1      0  5603 8610 2  Shared_Read     3007
         Address Start   End Duration         Value Reads Writes N Structure
1 6311168.000000   157   163        6 Private_Write     1      1 1 key_buff1
2 6311168.000000   163 11652    11489  Shared_Write     1      1 2 key_buff1
3 6309120.000000   163 11652    11489  Shared_Write     1      1 2 key_buff1
4 6311168.000000 11652 21776    10124  Shared_Write     1      1 3 key_buff1
5 6309120.000000 11652 21776    10124  Shared_Write     1      1 3 key_buff1
6 6309120.000000 11652 21776    10124  Shared_Write     1      1 3 key_buff1
#+end_example


#+begin_src R :results output graphics :file img/intensity_is_threads.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_is_threads.png]]



 Woh there is a lot of data structures here, most of the accesses
 seems to be on the three first, let's do a plot similar to:
[[*Importance of data structures][Importance of data structures]]

#+begin_src R :results output :session :exports both
library(plyr)
n <- ddply(m,c("Structure"),summarize,Reads=sum(Reads), Writes=sum(Writes));
o <- n
o$Writes <- NULL
o$Type <- rep("Read", nrow(o))
names(o) <- c("Structure", "N", "Type")
q <- n
q$Reads <- NULL
q$Type <- rep("Write", nrow(o))
names(q) <- c("Structure", "N", "Type")
q <- rbind(q,o)
head(q)
#+end_src

#+RESULTS:
:                       Structure     N  Type
: 1                     key_array  8194 Write
: 2                     key_buff1 49647 Write
: 3                     key_buff2 36940 Write
: 4   /tmp/NPB3.3-OMP/IS/is.c:494     1 Write
: 5 /tmp/NPB3.3-OMP/IS/is.c:494-1     7 Write
: 6 /tmp/NPB3.3-OMP/IS/is.c:494-2     2 Write

#+begin_src R :results output graphics :file img/struct_importance_is.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(q,aes(x=Structure,y=N, fill=Type)) +
  theme_bw() +
  geom_bar(stat="identity")
p
#+end_src

#+RESULTS:
[[file:img/struct_importance_is.png]]


Ok we can clearly focus on the first three data structures. BTW this
version of the plot is more compelete than the previous, it is nice to
see the read / write ratio.

#+begin_src R :results output graphics :file img/intensity_is_threads_zoom.png :exports both :width 600 :height 400 :session
library(ggplot2);
r <- m[grepl("key_", m$Structure),]
p <- ggplot(r) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_is_threads_zoom.png]]


- So we see that keybuff1 is shared in write mode
  - At the beginning it's is shared by 2 or 3 threads, but when it the
    number of threads increase with the time
  - It seems that the addresses in the middle are accessed by more
    threads than the other, but it's not as obvious as in Tabarnac. We
    shoul try to plot the number of accesses per addresses.
- key buff1 seems to never be read, I guess we always do something
  like  keybuff1[i]++ that triggers a read and a write.
- The read write pattern of key array is quite fun: basicely we never
  re write anything, which is not the case for the two other data
  structure. This information could be used to replicate the data
  structure if needed.
  
#+begin_src R :results output graphics :file img/intensity_is_threads_zoom_nacc.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(r) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(Reads+Writes))) +
  facet_grid(Structure~Value, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_is_threads_zoom_nacc.png]]

The number of accesses for writes are higher than for reads, it is an
artifacts as a write access always contains also a read.

I'm a bit disapointed here, I thought I will see the fact that the
middle addreses of keybuff1 are more accessed ...

What if we remove the facet on the type of access

#+begin_src R :results output graphics :file img/intensity_is_threads_zoom_nacc2.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(r) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(Reads+Writes))) +
  facet_grid(Structure~., scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_is_threads_zoom_nacc2.png]]


Well  he we can only say that keybuff1 have more accesses at the same
time than the two other structures, but we still can't see this gaussian

I'll just check that the trace is indeed the original version of is,
(If yes the result of the following line should be Macros: DYN).

#+begin_src sh :results output :exports both
grep Macros Moca-is.A-2016-02-26_16-29-49/Moca-is.A.log
#+end_src

#+RESULTS:
: Macros:	DYN

It looks fine, I should compare these plots to the modified version of
IS, and see what happens ...
For reminder Tabarnac IS visualisation are available here:
http://dbeniamine.github.io/Tabarnac/examples/is.B-original.html
and
http://dbeniamine.github.io/Tabarnac/examples/is.B-modif.html

Also we are looking to a class A version of IS, for tabarnac we used a
class B, maybe it could help to work on a bigger version.


*** DONE Class B
- State "DONE"       from "STARTED"    [2016-03-01 Tue 14:55]
- State "STARTED"    from "TODO"       [2016-03-01 Tue 14:11]
- State "TODO"       from              [2016-03-01 Tue 11:26]
 
So I just generated three new is traces:
- is.A-modif: Class A, modification from tabarnac paper (see
  http://dbeniamine.github.io/Tabarnac/examples/ ).
- is.B-orig: Class A, original version.
- is.B-modif: Class B, modified.

As usual, there is an archive on ligcloud:
https://ligcloud.imag.fr/public.php?service=files&t=4e9547f6da887a6c8ebcca9dea4c159f

#+begin_src sh :results output :exports both
md5sum is-AB.tgz
tar xvzf is-AB.tgz
#+end_src

#+RESULTS:
#+begin_example
a20fd83a6de147c13ac7d572f3d526b4  is-AB.tgz
Moca-is.A-modif-2016-03-01_14-00-23/
Moca-is.A-modif-2016-03-01_14-00-23/is.A-modif-stackmap.csv
Moca-is.A-modif-2016-03-01_14-00-23/Moca-full-trace.csv
Moca-is.A-modif-2016-03-01_14-00-23/Moca-output.log
Moca-is.A-modif-2016-03-01_14-00-23/stacks.log
Moca-is.A-modif-2016-03-01_14-00-23/Moca-is.A-modif.log
Moca-is.A-modif-2016-03-01_14-00-23/temp_1760
Moca-is.A-modif-2016-03-01_14-00-23/Moca-is.A-modif.log.err
Moca-is.A-modif-2016-03-01_14-00-23/is.A-modif.structs.csv
Moca-is.B-modif-2016-03-01_14-00-58/
Moca-is.B-modif-2016-03-01_14-00-58/Moca-is.B-modif.log
Moca-is.B-modif-2016-03-01_14-00-58/Moca-is.B-modif.log.err
Moca-is.B-modif-2016-03-01_14-00-58/is.B-modif-stackmap.csv
Moca-is.B-modif-2016-03-01_14-00-58/Moca-full-trace.csv
Moca-is.B-modif-2016-03-01_14-00-58/Moca-output.log
Moca-is.B-modif-2016-03-01_14-00-58/stacks.log
Moca-is.B-modif-2016-03-01_14-00-58/is.B-modif.structs.csv
Moca-is.B-modif-2016-03-01_14-00-58/temp_3266
Moca-is.B-orig-2016-03-01_14-03-40/
Moca-is.B-orig-2016-03-01_14-03-40/Moca-is.B-orig.log
Moca-is.B-orig-2016-03-01_14-03-40/is.B-orig-stackmap.csv
Moca-is.B-orig-2016-03-01_14-03-40/Moca-is.B-orig.log.err
Moca-is.B-orig-2016-03-01_14-03-40/Moca-full-trace.csv
Moca-is.B-orig-2016-03-01_14-03-40/Moca-output.log
Moca-is.B-orig-2016-03-01_14-03-40/stacks.log
Moca-is.B-orig-2016-03-01_14-03-40/is.B-orig.structs.csv
Moca-is.B-orig-2016-03-01_14-03-40/temp_5417
#+end_example

We start with the original is.B trace, see if the patterns are more
visible than on the class A, same analysis as [[*First look][above.]] 

#+begin_src sh :results output :exports both :session
DIR=Moca-is.B-orig-2016-03-01_14-03-40
MOCAPATH=~/Work/Moca
cd $DIR
$MOCAPATH/src/utils/create_event_producer.sh 4096 Moca-full-trace.csv
head Moca-framesoc.csv
awk -F , 'BEGIN{p="";cpt=1} {if(p==$1){n=$1"-"cpt;cpt++}\
else{cpt=1;n=$1};p=$1;print n","$2","$3}' \
is.B-orig.structs.csv > is.B-orig.structs-uniq.csv
cat  is.B-orig.structs-uniq.csv
#+end_src

#+RESULTS:
#+begin_example
Generating producer files
Generating framesoc trace file
Generating Virtual producers file
Generating Physical producers file
Virtual-producers.log Done
Physical-producers.log Done
Reading from Moca-full-trace.csv
770601 accesses on 67715 pages parsed from Moca-full-trace.csv
done in 00 h 00 min 23.992 sec
@Virt,@Phy,Nreads,Nwrites,CPUMask,Start,End,TaskId,Shared
0000000000400040,000062000b1dfa80,1,0,000001011,1,171,0,1
00000000004002a8,000062000b1dfa80,1,0,000001011,32663,34153,0,1
0000000000400bd4,000062000b1dfa80,1,0,000001011,55271,72678,0,1
00000000004009a0,000062000b1dfa80,1,0,000000011,88569,88776,1,1
00000000004009a0,000062000b1dfa80,1,0,000000111,92562,103554,7,1
00000000004009a0,000062000b1dfa80,1,0,000010011,238634,245102,2,1
00000000004009a0,000062000b1dfa80,1,0,001000000,254421,258859,4,1
00000000004009a0,000062000b1dfa80,1,0,001000000,258859,286485,4,2
0000000000400990,000062000b1dfa80,1,0,010000000,258859,286485,6,2
-1,,
__GI___pthread_keys,2196192,16384
__pthread_keys,2196192,16384
key_buff1,6305024,8388608
key_array,14693632,134217728
key_buff2,148911360,134217728
UnnamedStruct#2,283131920,32816
/tmp/NPB3.3-OMP/IS/is.c:494,283137392,4096
/tmp/NPB3.3-OMP/IS/is.c:494-1,283141504,4096
/tmp/NPB3.3-OMP/IS/is.c:494-2,283145616,4096
/tmp/NPB3.3-OMP/IS/is.c:494-3,283149728,4096
/tmp/NPB3.3-OMP/IS/is.c:494-4,283153840,4096
/tmp/NPB3.3-OMP/IS/is.c:494-5,283157952,4096
/tmp/NPB3.3-OMP/IS/is.c:494-6,283162064,4096
/tmp/NPB3.3-OMP/IS/is.c:494-7,283166176,4096
#+end_example


#+begin_src R :results output :session :exports both
computeType <- function(df){
  shared <-9
  write <- 4
  if(df[shared] >= 2){
    mytype <- "Shared"
  }else{
    mytype <- "Private"
  }
  if(df[write] >= 1){
     mytype <- paste(mytype,"Write" , sep="_")
  }else{
     mytype <- paste(mytype,"Read" , sep="_")
  }
  return(mytype)
}

k <- read.csv("Moca-is.B-orig-2016-03-01_14-03-40/Moca-framesoc.csv", header=T);
options("scipen"=100, "digits"=4);
head(k);

sapply(k, class);

names(k) <- c("Address", "Phy", "Reads", "Writes", "CPU", "Start", "End", "Tid", "N");

k$Value <- apply(k,1,computeType)
k$Address <- sprintf("%f", as.numeric(paste("0x", k$Address, sep="")))
k$Phy <- NULL;
k$CPU <- NULL;
k$Tid <- NULL;
#k$Reads <- NULL ;
#k$Writes <- NULL ;
k$Duration <- k$End - k$Start
head(k);

g <- k
structs <- read.csv("Moca-is.B-orig-2016-03-01_14-03-40/is.B-orig.structs-uniq.csv");
names(structs) <- c("Structure", "AddressStart", "AddressSize");
structs$AddressEnd = structs$AddressStart + structs$AddressSize;

library(sqldf);
m <- sqldf("SELECT g.Address, g.Start, g.End, g.Duration, g.Value, g.Reads, g.Writes, g.N, structs.Structure
            FROM g
            INNER JOIN structs
            ON (g.Address >= structs.AddressStart) AND (g.Address <= structs.AddressEnd)");
head(m);
#+end_src

#+RESULTS:
#+begin_example
            X.Virt            X.Phy Nreads Nwrites CPUMask  Start    End TaskId
1 0000000000400040 000062000b1dfa80      1       0    1011      1    171      0
2 00000000004002a8 000062000b1dfa80      1       0    1011  32663  34153      0
3 0000000000400bd4 000062000b1dfa80      1       0    1011  55271  72678      0
4 00000000004009a0 000062000b1dfa80      1       0      11  88569  88776      1
5 00000000004009a0 000062000b1dfa80      1       0     111  92562 103554      7
6 00000000004009a0 000062000b1dfa80      1       0   10011 238634 245102      2
  Shared
1      1
2      1
3      1
4      1
5      1
6      1
   X.Virt     X.Phy    Nreads   Nwrites   CPUMask     Start       End    TaskId 
 "factor"  "factor" "integer" "integer" "integer" "integer" "integer" "integer" 
   Shared 
"integer"
         Address Reads Writes  Start    End N        Value Duration
1 4194368.000000     1      0      1    171 1 Private_Read      170
2 4194984.000000     1      0  32663  34153 1 Private_Read     1490
3 4197332.000000     1      0  55271  72678 1 Private_Read    17407
4 4196768.000000     1      0  88569  88776 1 Private_Read      207
5 4196768.000000     1      0  92562 103554 1 Private_Read    10992
6 4196768.000000     1      0 238634 245102 1 Private_Read     6468
Loading required package: gsubfn
Loading required package: proto
Loading required package: RSQLite
Loading required package: DBI
 Loading required package: tcltk
         Address  Start    End Duration         Value Reads Writes N Structure
1 6307840.000000 279630 283344     3714 Private_Write     1      1 1 key_buff1
2 6307840.000000 310398 410993   100595 Private_Write     1      1 1 key_buff1
3 6307840.000000 452318 485570    33252 Private_Write     1      1 1 key_buff1
4 6307840.000000 485572 511748    26176 Private_Write     1      1 1 key_buff1
5 6307840.000000 511748 521080     9332  Shared_Write     1      1 2 key_buff1
6 6307840.000000 511748 521080     9332  Shared_Write     1      1 2 key_buff1
#+end_example


#+begin_src R :results output graphics :file img/intensity_is_B_orig_threads.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(m) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_is_B_orig_threads.png]]



#+begin_src R :results output :session :exports both
library(plyr)
n <- ddply(m,c("Structure"),summarize,Reads=sum(Reads), Writes=sum(Writes));
o <- n
o$Writes <- NULL
o$Type <- rep("Read", nrow(o))
names(o) <- c("Structure", "N", "Type")
q <- n
q$Reads <- NULL
q$Type <- rep("Write", nrow(o))
names(q) <- c("Structure", "N", "Type")
q <- rbind(q,o)
head(q)
#+end_src

#+RESULTS:
:                       Structure      N  Type
: 1                     key_array  76186 Write
: 2                     key_buff1  59945 Write
: 3                     key_buff2 406236 Write
: 4   /tmp/NPB3.3-OMP/IS/is.c:494     37 Write
: 5 /tmp/NPB3.3-OMP/IS/is.c:494-1     59 Write
: 6 /tmp/NPB3.3-OMP/IS/is.c:494-2     65 Write

#+begin_src R :results output graphics :file img/struct_importance_is_B_orig.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(q,aes(x=Structure,y=N, fill=Type)) +
  theme_bw() +
  geom_bar(stat="identity")
p
#+end_src

#+RESULTS:
[[file:img/struct_importance_is_B_orig.png]]


So far no suprise, the B class looks like the A.

#+begin_src R :results output graphics :file img/intensity_is_B_orig_threads_zoom.png :exports both :width 600 :height 400 :session
library(ggplot2);
r <- m[grepl("key_", m$Structure),]
p <- ggplot(r) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~Value, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_is_B_orig_threads_zoom.png]]

So we can compare this visualisation to the previous one:
[[file:img/intensity_is_threads_zoom.png][file:~/Work/labbook-lucas/img/intensity_is_threads_zoom.png]]

- It seems that there are some writes on keyarray at the end of the
  execution.
- It is still hard to see anything on keybuff1.
- Although keybuff2 patterns differs than on the previous trace, we
  have again the exact same patterns of shared read and writes.

  
#+begin_src R :results output graphics :file img/intensity_is_B_orig_threads_zoom_nacc.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(r) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(Reads+Writes))) +
  facet_grid(Structure~Value, scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_is_B_orig_threads_zoom_nacc.png]]

Still hard to see but there is a little something in the middle of keybuff1
Let's try to zoom as mush as possible:

#+begin_src R :results output graphics :file img/intensity_is_threads_zoom_nacc2.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(subset(r, r$Structure=="key_buff1")) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(Reads+Writes))) +
  facet_grid(Structure~., scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_is_threads_zoom_nacc2.png]]

Still hard to see anything ...
What happens if we do the same zoom on the thread based intensity ?

#+begin_src R :results output graphics :file img/intensity_is_B_orig_threads_zoo2m.png :exports both :width 600 :height 400 :session
library(ggplot2);
p <- ggplot(subset(r,r$Structure=="key_buff1")) +
  theme_bw() +
  geom_segment(size=2, aes(x=Start,xend=End, y=Address,yend=Address, color=as.factor(N))) +
  facet_grid(Structure~., scale="free_y")
  theme_bw() +
  theme(legend.title=element_blank()) +
  theme(legend.background=element_blank());
p
#+end_src

#+RESULTS:
[[file:img/intensity_is_B_orig_threads_zoo2m.png]]

Still hard to see anything ...
Maybe it is harder to see such behavior over the time ...
So next step, compare these results to the modified version, maybe we
will be able to see something.

*** TODO Compare with modified trace
- State "TODO"       from              [2016-03-01 Tue 11:26]
